<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xuanwo&#39;s Blog</title>
  <subtitle>A Long Way to Go</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xuanwo.org/"/>
  <updated>2016-09-12T18:05:34.942Z</updated>
  <id>https://xuanwo.org/</id>
  
  <author>
    <name>Xuanwo</name>
    <email>xuanwo.cn@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态网页数据抓取踩坑分享</title>
    <link href="https://xuanwo.org/2016/09/13/dynamic-page-data-spider/"/>
    <id>https://xuanwo.org/2016/09/13/dynamic-page-data-spider/</id>
    <published>2016-09-13T01:58:33.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<p>之前做了一些数据抓取的工作，期间也踩了一些坑，所以有了这篇文章。</p>
<a id="more"></a>
<h2 id="动态网页数据源获取"><a href="#动态网页数据源获取" class="headerlink" title="动态网页数据源获取"></a>动态网页数据源获取</h2><p>需要抓取的页面是使用<a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> JavaScript 框架开发的，所有的页面都是客户端渲染而成，这也就导致我只能看到一个个的 data-id ，没有办法直接获取数据。这就涉及到一个我之前没有接触过的领域——动态网页爬虫。<br>一番 Google 之后，我了解到动态网页爬虫大致上可以通过以下两种方法实现：</p>
<ul>
<li>分析网页代码结构和请求，找到数据源的请求链接</li>
<li>调用Webkit渲染之后再进行抓取</li>
</ul>
<p>第二种方法相当于在命令行中跑一个浏览器，一个页面一个页面的打开，效率可想而知。再加上待抓取页面的 DOM 结构本来就比较复杂，没有添加相应的 class 和 id，导致即使渲染出来了想要抓到自己需要的数据也非常费劲。<br>于是只能采用第一种方案：分析了一下网页的代码之后发现所有的数据都是通过一个接口返回的。使用 Chrome 审查工具中的 <code>Network</code> 工具可以获取到所有的网络请求，在里面搜索 <code>JSON</code> ，找到了一个 JSON 的请求。点开一看正是我们需要的数据，解决了动态网页数据源的问题。</p>
<h2 id="分类不统一"><a href="#分类不统一" class="headerlink" title="分类不统一"></a>分类不统一</h2><p>这个坑主要出在自己对目标网页的数据特性挖掘的不够。一开始以为目标网页是按照一个特定的分类来区分的，但是后来发现这个标准并不统一，最后抓取到的数据不在一个维度上。正当自己准备开工写很多特判的时候发现，如果从另外一个维度来索取数据的话，所有的数据都是统一的。<br>在这个案例中，就是将人为的分类切换成通过价格来获取数据，通过选择所有价格，就能获取到所有的数据，不需要再对不同维度的分类进行特判。<br>这个与其说是技术问题，更多的是一个经验的问题。</p>
<h2 id="页面内部JS执行"><a href="#页面内部JS执行" class="headerlink" title="页面内部JS执行"></a>页面内部JS执行</h2><p>这个坑就比较有趣了。<br>目标网页除了通过一个特定的接口获取数据之外，还会在页面内部通过 JavaScript 来直接传递数据。背后的技术考量不得而知，但是摆在我面前的问题就是我要如何获取这些 JavaScript 代码中的数据。<br>思考了一下之后想到了两种方案：</p>
<ul>
<li>自行匹配需要的字符串</li>
<li>通过 phatomjs 等工具执行页面内部的 js 代码，并输出需要的数据变量</li>
</ul>
<p>自行匹配的问题在于，我需要匹配的字符串的格式不一，很难直接匹配出我需要的数据。而通过 phatomjs 执行，就能比较好的解决这个问题。</p>
<p>一个比较脏的解决方案是这样的：</p>
<ol>
<li>下载整个HTML页面到 <code>test.html</code></li>
<li>通过 bs4 获取到所有的 <code>&lt;script&gt;</code> 标签内部的内容</li>
<li>将我们需要的那个标签输出到一个 <code>data.js</code> 文件中</li>
<li>之后把将数据构造成 json 的 js 代码写入 <code>data.js</code> 文件</li>
<li>通过 phatomjs 来执行代码</li>
<li>将输出通过 <code>json.loads</code> 载入并 append 到我们的数据数组中</li>
</ol>
<p>这样，我们就获得了页面内部js代码中数据的json形式。</p>
<blockquote>
<p>phatomjs 中执行的代码最后，千万要记得加上 <code>phatom.exit()</code>，否则不会自行退出。</p>
</blockquote>
<h2 id="phatomjs报错"><a href="#phatomjs报错" class="headerlink" title="phatomjs报错"></a>phatomjs报错</h2><p><a href="https://cli.xuanwo.org/Tools/phatomjs.html#qxcbconnection-could-not-connect-to-display" target="_blank" rel="external">https://cli.xuanwo.org/Tools/phatomjs.html#qxcbconnection-could-not-connect-to-display</a></p>
<p>当代码放到服务器上运行时候，出现了这样的报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QXcbConnection: Could not connect to display</span><br></pre></td></tr></table></figure>
<p>这是因为源中的phatomjs默认运行在图形界面下，只需要在运行前执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QT_QPA_PLATFORM=offscreen</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>这个坑就比较隐蔽了，重复调试了很久。<br>在前面的流程中，我们有一个下载HTML页面并使用bs4解析的步骤。我之前的实现是通过<code>subprocess.Popen()</code>直接调用 <code>curl</code> 之后，就打开<code>test.html</code>。这样的实现导致了这样的一个问题：有可能网页还没有下载完，我就开始进行解析了，这样就会导致我的解析内容跟本就不正确。也就是说，<code>subprocess.Popen()</code> 不是一个阻塞的过程，它在调用完 <code>curl</code> 之后不会等到 <code>curl</code> 返回再结束。<br>定位到问题的话，解决起来就很容易了。通过查阅文档，我知道了可以通过这种方法来保证命令执行完毕再执行下一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">child = subprocess.Popon(&quot;curl xxxx.com &gt; test.html&quot;, shell=True)</span><br><span class="line">child.wait()</span><br></pre></td></tr></table></figure>
<h2 id="回顾-amp-总结"><a href="#回顾-amp-总结" class="headerlink" title="回顾 &amp; 总结"></a>回顾 &amp; 总结</h2><p>这个小小的玩意儿开发没花多久，但是学到了很多东西。从之前自己一直以为很难不敢尝试的动态网页抓取到 Python subprocess 线程调度，果然不踩坑就不会有新的收获。<br>这次开发的东西比较敏感，涉及到公司内部的一些事务，所以代码就不开源出来了。有什么想法或者问题可以直接在评论区里提出来，我会尽量回复的。因为是一个一次性的小套件，所以没有怎么考虑优化上的事情，如果有更好的解决方案，也欢迎大家一起探讨，说不定下次就用上了呢~</p>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前做了一些数据抓取的工作，期间也踩了一些坑，所以有了这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="QingCloud" scheme="https://xuanwo.org/tags/QingCloud/"/>
    
      <category term="Work" scheme="https://xuanwo.org/tags/Work/"/>
    
      <category term="爬虫" scheme="https://xuanwo.org/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>nodebb-plugin-html5videoplayer 发布</title>
    <link href="https://xuanwo.org/2016/08/22/nodebb-plugin-html5videoplayer/"/>
    <id>https://xuanwo.org/2016/08/22/nodebb-plugin-html5videoplayer/</id>
    <published>2016-08-22T17:53:25.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<p><a href="">nodebb-plugin-html5videoplayer</a> 是一个简单的 NodeBB 插件，可以让 NodeBB 支持在线视频观看。Fork 自 <a href="https://github.com/ogerly" target="_blank" rel="external">@ogerly</a> 开发的 <a href="https://github.com/ogerly/nodebb-plugin-videoplayer" target="_blank" rel="external">nodebb-plugin-videoplayer</a>， 在他的基础上做了一些微不足道的贡献，括弧笑。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理非常简单，将帖子中出现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;xxx.mp4&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>标签转换为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video preload controls&gt;</span><br><span class="line">  &lt;source src=&quot;xx.mp4&quot;&gt;</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>也就是完全通过 HTML5 提供的 video 标签来实现在线视频的观看功能。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>世上轮子千千万，我为什么要Fork原来的再造一个？</p>
<p>最关键的因素在于我跟原作者的理念不太一样，原作者除了插入 video 标签以外，还提供了一个固定在下面下方的播放器控制条。由于版本更迭，这个播放器控制条已经失效，CSS 样式也不再适用。因此我 Fork 了原作者的插件，并上传了一个新的插件，旨在提供更简单的在线视频视频集成功能。</p>
<p>跟原来版本的区别主要如下：</p>
<ul>
<li>纯粹的播放器，没有多余的功能，不会修改任何页面外观</li>
<li>页面自适应，播放窗体会自适应当前页面大小，提供跨平台一致的体验</li>
<li>更强的外链支持，可以引用外部的链接，不需要上传到论坛</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>目前还不知道怎么提交到 NodeBB 的插件的中心，因此只能通过 npm 手动进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nodebb-plugin-html5videopalyer</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用起来非常简单，只需要在帖子中拖动上传视频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[video](/uploads/files/xyz.mp4)</span><br></pre></td></tr></table></figure>
<p>或者直接输入引用的视频链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[video](//aa.com/bb/cc.mp4)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前仅支持<code>mp4</code>，<code>ogv</code>,<code>webm</code>,<code>mov</code>这四种格式<br>引用的外链需要去掉协议头，否则无法正常解析</p>
</blockquote>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>最后显示的效果可以参考这个链接： <a href="https://community.qingcloud.com/topic/556" target="_blank" rel="external">https://community.qingcloud.com/topic/556</a></p>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;&quot;&gt;nodebb-plugin-html5videoplayer&lt;/a&gt; 是一个简单的 NodeBB 插件，可以让 NodeBB 支持在线视频观看。Fork 自 &lt;a href=&quot;https://github.com/ogerly&quot;&gt;@ogerly&lt;/a&gt; 开发的 &lt;a href=&quot;https://github.com/ogerly/nodebb-plugin-videoplayer&quot;&gt;nodebb-plugin-videoplayer&lt;/a&gt;， 在他的基础上做了一些微不足道的贡献，括弧笑。&lt;/p&gt;
    
    </summary>
    
      <category term="Develope" scheme="https://xuanwo.org/categories/Develope/"/>
    
    
      <category term="JavaScript" scheme="https://xuanwo.org/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://xuanwo.org/tags/Node-js/"/>
    
      <category term="NodeBB" scheme="https://xuanwo.org/tags/NodeBB/"/>
    
  </entry>
  
  <entry>
    <title>NodeBB 升级迁移总结</title>
    <link href="https://xuanwo.org/2016/07/08/nodebb-upgrade/"/>
    <id>https://xuanwo.org/2016/07/08/nodebb-upgrade/</id>
    <published>2016-07-08T10:00:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://community.qingcloud.com/" target="_blank" rel="external">青云用户社区</a>使用了开源的 NodeBB 论坛，部署之初使用<code>0.7</code>版本，因为没有跟随官方进度进行更新，导致论坛版本长期停滞。一方面无法享受到官方的BUG Fix，另一方面也无法使用很多业务需求的插件。思量再三后决定对社区进行升级迁移，不在原论坛直接升级，而是部署一套新的环境，将原有的数据全部导出。</p>
<a id="more"></a>
<h1 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h1><h2 id="NodeBB-升级路径"><a href="#NodeBB-升级路径" class="headerlink" title="NodeBB 升级路径"></a>NodeBB 升级路径</h2><p>NodeBB 自0.3版本后就提供了一套独特升级路径，主要有以下几个要点：</p>
<ul>
<li>NodeBB采用语义化版本号：<code>x.y.z</code></li>
<li>对<code>z</code>版本号的变动，可以直接升级</li>
<li>只有当<code>z</code>版本号已经是<code>x.y</code>版本下的最新版本，才能升级到<code>x.y+1</code></li>
</ul>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>NodeBB在部署的时候就使用了青云平台上的 Redis 缓存和负载均衡器。这样迁移的问题就会变的简单很多，我只需要将 NodeBB 路径下的<code>public/uploads</code>资源进行打包即可，Redis 缓存和负载均衡器都可以直接使用。</p>
<h1 id="迁移步骤"><a href="#迁移步骤" class="headerlink" title="迁移步骤"></a>迁移步骤</h1><h2 id="迁移-NodeBB"><a href="#迁移-NodeBB" class="headerlink" title="迁移 NodeBB"></a>迁移 NodeBB</h2><p>建议在一个新的环境里面创建迁移环境。</p>
<h3 id="Node-版本"><a href="#Node-版本" class="headerlink" title="Node 版本"></a>Node 版本</h3><p>同样建议使用 <code>nvm</code> 来管理版本，避免其他应用对NodeBB环境产生干扰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm install stable</span><br><span class="line">nvm use stable</span><br></pre></td></tr></table></figure>
<p>如果不想每一次退出shell后都要执行<code>nvm use stable</code>，可以手动设置默认版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvm alias default stable</span><br></pre></td></tr></table></figure>
<h3 id="NodeBB-版本"><a href="#NodeBB-版本" class="headerlink" title="NodeBB 版本"></a>NodeBB 版本</h3><p>首先下载跟生产环境一致的NodeBB版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b v0.7.x</span><br></pre></td></tr></table></figure>
<p>然后使用跟生产环境一致的<code>config.json</code>，NoedBB升级工具会自动更新<code>package.json</code>，所以无需修改。</p>
<p>然后运行<code>./nodebb upgrade</code>以升级数据结构和依赖并打上所有的补丁。</p>
<p>运行完毕后切换到更高版本的分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout v0.8.x</span><br></pre></td></tr></table></figure>
<p>同样运行<code>./nodebb upgrade</code>，以此类推，直至升级到官方最新版本。</p>
<h2 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h2><p>正如之前所说的，Redis已经被直接升级到最新版本，接下来只需要将用户上传的数据导出即可。</p>
<p>在生产环境中执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /path/to/nodebb/public</span><br><span class="line">tar -cvf nodebb_assets_backup.tar.gz ./upload</span><br></pre></td></tr></table></figure>
<p>切换到迁移环境后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /path/to/nodebb/public</span><br><span class="line">tar -xvf nodebb_assets_backup.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>目前NodeBB不支持降级操作，如果担心破坏生产环境，可以在生成一个 Redis 的备份并重新创建资源，不要对原数据库进行操作。</li>
<li>由于 Redis 中会保存对原论坛的主题和插件等配置，在迁移到新版本后，有很大可能会产生错误，可以执行<code>./nodebb reset -a</code>以清除所有主题和插件配置。确认 NodeBB 运行正常后再逐个启用即可。</li>
<li>在升级时候会因为Node.js版本的问题导致某些依赖无法安装，建议可以使用<code>0.12</code>版本进行升级，升级成功后再切换到更新的版本上重新进行<code>npm install --production</code></li>
</ul>
<h1 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h1><h2 id="NodeBB的升级路线设计"><a href="#NodeBB的升级路线设计" class="headerlink" title="NodeBB的升级路线设计"></a>NodeBB的升级路线设计</h2><p>这次升级迁移其实经历很久的论证过程。<br>一开始简单地尝试一下之后认定无法直接进行升级就产生了一些畏难情绪，心里想着不如就让它这样，反正现在线上跑得也挺好的，没有出什么太大的问题。而后种种需求的提出让我有些招架不住了，现有的落后版本缺少很多API和现有的插件，自行开发和维护的成本非唱高。这也是我有一段时间觉得开源在实际应用中并不是那么美好的原因。<br>等到我真的沉下心来仔细研究官方的文档，才发现 NodeBB 看似鬼畜坑爹的升级路线设计其实也有着其优雅之处。数据库的结构可以随之版本同步更新，这样可以避免早期数据库结构设计不合理带来的种种弊端，并防止产生版本之间的Breaking Change。抛开API层面的兼容性不谈，NodeBB可以做到我直接使用原来的 Redis 从 <code>0.7.0</code> 一路升级到 <code>1.0.4</code>，还能保证我的数据没有出现任何丢失，就冲着这一点，我觉得这个升级路线的设计是有价值的。<br>当然，路线是好的，但是在具体实现升级功能的时候还有待商榷之处：不难发现升级过程中有很大一部分的重复操作，其实这些都是可以避免的。每一个<code>x.y</code>版本号之间的更新操作其实都是一致的，完全可以通过脚本实现。</p>
<h2 id="应用部署的灵活性"><a href="#应用部署的灵活性" class="headerlink" title="应用部署的灵活性"></a>应用部署的灵活性</h2><p>上线任何应用之前都应该考虑其架构的扩展性和迁移能力。<br>很多时候，部署一套应用的目的根本就不是为了去使用他，只是单纯的部署一个玩一玩而已。在这样的心态下，总会干出这样的事情：在一个20G的主机上跑ownCloud；在一个主机上同时跑wordpress，nginx和mysql等应用。当然，这样做并没有什么问题，毕竟是自己的Server，哪怕天天 <code>rm -rf /</code>都是OK的。<br>但是如果是一套需要给别人用的应用，部署时的扩展性和迁移能力就必须考虑在内。这其实是两个很实在的问题：服务器空间耗尽，性能跟不上怎么办？服务器挂了，如何保全自己的数据？自己设计这样一套系统很麻烦，但是如果是在青云上就不一样了。我最喜欢青云的一点就是，青云几乎所有的资源都是可以动态伸缩和扩展的。带宽受限制了，直接扩大；服务器性能不够了，加核心加内存；单个服务器支撑不住了，批量生成十个并使用负载均衡器进行负载均衡操作；想要测试某个最新的特性，直接从线上创建一个Snapshot并生成资源进行测试。<br>在本次迁移的过程中，我们就可以看出来，我们可以直接使用 Redis 进行升级，而不是手动导出数据库备份再执行导入操作。同样地，我们也不需要再重新配置一遍 Nginx ，只需要再创建一个负载均衡器即可。</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年07月08日 首次发布</li>
<li>2016年07月15日 青云社区成功上线</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://community.qingcloud.com/&quot;&gt;青云用户社区&lt;/a&gt;使用了开源的 NodeBB 论坛，部署之初使用&lt;code&gt;0.7&lt;/code&gt;版本，因为没有跟随官方进度进行更新，导致论坛版本长期停滞。一方面无法享受到官方的BUG Fix，另一方面也无法使用很多业务需求的插件。思量再三后决定对社区进行升级迁移，不在原论坛直接升级，而是部署一套新的环境，将原有的数据全部导出。&lt;/p&gt;
    
    </summary>
    
      <category term="Operate" scheme="https://xuanwo.org/categories/Operate/"/>
    
    
      <category term="JavaScript" scheme="https://xuanwo.org/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://xuanwo.org/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>新博客上线&amp;Hexo主题开发入门</title>
    <link href="https://xuanwo.org/2016/06/29/new-blog-new-life/"/>
    <id>https://xuanwo.org/2016/06/29/new-blog-new-life/</id>
    <published>2016-06-29T23:06:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>曾经看过我的博客的同学大概都会发现，我的博客再一次大变样了~<br>这一次的更新其实酝酿了很久，早在刚开始用Hexo的时候就想着要有一个自己的主题。但是那个时候觉得这是一件很难的事情，要懂HTML，CSS，JavaScript，还要懂Swig，Ejs等模板语言，还要懂Hexo的内部原理，于是就一直搁置了。在独立实现了一个<a href="https://xuanwo.org/2016/06/16/jade_ims/">完整的项目</a>之后，我认为自己已经有这样的能力了，于是决定正式开始。<br>在我看来的话，Hexo的使用者大概分为三个层次：第一种用别人的主题，第二种模仿现有的主题，第三种自己独立开发。我原来是第一种，在Next的基础上做了很多改动，这一次进入到了第二个层次。我找了一套自我感觉还不错的模板，然后套用它的CSS设定和页面结构，就成了我现在的主题。<br>利用两天学习和工作的闲暇时间，我大体上完成了这个主题。做得比较糙，很多细节还有待优化，但是我已经急不可耐地想要正式上线了，笑。在未来的话，我希望能把一些配置都能整理出来，优化一下代码，然后开源这个主题，希望大家能够喜欢~<br>庆祝的话已经说的差不多了，下面来讲一讲如何开发一个Hexo主题。</p>
<a id="more"></a>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="主题结构"><a href="#主题结构" class="headerlink" title="主题结构"></a>主题结构</h2><p>Hexo主题的结构大体如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">│   ├── default.yml</span><br><span class="line">│   └── zh-Hans.yml</span><br><span class="line">├── layout</span><br><span class="line">│   ├── achieve.swig</span><br><span class="line">│   ├── category.swig</span><br><span class="line">│   ├── index.swig</span><br><span class="line">│   ├── _layout.swig</span><br><span class="line">│   ├── page.swig</span><br><span class="line">│   ├── _partials</span><br><span class="line">│   ├── post.swig</span><br><span class="line">│   └── tag.swig</span><br><span class="line">└── <span class="built_in">source</span></span><br><span class="line">    ├── css</span><br><span class="line">    ├── fonts</span><br><span class="line">    ├── img</span><br><span class="line">    ├── js</span><br><span class="line">    └── vendors</span><br></pre></td></tr></table></figure>
<p>首先有一个<code>_config.yml</code>负责提供主题级别的配置，可以在<code>layout</code>中通过<code>theme.xxx</code>的形式进行调用。<br>然后<code>languages</code>负责实现博客的i18N功能，如果博客没有多语言的需求，只需要实现一个<code>default.yml</code>即可。<br>其次是最为重要的<code>layout</code>文件夹，这个里面主要存放博客的结构，Hexo 引擎会使用指定的渲染引擎将<code>layout</code>文件渲染成HTML页面。<br>最后是<code>source</code>，把所有主题需要用到的资源，比如CSS，Fonts，JS等都存放到这个文件夹中。</p>
<p>这个主题使用了<a href="http://paularmstrong.github.io/swig/" target="_blank" rel="external">swig</a>。</p>
<h2 id="页面结构"><a href="#页面结构" class="headerlink" title="页面结构"></a>页面结构</h2><p>页面结构分为两个维度，一者是我要呈现哪些页面，二者是每个页面上都有哪些内容。</p>
<h3 id="哪些页面？"><a href="#哪些页面？" class="headerlink" title="哪些页面？"></a>哪些页面？</h3><p>作为一个博客，主要需要的页面有以下这些：</p>
<ul>
<li>主页</li>
<li>单页</li>
<li>归档页面</li>
<li>分类页面</li>
<li>标签页面</li>
<li>文章页</li>
</ul>
<h3 id="哪些内容？"><a href="#哪些内容？" class="headerlink" title="哪些内容？"></a>哪些内容？</h3><p>如果没有什么特别的设计，博客的页面大体上可以分为这几个部分：</p>
<ul>
<li>head：头部文件</li>
<li>body：主体内容<ul>
<li>header：题图，导航栏等</li>
<li>content： 内容</li>
<li>footer：尾部的联系方式等</li>
</ul>
</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>前面讲到了 Hexo 的结构，下面来聊一聊具体的实现。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Hexo 渲染的入口是<code>_layout.swig</code>，所以一个主题至少需要实现一个<code>_layout.swig</code>。<br>然后Hexo会遍历Hexo目录下<code>source</code>文件夹中的所有Markdown文件，根据Markdown文件所指定的layout进行渲染，默认类型为<code>post</code>。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="layout-swig结构"><a href="#layout-swig结构" class="headerlink" title="_layout.swig结构"></a>_layout.swig结构</h3><p>整体的结构基本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &#123;% include &apos;_partials/head.swig&apos; %&#125;</span><br><span class="line">    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body id=&quot;home&quot;&gt;</span><br><span class="line">    &#123;% include &apos;_partials/menu.swig&apos; %&#125;</span><br><span class="line">    &lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">        &#123;% include &apos;_partials/nav.swig&apos; %&#125;</span><br><span class="line">        &#123;% include &apos;_partials/header.swig&apos; %&#125;</span><br><span class="line">        &lt;div id=&quot;start&quot; class=&quot;container content&quot;&gt;</span><br><span class="line">            &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &#123;% include &apos;_partials/footer.swig&apos; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="实现文章渲染"><a href="#实现文章渲染" class="headerlink" title="实现文章渲染"></a>实现文章渲染</h3><p>这个地方主要是借鉴了NexT主题的设计，实现了一个swig的宏来生成对应的文章。这个宏主要有两个参数，第一个是post对象，第二个是是否为主页。如果是主页就只显示简略的内容，如果不是就输出全文。</p>
<p>判断的部分实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if is_index %&#125;</span><br><span class="line">    &#123;% if post.excerpt %&#125;</span><br><span class="line">        &#123;&#123; post.excerpt &#125;&#125;</span><br><span class="line">        &lt;a class=&quot;&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;Read more&lt;/a&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">    &#123;&#123; post.content &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>用到的post页的参数可以<a href="https://hexo.io/zh-cn/docs/variables.html" target="_blank" rel="external">我翻译的中文文档</a></p>
<h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>Hexo 自己实现了一个分页插件，直接使用paginator函数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.prev or page.next %&#125;</span><br><span class="line">    &lt;nav class=&quot;pagination&quot;&gt;</span><br><span class="line">        &#123;&#123; paginator(&#123;</span><br><span class="line">            prev_text: &apos;&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">            next_text: &apos;&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;&apos;,</span><br><span class="line">            mid_size: 1</span><br><span class="line">        &#125;) &#125;&#125;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>对于Hexo来说，评论系统就是调用一个第三方的JS。所以只需要在合适的位置插入代码即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var disqus_config = function () &#123;</span><br><span class="line">        this.page.url = &apos;&#123;&#123; page.permalink &#125;&#125;&apos;;</span><br><span class="line">        this.page.identifier = &apos;&#123;&#123; page.path &#125;&#125;&apos;;</span><br><span class="line">    &#125;;</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var d = document, s = d.createElement(&apos;script&apos;);</span><br><span class="line">        s.src = &apos;//abc.disqus.com/embed.js&apos;;</span><br><span class="line">        s.setAttribute(&apos;data-timestamp&apos;, +new Date());</span><br><span class="line">        (d.head || d.body).appendChild(s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h1><ul>
<li><code>page.posts</code>是按照时间排序的，但是<code>site.posts</code>是无序的。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo 官方中文文档</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年06月30日 首次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;曾经看过我的博客的同学大概都会发现，我的博客再一次大变样了~&lt;br&gt;这一次的更新其实酝酿了很久，早在刚开始用Hexo的时候就想着要有一个自己的主题。但是那个时候觉得这是一件很难的事情，要懂HTML，CSS，JavaScript，还要懂Swig，Ejs等模板语言，还要懂Hexo的内部原理，于是就一直搁置了。在独立实现了一个&lt;a href=&quot;https://xuanwo.org/2016/06/16/jade_ims/&quot;&gt;完整的项目&lt;/a&gt;之后，我认为自己已经有这样的能力了，于是决定正式开始。&lt;br&gt;在我看来的话，Hexo的使用者大概分为三个层次：第一种用别人的主题，第二种模仿现有的主题，第三种自己独立开发。我原来是第一种，在Next的基础上做了很多改动，这一次进入到了第二个层次。我找了一套自我感觉还不错的模板，然后套用它的CSS设定和页面结构，就成了我现在的主题。&lt;br&gt;利用两天学习和工作的闲暇时间，我大体上完成了这个主题。做得比较糙，很多细节还有待优化，但是我已经急不可耐地想要正式上线了，笑。在未来的话，我希望能把一些配置都能整理出来，优化一下代码，然后开源这个主题，希望大家能够喜欢~&lt;br&gt;庆祝的话已经说的差不多了，下面来讲一讲如何开发一个Hexo主题。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Hexo" scheme="https://xuanwo.org/tags/Hexo/"/>
    
      <category term="Blog" scheme="https://xuanwo.org/tags/Blog/"/>
    
      <category term="Nodejs" scheme="https://xuanwo.org/tags/Nodejs/"/>
    
      <category term="HTML" scheme="https://xuanwo.org/tags/HTML/"/>
    
      <category term="JavaScript" scheme="https://xuanwo.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>马可波罗珠宝进销存系统开发手记</title>
    <link href="https://xuanwo.org/2016/06/16/jade_ims/"/>
    <id>https://xuanwo.org/2016/06/16/jade_ims/</id>
    <published>2016-06-16T22:00:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/imgs/develop/jade-ims-index.png" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个项目从我们这个学期开了<strong>系统分析与设计</strong>这门课之后就开始了，首次创建这个项目是在3月26号，实际上真正的开发时间集中在6月上旬。差不多用两个星期的闲暇时间时间完成了这个简单的进销存系统。这个系统基于Flask框架，使用SQLite3数据库，前端则是使用Bootstrap框架，实现了包括客户，库存，销售，进货等管理子系统。说是管理，其实也就是简单的增加和删除而已。<br>前人经常说，不要重复造轮子。既然有类似于Odoo这样强大的ERP系统珠玉在前，我为什么要再自己造一个功能简单，甚至根本不会有人用的轮子呢？从前我确实是这么想的，但是稍微有一点工作经验之后发现再造轮子的原因有两条：</p>
<ul>
<li>作为一个处在知识积累阶段的学生而言，再造轮子很有必要。不造一次轮子，你就永远不会明白轮子内部的真实构造。很多技术虽然看起来简单，但是想要有一个完善且健壮的实现却有很多坑需要踩。踩这些坑的过程，也正是一个技术人员成长最快的过程。</li>
<li>别人的轮子终究是别人的。你不知道这个轮子最大能承受多少压力，你也不知道这个轮子在什么样的情况下会爆胎。当一个轮子装上企业呼呼向前的列车，再要想把它替换下来是一件很难且成本很高的事情。</li>
</ul>
<p>接下来，讲讲造这个轮子的一些经历吧~</p>
<a id="more"></a>
<h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>正如前言中说的，这个项目是系统分析与设计这门课的课程设计，也是贯穿着整个学期的一个主旋律。早在这学期开学之初，我们就知道了自己需要做这样的一个系统。经历了上个学期各种技术炫了半天，最后却只是抄袭各种开源项目草草实现的<a href="https://xuanwo.org/2015/06/30/together-project/">失败</a>，这个学期我务实了很多。从最开始的讨论就一直跟组员强调技术的可行性，基本上否决了所有试图增大项目复杂度的建议，把主题定在了一个纯粹的进销存管理系统。之所以如此，是因为我的观念发生了很大的变化：原来觉得技术的先进是最重要的，开发项目一定要用最现代的技术，最炫目的特效；现在觉得哪怕是一个用VB写出来的能稳定运行的丑陋系统都要胜过采用了种种最新潮技术却漏洞百出根本没法运行的“先进”系统。<br>在讨论到最极端的时候，我甚至想只做一个仓库的管理系统，只包括进库和出库这样的简单功能。这样的态度曾经闹得有一次讨论直接不欢而散，好在组员都是非常Nice的人，在我主动表达歉意之后大度地表示没什么。经过多次讨论之后，我们终于达成了共识，要做一个进销存系统，功能尽可能简单，在实现基础功能的前提下，再考虑加入新的功能。<br>接下来的事情就没有什么大的分歧了，整体系统采用B/S架构，开发语言选用我个人比较喜欢的Python，使用Flask框架，数据库选用无需配置的SQLite。然后服务器选择阿里云的学生机，系统选择成熟稳定的CentOS 7.2，Web Server选用Nginx，也就是我个人目前比较喜欢的开发平台——LESP(Linux, Nginx, SQLite, Python)。</p>
<h1 id="项目细节"><a href="#项目细节" class="headerlink" title="项目细节"></a>项目细节</h1><p>下面再介绍一下项目的细节。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>项目大体上采用了MVC的思想，不过在具体的实现上并没有太过纠结于概念上的东西。所有的网页模板都在<code>templates</code>文件夹下，静态资源都扔到了<code>static</code>目录，使用一个<code>models.py</code>模块来单独存放所有的数据库定义，然后所有的路由以及操作都在<code>views</code>中实现。对于我来说，快速地实现需求才是头等大事，是不是符合正统的MVC理念并不是十分重要。实际上现在这样的结构开发起来感觉也蛮顺手的，需要调整前端的样式和表单就在<code>templates</code>文件夹下操作，需要修改程序的逻辑就去<code>views</code>，他们基本上是一一对应的关系。<a href="https://spacewander.github.io/explore-flask-zh/4-organizing_your_project.html" target="_blank" rel="external">这里</a>有更加清晰的讲解，值得一看。</p>
<h2 id="项目中的问题-amp-解决方案"><a href="#项目中的问题-amp-解决方案" class="headerlink" title="项目中的问题&amp;解决方案"></a>项目中的问题&amp;解决方案</h2><h3 id="在Flask框架中同时使用蓝图与Flask-SQLAlchemy"><a href="#在Flask框架中同时使用蓝图与Flask-SQLAlchemy" class="headerlink" title="在Flask框架中同时使用蓝图与Flask_SQLAlchemy"></a>在Flask框架中同时使用蓝图与Flask_SQLAlchemy</h3><p><a href="https://segmentfault.com/q/1010000005640527" target="_blank" rel="external">https://segmentfault.com/q/1010000005640527</a></p>
<p><em>感谢@Ethan和@，他们强有力地向我证明了有师傅带路的好处。</em></p>
<p>这个问题纯粹是因为一直以来都是一个脚本Boy，没有系统性的学习过软件开发导致的。很显然，按照我原来的代码去产生实例，就会导致循环导入的错误。想要解决这样的问题，就需要使用工厂函数去生成实例，而不是自己去生成它。</p>
<p>在<code>__init__.py</code>中添加一个<code>create_app()</code>函数，在函数中进行参数配置，初始化和导入蓝图的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bps = [<span class="string">'jade_ims.views.dashboard:dashboard'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.install:install'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.login:login'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.sale:sale'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.customer:customer'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.purchase.inputbill:inputbill'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.purchase.supplier:supplier'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.stock.enterstockbill:enterstockbill'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.stock.leavestockbill:leavestockbill'</span>,</span><br><span class="line">       <span class="string">'jade_ims.views.stock.stock:stock'</span></span><br><span class="line">       ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span><span class="params">()</span>:</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config.from_object(<span class="string">'config'</span>)</span><br><span class="line">    app.config.from_pyfile(<span class="string">'config.py'</span>)</span><br><span class="line"></span><br><span class="line">    db.init_app(app)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> bps:</span><br><span class="line">        bp = import_string(path)</span><br><span class="line">        app.register_blueprint(bp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>
<h3 id="Flask如何优雅地重定向所有未登录用户到登陆界面"><a href="#Flask如何优雅地重定向所有未登录用户到登陆界面" class="headerlink" title="Flask如何优雅地重定向所有未登录用户到登陆界面"></a>Flask如何优雅地重定向所有未登录用户到登陆界面</h3><p><a href="https://segmentfault.com/q/1010000005645821" target="_blank" rel="external">https://segmentfault.com/q/1010000005645821</a></p>
<p><em>感谢@zwillon和@igaozp</em></p>
<p>有一个Feature是想要把所有未登录的用户都重定向到登录页面。当时手头上的技术方案主要有两种：第一种是自己包装一个装饰器，并添加在每一个视图函数中；第二种是使用第三方库<code>Flask-Login</code>，在视图函数中添加<code>@login_required</code>。但是感觉姿势都不怎么优雅，因为我需要不断地在视图函数中添加这个装饰器，不太符合DRY(Don’t Repeat Yourself)准则。<br>SF的老司机给了我一个相当优雅的方案——Hook到app的<code>before_request</code>方法。也就是这样来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_need_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 检查登录的逻辑</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>我第一次是这样实现的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_need_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'logged_in'</span> <span class="keyword">not</span> <span class="keyword">in</span> session:</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login.user_login'</span>))</span><br></pre></td></tr></table></figure>
<p>这样就带来了一个问题，对于未登录的用户来说，所有页面都会不断地重定向从而导致整个应用崩溃。因此还需要指定在某些情况下停止重定向，所以我们还需要修改一下<code>check_need_login</code>的逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_need_login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'logged_in'</span> <span class="keyword">not</span> <span class="keyword">in</span> session <span class="keyword">and</span> request.endpoint <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'login.user_login'</span>, <span class="string">'static'</span>):</span><br><span class="line">        <span class="keyword">return</span> redirect(url_for(<span class="string">'login.user_login'</span>))</span><br></pre></td></tr></table></figure>
<p>当<code>session</code>中没有<code>logged_in</code>字段且<code>endpoint</code>不是<code>user_login</code>和<code>static</code>的时候就重定向到登录页面，这样就比较优雅地解决了重定向未登录用户到登陆界面的需求。</p>
<h3 id="flask-sqlalchemy-插入数据时发生错误后如何处理"><a href="#flask-sqlalchemy-插入数据时发生错误后如何处理" class="headerlink" title="flask_sqlalchemy 插入数据时发生错误后如何处理"></a>flask_sqlalchemy 插入数据时发生错误后如何处理</h3><p><a href="https://segmentfault.com/q/1010000005647431" target="_blank" rel="external">https://segmentfault.com/q/1010000005647431</a></p>
<p>在实际开发的过程中发现，如果<code>db.session</code>中添加的记录有问题，在commit的时候会出现一个报错。所以我们需要在出错的时候进行一些处理，以保证程序出错之后还能够正常地运行。网友 @学不会编程的永仲 给出的回答是我应该在form中验证数据的正确性。虽然我相信他的理解可能是正确的，但是不太符合我的哲学，我更加倾向于<strong>让它崩溃，然后处理异常</strong>而不是<strong>事先处理好所有的错误</strong>。<br>通过查阅文档，了解到<code>db.session.rollback()</code>这一函数可以在出错是进行回滚，于是最后的实现变成了这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@supplier.route('/purchase/supplier/add', methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_supplier</span><span class="params">()</span>:</span></span><br><span class="line">    form = request.form</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        print(form)</span><br><span class="line">        supplier = Supplier(form[<span class="string">'supplier_name'</span>],</span><br><span class="line">                            form[<span class="string">'supplier_constract'</span>],</span><br><span class="line">                            form[<span class="string">'supplier_phone'</span>],</span><br><span class="line">                            form[<span class="string">'supplier_address'</span>],</span><br><span class="line">                            form[<span class="string">'supplier_remark'</span>])</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            db.session.add(supplier)</span><br><span class="line">            db.session.commit()</span><br><span class="line">            flash(<span class="string">'供应商添加成功！'</span>, <span class="string">'success'</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            db.session.rollback()</span><br><span class="line">            flash(<span class="string">'输入不合法，请重新输入！'</span>, <span class="string">'danger'</span>)</span><br><span class="line">    <span class="keyword">return</span> redirect(url_for(<span class="string">'supplier.list_supplier'</span>))</span><br></pre></td></tr></table></figure>
<h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><p>随着答辩的完成，这个项目进入了尾声。因为很多东西需要去学习，有新的东西需要去探索，所以这个项目也很有可能不会再继续维护了。那么这个项目开源出来的价值在哪里呢？我想，这个项目虽然简单，但它毕竟还算是一个完整的Flask项目，除了<code>flask_sqlalchemy</code>之外没有多余的依赖，非常适合一个跟我一样的Python初学者进行入门学习。如果说有人能够因为这个项目少走一些弯路，少在一些死胡同浪费时间，我想这个项目的价值就已经实现了。如果再往大一点来说，开源的价值也就实现了。<br>如果要我自评的话，我觉得这样的项目应该有60分。之所以给一个及格分，是因为这个项目毕竟实现了需求的大多数功能，也有好好地跑在阿里云的服务器上。丢分的话，大体上是因为这个项目毫无注释，没有安装文档，也没有配置手册，很多东西都是硬编码到了代码中。不仅如此，编程的风格也是相当的不佳，在模板部分缺乏良好的顶层设计，出现了大量的重复代码。这些问题希望自己能在下一个项目中得到一些改善。<br>Anyway，随着这个项目的结束，我的大三生涯也要结束了。接下来是波澜壮阔的实习阶段，希望自己能够在实习的时候多踩一些坑，多走一些弯路，多<br>得到一些来自“长者”的指点。</p>
<h1 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h1><ul>
<li><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="external">Flask 中文文档 <em>文档略有过时，代码以Github上为准</em></a></li>
<li><a href="https://spacewander.github.io/explore-flask-zh/index.html" target="_blank" rel="external">Flask 之旅</a></li>
<li><a href="http://docs.jinkan.org/docs/flask-sqlalchemy/index.html" target="_blank" rel="external">Flask-SQLALchemy 中文文档</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年06月17日 首次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/imgs/develop/jade-ims-index.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这个项目从我们这个学期开了&lt;strong&gt;系统分析与设计&lt;/strong&gt;这门课之后就开始了，首次创建这个项目是在3月26号，实际上真正的开发时间集中在6月上旬。差不多用两个星期的闲暇时间时间完成了这个简单的进销存系统。这个系统基于Flask框架，使用SQLite3数据库，前端则是使用Bootstrap框架，实现了包括客户，库存，销售，进货等管理子系统。说是管理，其实也就是简单的增加和删除而已。&lt;br&gt;前人经常说，不要重复造轮子。既然有类似于Odoo这样强大的ERP系统珠玉在前，我为什么要再自己造一个功能简单，甚至根本不会有人用的轮子呢？从前我确实是这么想的，但是稍微有一点工作经验之后发现再造轮子的原因有两条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为一个处在知识积累阶段的学生而言，再造轮子很有必要。不造一次轮子，你就永远不会明白轮子内部的真实构造。很多技术虽然看起来简单，但是想要有一个完善且健壮的实现却有很多坑需要踩。踩这些坑的过程，也正是一个技术人员成长最快的过程。&lt;/li&gt;
&lt;li&gt;别人的轮子终究是别人的。你不知道这个轮子最大能承受多少压力，你也不知道这个轮子在什么样的情况下会爆胎。当一个轮子装上企业呼呼向前的列车，再要想把它替换下来是一件很难且成本很高的事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，讲讲造这个轮子的一些经历吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Python" scheme="https://xuanwo.org/tags/Python/"/>
    
      <category term="Information" scheme="https://xuanwo.org/tags/Information/"/>
    
      <category term="项目" scheme="https://xuanwo.org/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Flask" scheme="https://xuanwo.org/tags/Flask/"/>
    
      <category term="HTML" scheme="https://xuanwo.org/tags/HTML/"/>
    
      <category term="JavaScript" scheme="https://xuanwo.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在QingCloud上部署弹性扩容的OwnCloud</title>
    <link href="https://xuanwo.org/2016/06/03/owncloud-on-qingcloud/"/>
    <id>https://xuanwo.org/2016/06/03/owncloud-on-qingcloud/</id>
    <published>2016-06-03T08:00:00.000Z</published>
    <updated>2016-09-12T18:05:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为实在不满意百度云的一些缺陷，我们最终决定部署一套团队内部使用的云存储平台，用于团队协作及资料长期存储。希望能够达到如下目标：</p>
<ul>
<li>数据安全性高</li>
<li>权限控制能力强</li>
<li>分享功能更强，可以设置密码和过期时间等</li>
<li>允许匿名第三方上传数据</li>
<li>没有文件上传大小限制</li>
<li>支持多平台同步功能</li>
</ul>
<p>综合考量各开源项目之后，我最终选定基于QingCloud部署一套开源存储项目OwnCloud。</p>
<a id="more"></a>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>在部署之前，我们首先要考虑这套系统大概会有多少人用，会使用多大的空间，需要多少带宽，服务器的配置等问题。我们现在有几个TB的数据，10人使用，未来人数无法预估，各资源使用量也无法预估。但是非常有意思的事情是，在青云QingCloud平台上，一切都是可以动态扩容的，所以我完全可以以最少的资源验证服务是否符合需求，然后再增加服务所使用的资源。</p>
<p>整个部署过程概括为如下4步：</p>
<ul>
<li>验证功能及预估花费</li>
<li>在QingCloud上创建主机、网络等资源并修改配置</li>
<li>安装OwnCloud环境</li>
<li>使用LVM管理分区，实现空间动态扩容</li>
<li>在网页端安装OwnCloud</li>
</ul>
<h2 id="资源编排"><a href="#资源编排" class="headerlink" title="资源编排"></a>资源编排</h2><p>在实际生成需要的资源之前，我先通过青云QingCloud的提供的资源编排功能看看青云是否能够满足我们的需求以及搭建这一套服务需要多少钱：</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-1.png" alt=""></p>
<p>如图所示，我们在一个私有网络中创建一台主机和一个数据库，并为整个VPC网络分配了一个公网IP和防火墙。</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-tp.png" alt=""></p>
<p>如图，整套资源预计需要每小时0.56元。</p>
<h2 id="创建并修改配置"><a href="#创建并修改配置" class="headerlink" title="创建并修改配置"></a>创建并修改配置</h2><p>生成模板之后，点击创建。等待大概一分钟之后，所有资源全部创建完毕。在SSH连接上服务器开始实际的配置工作之前，需要先修改VPC的设置。</p>
<h3 id="添加端口转发规则"><a href="#添加端口转发规则" class="headerlink" title="添加端口转发规则"></a>添加端口转发规则</h3><p>我需要将来自公网的流量转发到我的主机上，主要有两条，一个是SSH，一个是HTTP。</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-2.png" alt=""></p>
<p>主机的内网地址是<code>192.168.0.2</code>，所以需要把所有来自22和80的端口都转发到这个地址。</p>
<h3 id="添加防火墙规则"><a href="#添加防火墙规则" class="headerlink" title="添加防火墙规则"></a>添加防火墙规则</h3><p>出于安全性考虑，青云的防火墙默认只开放了22和ICMP。为了可以正常访问到主机，还需要添加80端口的例外规则：</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-3.png" alt=""></p>
<p>我们看到青云在右边提供了常用端口的配置，选择http即可。</p>
<h2 id="安装OwnCloud"><a href="#安装OwnCloud" class="headerlink" title="安装OwnCloud"></a>安装OwnCloud</h2><p>OwnCloud为CentOS平台提供了二进制的包，没有特殊需求的话，直接使用即可。<br>首先添加OwnCloud官方的Key文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key</span><br></pre></td></tr></table></figure>
<p>然后添加OwnCloud的repo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -O /etc/yum.repos.d/ce:stable.repo</span><br></pre></td></tr></table></figure>
<p>更新repo之后开始安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean expire-cache</span><br><span class="line">yum install owncloud</span><br></pre></td></tr></table></figure>
<p>yum将会自动处理依赖，如果速度不佳的话，可以直接将包下载到本地：<a href="http://download.owncloud.org/download/repositories/stable/CentOS_7/" target="_blank" rel="external">直接下载</a></p>
<h2 id="启用httpd，并测试是否安装正确"><a href="#启用httpd，并测试是否安装正确" class="headerlink" title="启用httpd，并测试是否安装正确"></a>启用httpd，并测试是否安装正确</h2><p>OwnCloud默认使用Apache作为Web服务器，上一步已经安装了Apache，接下来需要启用它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start httpd</span><br></pre></td></tr></table></figure>
<p>如需要开机自行启动，可以输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> httpd</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中访问：<code>http://&lt;your ip&gt;/owncloud</code>，如果出现OwnCloud的安装界面，说明已经配置成功了。</p>
<h2 id="使用LVM管理分区，实现空间动态扩容"><a href="#使用LVM管理分区，实现空间动态扩容" class="headerlink" title="使用LVM管理分区，实现空间动态扩容"></a>使用LVM管理分区，实现空间动态扩容</h2><p>OwnCloud在安装的时候只能选择一个目录，为了能够实现空间的动态扩容，需要使用LVM创建一个逻辑分区并挂载到指定的数据目录下。</p>
<p>首先在青云QingCloud的控制台中创建一块硬盘，然后挂载到主机中。之后，就能够通过<code>/dev/sdb</code>等形式来访问这块硬盘。</p>
<blockquote>
<p>需要注意的是，主机在每次重启的时候硬盘的顺序可能会发生改变，所以如果需要自动挂载的话，需要使用UUID或者LABLE的方式来指定硬盘，不能使用设备名。</p>
</blockquote>
<p>接下来需要在CentOS下使用LVM来配置分区，实现分区的动态扩容。</p>
<h3 id="安装LVM工具"><a href="#安装LVM工具" class="headerlink" title="安装LVM工具"></a>安装LVM工具</h3><p>青云QingCloud提供的CentOS 7.2默认映像是没有LVM工具的，所以首先需要安装它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install lvm2</span><br></pre></td></tr></table></figure>
<h3 id="创建物理卷（PV）"><a href="#创建物理卷（PV）" class="headerlink" title="创建物理卷（PV）"></a>创建物理卷（PV）</h3><p>首先检测能够被作为物理卷的设备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvmdiskscan</span><br></pre></td></tr></table></figure>
<p>然后在指定设备上创建物理卷，所有需要用到的设备都需要执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sdb</span><br></pre></td></tr></table></figure>
<p>然后查看已经创建好的物理卷：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pvdisplay</span><br></pre></td></tr></table></figure>
<p>输出大概如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--- Physical volume ---</span><br><span class="line"> PV Name               /dev/sdb</span><br><span class="line"> PV Size               1000.00 GiB / not usable 4.00 MiB</span><br><span class="line"> Allocatable           yes</span><br><span class="line"> PE Size               4.00 MiB</span><br><span class="line"> Total PE              255999</span><br><span class="line"> Free PE               255999</span><br><span class="line"> Allocated PE          0</span><br><span class="line"> PV UUID               EHIeTJ-WBPv-rQkQ-LnuI-0IWE-SM4z-bMPAWx</span><br></pre></td></tr></table></figure>
<h3 id="创建卷组（VG）"><a href="#创建卷组（VG）" class="headerlink" title="创建卷组（VG）"></a>创建卷组（VG）</h3><p>物理卷创建完毕后，需要创建一个卷组来实现物理卷的统一管理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgcreate owncloud-vg /dev/sdb /dev/sdc /dev/sdd</span><br></pre></td></tr></table></figure>
<p>后续如果需要扩展的话，可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgextend owncloud-vg /dev/sde</span><br></pre></td></tr></table></figure>
<p>同样地，使用<code>vgdisplay</code>来查看创建好的卷组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--- Volume group ---</span><br><span class="line"> VG Name               owncloud-vg</span><br><span class="line"> Format                lvm2</span><br><span class="line"> Metadata Areas        1</span><br><span class="line"> Metadata Sequence No  2</span><br><span class="line"> VG Access             <span class="built_in">read</span>/write</span><br><span class="line"> VG Status             resizable</span><br><span class="line"> MAX LV                0</span><br><span class="line"> Cur LV                1</span><br><span class="line"> Open LV               1</span><br><span class="line"> Max PV                0</span><br><span class="line"> Cur PV                1</span><br><span class="line"> Act PV                1</span><br><span class="line"> VG Size               1000.00 GiB</span><br><span class="line"> PE Size               4.00 MiB</span><br><span class="line"> Total PE              255999</span><br><span class="line"> Alloc PE / Size       230400 / 900.00 GiB</span><br><span class="line"> Free  PE / Size       25599 / 100.00 GiB</span><br><span class="line"> VG UUID               xCCtSR-QFcZ-StcI-HM7O-KDAz-PvMC-EgYcSV</span><br></pre></td></tr></table></figure>
<h3 id="创建逻辑卷（LV）"><a href="#创建逻辑卷（LV）" class="headerlink" title="创建逻辑卷（LV）"></a>创建逻辑卷（LV）</h3><p>然后就可以开始创建逻辑卷了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvcreate -L 900G owncloud-vg -n owncloud-data</span><br></pre></td></tr></table></figure>
<p>创建完毕后，就可以通过<code>/dev/mapper/owncloud--vg-owncloud--data</code>或者<code>/dev/owncloud-vg/owncloud-data</code>来访问这个设备了。</p>
<p>如果需要扩大逻辑卷，可以使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lvextend -L 1000G /dev/owncloud-vg/owncloud-data</span><br></pre></td></tr></table></figure>
<p>确认扩展成功后，再更新文件系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/owncloud-vg/owncloud-data</span><br></pre></td></tr></table></figure>
<h3 id="创建文件系统并挂载"><a href="#创建文件系统并挂载" class="headerlink" title="创建文件系统并挂载"></a>创建文件系统并挂载</h3><p>在逻辑卷上创建一个ext4分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/mapper/owncloud--vg-owncloud--data</span><br></pre></td></tr></table></figure>
<p>然后将分区挂载到期望的目录下，比如<code>/data</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/mapper/owncloud--vg-owncloud--data /data</span><br></pre></td></tr></table></figure>
<h2 id="修改文件夹权限"><a href="#修改文件夹权限" class="headerlink" title="修改文件夹权限"></a>修改文件夹权限</h2><p>为了OwnCloud能够正确读写数据分区，需要修改<code>/data</code>的所有者和权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chown -R apache:apache /data</span><br><span class="line">chmod 775 /data -R</span><br></pre></td></tr></table></figure>
<h2 id="网页安装OwnCloud"><a href="#网页安装OwnCloud" class="headerlink" title="网页安装OwnCloud"></a>网页安装OwnCloud</h2><p>全部配置完毕后，可以开始在网页进行OwnCloud安装了。</p>
<p>管理员帐号： 自定义<br>管理员密码： 自定义<br>数据路径：<code>/data</code><br>数据库用户：<code>root</code><br>数据库密码：<code>&lt;your password&gt;</code><br>数据库名称自定义，比如：<code>owncloud</code><br>数据库地址：<code>&lt;your rdb ip&gt;</code></p>
<blockquote>
<p>在创建RDB时，系统会自动用相同的密码创建Root用户。OwnCloud在安装时需要创建一个新的账户来进行管理，而青云提供的默认用户没有这样的权限。因此需要使用Root用户而不是创建时指定的用户。</p>
</blockquote>
<p>提示创建完毕后，就可以使用管理员用户登陆了。</p>
<h1 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h1><h2 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h2><p>一个存储类的应用，必须要有自动备份的功能，保证用户在最坏的情况下都能找回他们的数据，对于存储着工作资料的私有云存储而言更是如此。所以，需要对主机，硬盘和数据库进行定时备份。</p>
<h3 id="主机和硬盘"><a href="#主机和硬盘" class="headerlink" title="主机和硬盘"></a>主机和硬盘</h3><p>青云QingCloud 提供了一个叫定时器的功能，可以设置在每天的三点重复执行备份任务。</p>
<p>首先创建一个定时器，每天3：00重复执行：</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-backup-1.png" alt=""></p>
<p>然后在该定时器中添加对应的定时器任务：</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-backup-2.png" alt=""></p>
<p>选中需要备份的主机和硬盘即可。</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>青云QingCloud 上的数据库自带自动备份功能，只需要开启它。</p>
<p>在需要备份的数据库上右击，选择<code>修改自动备份策略</code>：</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-backup-3.png" alt=""></p>
<blockquote>
<p>青云QingCloud 首次备份是全量备份，之后是增量备份。当变化较大时，会自动创建新的备份链。</p>
</blockquote>
<h2 id="自动伸缩"><a href="#自动伸缩" class="headerlink" title="自动伸缩"></a>自动伸缩</h2><p>云存储服务的一个最显著的特点是有明显的高峰期，如果能够实现高峰期时自动增加带宽，低峰期时自动降低带宽就能够节省昂贵的带宽费用的目的。青云QingCloud提供的自动伸缩就能有效地满足这一痛点。</p>
<p>首先创建一个自动伸缩策略：</p>
<p>操作类型为调整公网IP带宽上限，然后选择需要自动伸缩的资源。</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-autoscaling-1.png" alt=""></p>
<p>然后添加带宽提高和降低的触发条件：</p>
<p>以带宽提高为例，我们可以在公网进流量连续15分钟平均值大于当前带宽的80%时提高带宽。</p>
<blockquote>
<p>青云QingCloud的监控周期为5分钟，而数据采样周期为1分钟。</p>
</blockquote>
<p><img src="/imgs/opinion/qingcloud-owncloud-autoscaling-2.png" alt=""></p>
<p>最后添加操作参数：</p>
<p>可以设置每次提高5Mbps，最高允许的带宽为20Mbps。</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-autoscaling-3.png" alt=""></p>
<h2 id="硬盘扩容"><a href="#硬盘扩容" class="headerlink" title="硬盘扩容"></a>硬盘扩容</h2><p>硬盘扩容有两种方式，第一是硬盘自身的纵向扩容，提升硬盘的大小；第二是硬盘数量的横向扩容，提升硬盘的个数。下面分别讲一讲。</p>
<h3 id="纵向扩容"><a href="#纵向扩容" class="headerlink" title="纵向扩容"></a>纵向扩容</h3><p>首先暂停服务：</p>
<p>进入 Owncloud 所在文件夹，修改<code>config</code>文件夹下的<code>config.php</code>文件，将<code>maintenance</code>修改为<code>true</code>。这样 Owncloud 就会进入维护模式，从而防止在扩容期间出现意外的数据丢失。</p>
<p>然后从系统中卸载数据盘：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /data</span><br></pre></td></tr></table></figure>
<p>然后就可以在青云的控制台中卸载这块磁盘，并执行扩容操作。<strong>一定要先在系统中卸载，再在青云的控制台中卸载，否则会出现不可恢复的数据丢失。</strong></p>
<p>等到青云提示扩容完成后，再将这块盘挂载到主机上，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pvresize /dev/sdx</span><br></pre></td></tr></table></figure>
<p>来自动探测设备当前大小并将物理卷扩展到其最大容量</p>
<p>之后就可以扩容逻辑卷的大小了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvextend -l 100%VG owncloud-vg/owncloud-data</span><br></pre></td></tr></table></figure>
<p>这个命令会将这个VG的所有空间分配到我们的LV当中。</p>
<p>然后将这个逻辑卷挂载到我们的数据分区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount /dev/mapper/owncloud--vg-owncloud--data /data</span><br></pre></td></tr></table></figure>
<p>然后我们需要让文件系统也检测到空间的变更：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resize2fs /dev/mapper/owncloud--vg-owncloud--data</span><br></pre></td></tr></table></figure>
<p>至此，空间扩容完毕，可以再将<code>config.php</code>中的<code>maintenance</code>修改为<code>false</code>，开始正常对外提供服务。</p>
<h3 id="横向扩容"><a href="#横向扩容" class="headerlink" title="横向扩容"></a>横向扩容</h3><p>横向扩容相对比较简单一些。</p>
<p>首先将Owncloud置于维护模式，然后在青云的控制台上创建一块新的盘挂载到系统中，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pvcreate /dev/sdx</span><br></pre></td></tr></table></figure>
<p>以将这个卷转换为一个物理卷。</p>
<p>之后就可以将这个物理卷加入到一个VG中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vgextend owncloud-vg /dev/sdx</span><br></pre></td></tr></table></figure>
<p>之后的操作跟纵向扩容相似，扩大LV，重新挂载，更新文件系统，退出维护模式等，不再赘述。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>下面来聊一聊OwnCloud的一些应用。</p>
<h2 id="分享功能"><a href="#分享功能" class="headerlink" title="分享功能"></a>分享功能</h2><p><img src="/imgs/opinion/qingcloud-owncloud-4.png" alt=""></p>
<p>分享功能是我比较看重的一个部分。OwnCloud的分享可以选择用户和组，然后还能通过链接进行分享。通过链接分享时，可以指定密码和过期时间，还能允许编辑。这样就可以实现给用户发送需要的资料以及收集来自合作伙伴的视频，文件等功能。</p>
<h2 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h2><p>OwnCloud内建了一个版本管理功能，同一个文件可以提供多个历史版本，这样方便大家进行版本追溯和管理，为团队协作编辑提供了便利。除此以外还有评论系统，实时性能还不错，基本可以用于对具体文档的简单协作。</p>
<p><img src="/imgs/opinion/qingcloud-owncloud-show-1.png" alt=""></p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年06月03日 首次发布</li>
<li>2016年06月11日 增加自动备份和自动伸缩的配置</li>
<li>2016年08月20日 增加了硬盘空间的横向与纵向扩容</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;因为实在不满意百度云的一些缺陷，我们最终决定部署一套团队内部使用的云存储平台，用于团队协作及资料长期存储。希望能够达到如下目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据安全性高&lt;/li&gt;
&lt;li&gt;权限控制能力强&lt;/li&gt;
&lt;li&gt;分享功能更强，可以设置密码和过期时间等&lt;/li&gt;
&lt;li&gt;允许匿名第三方上传数据&lt;/li&gt;
&lt;li&gt;没有文件上传大小限制&lt;/li&gt;
&lt;li&gt;支持多平台同步功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综合考量各开源项目之后，我最终选定基于QingCloud部署一套开源存储项目OwnCloud。&lt;/p&gt;
    
    </summary>
    
      <category term="Opinion" scheme="https://xuanwo.org/categories/Opinion/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="QingCloud" scheme="https://xuanwo.org/tags/QingCloud/"/>
    
      <category term="Work" scheme="https://xuanwo.org/tags/Work/"/>
    
  </entry>
  
  <entry>
    <title>我从Qingchat中学到的教训</title>
    <link href="https://xuanwo.org/2016/05/29/learn-from-qingchat/"/>
    <id>https://xuanwo.org/2016/05/29/learn-from-qingchat/</id>
    <published>2016-05-29T20:57:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前的一段时间一直在从事<a href="https://github.com/Xuanwo/qingchat" target="_blank" rel="external">Qingchat</a>的相关开发工作，这个项目是一个基于Mojo-Weixin提供的Rest API开发的一个微信机器人，承担了十余个群，上千人的微信直播活动。秉承着ACM训练出来的“暴力加乱搞”风格，我花了大概一个星期的课余时间，搞出了一个可用的版本。期间也迭代了很多次，既欣慰于Coding的力量，也苦恼于当初设计的不完善带来的种种问题。在这个项目即将大规模重构的前夕，我总结一下开发Qingchat的过程中的经验教训，希望自己能成为一个更好更聪明的Coder。</p>
<a id="more"></a>
<h1 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h1><h2 id="没有稳定性的世界"><a href="#没有稳定性的世界" class="headerlink" title="没有稳定性的世界"></a>没有稳定性的世界</h2><p>从最开始Coding的时候，就有着一个根深蒂固的信念：计算机不会出错。1是1，0是0，只要自己的实现是对的，那最后的结果也一定是对的。然后，真相并非如此：我们存在于一个没有稳定性的世界。<br>你访问的路径可能是不存在的，你访问的文件可能是不存在或者已经上锁，你期望的服务器响应因为网络环境太差变成了超时。不仅如此，有时候你还会遇到神出鬼没的黑客们，稍有不慎你可能就永远失去了对数据的掌控权（<em>我测试用的服务器被人暴力尝试登陆34万次</em>）。<br>所以我们在编程的时候就应当完全抛弃“这个服务是稳定的”这种前提，学会在万物皆有可能出错的假设下编程，不要轻视程序的鲁棒性。你永远都不会知道用户会以何种方式使用你的程序，同样的，你也不会知道用户到底会输入什么样的数据。灵活运用“防御式编程”和“让它出错”两种思想，让你的代码更健壮。</p>
<h2 id="拥抱多线程，走向非阻塞"><a href="#拥抱多线程，走向非阻塞" class="headerlink" title="拥抱多线程，走向非阻塞"></a>拥抱多线程，走向非阻塞</h2><p>现在回过头来看，自己当初实现的群发功能就是一个彻头彻尾的失败品：容错性差，效率低下。这些问题其实是由同一个原因导致的：我使用了一个单线程阻塞式的实现，不仅如此，还没有做任何异常的处理。这样导致的结果就是只要某个环节出错，整个群发任务就会直接退出。速度是跟微信群的数量成正比的，群的数量上升之后，群发速度过慢成了我的同事们经常向我吐嘈的问题。<br>开发的时候不计算网络传输延时绝对是一个重大失误——实际上，网络延时是整个系统的关键瓶颈。为了解决这个问题，Node.js 采用了一种单线程非阻塞的设计（一家之言，轻喷）。对于Python来说也是一样的，适度地拥抱多线程开发以提高并行效率，多采用非阻塞式设计以避免单个任务执行时间过长拖慢运行速度。<br>在一次去上课的路上，我形象地把这种设计比作“射后不管”，好像是飞毛腿导弹？</p>
<h2 id="开源非万能"><a href="#开源非万能" class="headerlink" title="开源非万能"></a>开源非万能</h2><p>我原来是一个开源的死忠粉，认为开源可以解决一切问题，那个时候每天思考的问题就是为什么Windows不开源？等到真的进入业界，才明白自己的这种想法有多么幼稚。<br>除去那些大型的有基金会在背后支撑的项目，绝大多数项目完全依靠开发者个人热情来维持，某些涉及到商业支持的项目更是存在着“人走项目死”的现象。比如我参与管理的<a href="https://github.com/hexojs" target="_blank" rel="external">Hexo</a>项目在作者tommy开始实习之后就进展缓慢，再比如我接手但是现状非常差的<a href="https://github.com/staticfile/static" target="_blank" rel="external">staticfile</a>（<em>很抱歉我并没有能够做出什么正面的贡献，反而让状况变得更加糟糕了</em>）。<br>这些实践都告诉我，开源并不是万能的，真正想要解决一个问题，需要一个完善的制度以及各方面的激励机制。单纯依赖于开发者个人的热情往往不利于一个项目的长远发展，而在自行开发的项目中依赖于一个开源项目往往会带来更多的风险。开发者不一定会开发你期望的功能，开发者也不一定会按照你期望的进度进行开发。<br>作为我个人，我依然是一个热爱开源项目，崇尚开源理念的人；然而作为一个产品的开发者，一个服务的提供者，你必须权衡自行开发，采购商业产品以及使用开源项目之间的利弊。不同的选择取决于不同的项目，不同的需求，不同的自主开发能力，不同的后续维护能力。一味的强调开源理念，不顾实际，往往对开源事业的发展有害无益，挫伤人们对开源的信赖。</p>
<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>一个项目最具活力与激情的时刻就是在设计之初实现之前，等到实现的时候往往寸步难行，到了后续维护的时候时常想就此了断。我希望这个项目能够存活更长的时间，希望自己向同事们提出的构想都能够一一变为现实。本次重构希望能够实现一个更加稳定更加高效的Qingchat，希望能够进一步减少重复劳动，提高效率。<br>最后感谢同事们的不杀之恩，感谢青云QingCloud的自由空间，可以允许我以自己想要的方式完成工作。最后以青云CTO Reno在某次会上说的话自勉：“你们是青云的Devloper，No excuse。”</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年05月30日 初稿</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前的一段时间一直在从事&lt;a href=&quot;https://github.com/Xuanwo/qingchat&quot;&gt;Qingchat&lt;/a&gt;的相关开发工作，这个项目是一个基于Mojo-Weixin提供的Rest API开发的一个微信机器人，承担了十余个群，上千人的微信直播活动。秉承着ACM训练出来的“暴力加乱搞”风格，我花了大概一个星期的课余时间，搞出了一个可用的版本。期间也迭代了很多次，既欣慰于Coding的力量，也苦恼于当初设计的不完善带来的种种问题。在这个项目即将大规模重构的前夕，我总结一下开发Qingchat的过程中的经验教训，希望自己能成为一个更好更聪明的Coder。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Python" scheme="https://xuanwo.org/tags/Python/"/>
    
      <category term="qingchat" scheme="https://xuanwo.org/tags/qingchat/"/>
    
      <category term="QingCloud" scheme="https://xuanwo.org/tags/QingCloud/"/>
    
      <category term="实习" scheme="https://xuanwo.org/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于MSP430G2553的打铃系统开发手记</title>
    <link href="https://xuanwo.org/2016/05/09/msp430g2553-bellring/"/>
    <id>https://xuanwo.org/2016/05/09/msp430g2553-bellring/</id>
    <published>2016-05-09T08:42:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我萌萌哒的妹纸是一个代码苦手，完全无法理解 C 语言，所以每一次到单片机上机需要交作业的时候都是愁眉苦脸的样子。而我又总是因为自己确实不懂单片机里面的种种奇怪定义（中断，串口，P1.x 之类），所以也一直没有什么好办法去帮她。这一次的作业对编码能力要求较高，但是涉及到的硬件比较少，于是决定以此为契机，开始我的嵌入式开发之旅。</p>
<a id="more"></a>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>这次的如下：</p>
<h2 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h2><ul>
<li>基本计时和显示功能(用 12 小时制显示)。<br>包括上下午标志,时、分的数字显示,秒信号指示。</li>
<li>能设置当前时间(含上、下午,时,分)</li>
<li>能实现基本打铃功能,规定:<br>上午 6:00 起床铃;打铃 5 秒、停 2 秒、再打铃 5 秒。<br>下午 10:30 熄灯铃;打铃 5 秒、停 2 秒、再打铃 5 秒。</li>
</ul>
<blockquote>
<p>铃声可用 LED 灯光显示,如果实验装置没有 LED 发光管,可以用七段显示管的小数点显示,也可以用显示小时的十位数码管的多余段显示。凡是用到铃声功能的均可如此处理。</p>
</blockquote>
<h2 id="发挥部分"><a href="#发挥部分" class="headerlink" title="发挥部分"></a>发挥部分</h2><ul>
<li>增加整点报时功能,整点时响铃 5 秒,要求有控制启动和关闭功能。</li>
<li>增加调整起床铃、熄灯铃时间的功能。</li>
<li>增加调整打铃时间长短和间歇时间长短的功能。</li>
<li>增设上午 4 节课的上、下课打铃功能,规定:<br>7:30 上课,8:20 下课;8:30 上课,9:20 下课;9:40 上课,10:30 下课;10:40 上课,11:30 下课;每次铃声 5 秒。</li>
<li>利用板上按键做一个 12 小时/24 小时的显示格式切换</li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>既然我都出动了，肯定不能满足于只完成基本要求，决定把所有功能全都完整的实现。</p>
</blockquote>
<p>简单的来说，整体需求可以分为三个部分：显示，打铃，修改。</p>
<p>需要用到的东西有：串口，指示灯和一个按键。</p>
<h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><p>遵循简单的前后端分离的思想，我们可以使用三个全局变量 hour ， minute ， second 来存储当前的时间，只需要在显示的时候区分上下午和 12 小时／ 24 小时即可。这两个部分解耦之后会发现，我们后面的利用板上按键修改显示格式也变得容易了很多。<br>通过串口显示也就是需要向指定变量发送字符，将这个功能抽象并封装之后，对于我后续的编程来说，也就是调用一下 Send_Str(str) 的过程。</p>
<h2 id="打铃"><a href="#打铃" class="headerlink" title="打铃"></a>打铃</h2><p>打铃是这套系统的重头戏，因为学校方面的资源限制，所以使用指示灯示意的方法来代替打铃。<br>指示灯的亮灭是通过控制一个变量的值来确定的，于是我只要在正确时候设置正确的值，打铃系统就能按照我期望的方式工作。</p>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>修改同样是通过串口进行的。</p>
<blockquote>
<p>在最开始的设计文档中，本来是要求使用4个按键来进行设计，也就是说跟一个普通的电子表差不多。但是非常因缺思艇的事情是学校的按键不够了，所以老师要求所有功能都用串口实现。</p>
</blockquote>
<p>跟显示有些不同的地方是，通过串口向芯片发送数据需要正确使用串口中断。</p>
<p>综上，这个系统所需要的全部内容就已经实现了。可以看到我做了很多将对硬件的操作抽象化的处理，其实这一点非常重要。因为对于我来说，嵌入式开发最大的难题在于，我不知道里面种种变量的含义，不知道如何操作具体的硬件。将硬件操作抽象化处理之后，我就可以很方便地开展我的后续开发。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>实现就不再赘述了，想必读者一定都比我强，下面聊一聊遇到的问题以及 debug 的经历。</p>
<h2 id="串口配置"><a href="#串口配置" class="headerlink" title="串口配置"></a>串口配置</h2><p>串口的收和发其实是分开的，这里用到了两个变量： UCA0TXBUF ， UCA0RXBUF 。从字面意思上可以看出，前一个用于发送，后一个用于接收（相对于开发者来说）。发送和接收其实就是给这两个值赋值的过程，看起来这两个变量在接受到值之后会将这个值传给别的变量，所以只要不断的将值赋给它就行，我们写了这样的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector=USCIAB0RX_VECTOR <span class="comment">//中断服务函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">__</span><span class="function">interrupt <span class="keyword">void</span> <span class="title">uart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rec = UCA0RXBUF;</span><br><span class="line">    <span class="comment">//读取到缓冲区</span></span><br><span class="line">    strtmp[<span class="built_in">strlen</span>++] = rec;</span><br><span class="line">    strtmp[<span class="built_in">strlen</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="comment">//切换模式</span></span><br><span class="line">    mode = strtmp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send_Char</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!(IFG2 &amp; UCA0TXIFG));</span><br><span class="line">    UCA0TXBUF = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Send_Str</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*(p + i) != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(IFG2 &amp; UCA0TXIFG));</span><br><span class="line">        UCA0TXBUF = *(p + i);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    Send_Char(<span class="number">0x0d</span>);</span><br><span class="line">    Send_Char(<span class="number">0x0a</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uart 貌似是一个内置的中断函数，用来处理串口的接收，只要将变量 UCA0RXBUF 的值存储起来即可；后面的 Send_Str 就非常好理解了，将值发送给 UCA0TXBUF ，从而实现串口的输出。</p>
<p>思路如此清晰，但是测试的时候却遇到了问题，我们的输出是空的，转为16进制显示后，全都是0x00。这个问题调试了很久，拿着原来的代码逐行比对之后发现，出了这样的问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- UCA0BR0 = <span class="number">130</span>;</span><br><span class="line">- UCA0BR1 = <span class="number">6</span>;</span><br><span class="line">+ UCA0BR0 = <span class="number">104</span>;</span><br><span class="line">+ UCA0BR1 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>Google 一下才明白，原来 UCA0BR0 和 UCA0BR1 是由系统的时钟速度和波特率决定的值，如果设置错误就会导致串口发送失败。具体的值可以参考<a href="http://www.ti.com/lit/ug/slau144j/slau144j.pdf" target="_blank" rel="external">用户手册</a>， Ctrl＋F 搜索 <code>Table 15-4. Commonly Used Baud Rates</code> 即可。</p>
<h2 id="串口输出异常"><a href="#串口输出异常" class="headerlink" title="串口输出异常"></a>串口输出异常</h2><p>前面提到我们直接使用三个变量保存当前时间，在输出时做进一步处理，转为字符串的过程中，我们进行了这样的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Time[<span class="number">0</span>] = hour / <span class="number">10</span> + <span class="string">'0'</span>;</span><br></pre></td></tr></table></figure>
<p>但有趣的事情是，在初始化之后，我们得到的输出是这样的： <code>0/:0/:0/</code> 。随手输出了一下 <code>/</code> 的 ASCII 码，发现它刚好比 <code>0</code> 小一。</p>
<p>难道说，存储器中的默认值不是 0 吗？ Google 一下之后发现，还真的不是 0 。 MSP430G2553 中的 Flash 存储器在默认状态下的值全为 1 ，然后写入时只能将 1 置为 0 ，所以每一次写入数据都需要先清空再写入。那么问题来了，为什么全为 1 会导致最后输出的结果小 1 呢？我来简单的阐述一下我的理解：</p>
<p>假设这个存储器只有 8 位，也就是说，现在的值为 <code>11111111</code> ，然后我加上一个 <code>1</code> ，于是我们得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  11111111</span><br><span class="line">+        1</span><br><span class="line"> 100000000</span><br></pre></td></tr></table></figure>
<p>显然，我们最后的结果已经移除了，此时会产生截断，也就是说，存储器现在的数据变成了 <code>00000000</code> ，也就是 <code>0</code>，跟我们期望的结果 <code>1</code> 刚好相差一。</p>
<p>当然，实际的情况要比我上面的举例要复杂的多，不过我想已经足够我们认识到这个 BUG 的本质，就不再多说啦。</p>
<h2 id="Flash-存储器未清空"><a href="#Flash-存储器未清空" class="headerlink" title="Flash 存储器未清空"></a>Flash 存储器未清空</h2><p>在测试中，我们发现每一次烧录程序之后， Flash 存储器不会清空，依然会从上一次我们保存的时间开始计时。我觉得这是正确的行为，没有在意，但是我妹纸和她的队友告诉我她们在完成上一个作业的时候每次都是会清空的。我对着这次和上次的代码研究了很久，认为代码里面根本就没有清空 Flash 存储器的操作，如果有的话，掉电保存这项功能根本无从谈起。我妹纸她们也同意我的分析，但是她们的实践确实证明了每次都会清空 Flash 存储区。</p>
<p>这个问题也困扰了很久，直到第二天，用别人的电脑重新烧录了一遍程序，发现他们的是会正常清空的。所以说，问题在于 CCS 的版本：我妹纸使用的 CCS 版本是 6.1 ，而<br>他们用的版本是 5.1.1 ，也就是说，不同版本的 CCS 在烧录程序期间的不同行为导致了这次错误。我们换用了 5.1.1 之后，成功解决了这个问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对嵌入式开发有了初步的了解，向着真·全栈开发工程师又近了一步。</p>
<p>这一次的开发经历遇到了很多因缺思艇的问题，因为嵌入式开发本身比较偏向底层，这次开发甚至还遇到了存储器的存储原理。也有一点将自己看的 CSAPP 融会贯通的感觉，还是很有意思的。</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年05月09日  首次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;我萌萌哒的妹纸是一个代码苦手，完全无法理解 C 语言，所以每一次到单片机上机需要交作业的时候都是愁眉苦脸的样子。而我又总是因为自己确实不懂单片机里面的种种奇怪定义（中断，串口，P1.x 之类），所以也一直没有什么好办法去帮她。这一次的作业对编码能力要求较高，但是涉及到的硬件比较少，于是决定以此为契机，开始我的嵌入式开发之旅。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="C" scheme="https://xuanwo.org/tags/C/"/>
    
      <category term="单片机" scheme="https://xuanwo.org/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab部署和汉化以及简单运维</title>
    <link href="https://xuanwo.org/2016/04/13/gitlab-install-intro/"/>
    <id>https://xuanwo.org/2016/04/13/gitlab-install-intro/</id>
    <published>2016-04-13T23:20:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在跟网络中心的老师沟通成立镜像站的相关事宜的时候，意外地接下来搭建一套校内的 Git 服务的任务。<br><a href="https://imnerd.org/" target="_blank" rel="external">@怡红公子</a> 曾经搭建过一套类似的服务，但由于服务器端没有开启 VT 虚拟化导致不能安装 64 位的操作系统，再加上 Gitlab 不提供 32 位的安装包，所以长期以来怡红公子一直都是自行编译并配置 Gitlab 。考虑到后续维护的方便，我们决定趁着这个机会使用另一台支持安装 64 位操作系统的服务器，一劳永逸地解决这个问题。<br>我们的服务器环境是 <strong>CentOS 7.2 64bit</strong> ，以下所有操作均以此为基准。</p>
<a id="more"></a>
<h1 id="Gitlab-安装"><a href="#Gitlab-安装" class="headerlink" title="Gitlab 安装"></a>Gitlab 安装</h1><p>推荐使用 <a href="https://about.gitlab.com/downloads" target="_blank" rel="external">Install a GitLab CE Omnibus package</a> 安装 ，其他发行版可以点选对应版本，不再赘述。</p>
<h2 id="安装和配置依赖"><a href="#安装和配置依赖" class="headerlink" title="安装和配置依赖"></a>安装和配置依赖</h2><p>如果需要安装 Postfix 来发送邮件，则需要在安装过程中选择 <code>Internet Site</code>。你也可以使用 Sendmail 之类的第三方发信服务或者使用自行配制的 SMTP 服务器。<br>除此以外，下列命令将会在防火墙中打开 HTTP(80) 和 SSH(22) 对应端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install curl policycoreutils openssh-server openssh-clients</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sshd</span><br><span class="line">sudo systemctl start sshd</span><br><span class="line">sudo yum install postfix</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> postfix</span><br><span class="line">sudo systemctl start postfix</span><br><span class="line">sudo firewall-cmd --permanent --add-service=http</span><br><span class="line">sudo systemctl reload firewalld</span><br></pre></td></tr></table></figure>
<h2 id="添加-Gitlab-源并安装"><a href="#添加-Gitlab-源并安装" class="headerlink" title="添加 Gitlab 源并安装"></a>添加 Gitlab 源并安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="_">-s</span>S https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum install gitlab-ce</span><br></pre></td></tr></table></figure>
<p>这个脚本会在源中添加 Gitlab-CE ，并自动执行<code>yum makecache</code>，然后安装<code>gitlab-ce</code>。由于源在国外，可能速度较慢，也可以手动添加来自 清华tuna 的源： <a href="https://mirrors.tuna.tsinghua.edu.cn/help/gitlab-ce/" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/help/gitlab-ce/</a> ， 链接中为各发行版下的教程，感谢 清华tuna 提供镜像。</p>
<h2 id="配置并启动-Gitlab"><a href="#配置并启动-Gitlab" class="headerlink" title="配置并启动 Gitlab"></a>配置并启动 Gitlab</h2><p>此时已经可以启动服务了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>进行一长串复杂的启动流程之后， gitlab 就已经可以通过 <code>localhost</code> 进行访问了。</p>
<h1 id="Gitlab-配置"><a href="#Gitlab-配置" class="headerlink" title="Gitlab 配置"></a>Gitlab 配置</h1><h2 id="修改域名"><a href="#修改域名" class="headerlink" title="修改域名"></a>修改域名</h2><p>默认的配置文件保存在 <code>/etc/gitlab/gitlab.rb</code> ，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/gitlab/gitlab.rb</span><br></pre></td></tr></table></figure>
<p>打开文件，并修改：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">external_url <span class="string">'http://your.domain'</span></span><br></pre></td></tr></table></figure>
<p>再次执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>即可。</p>
<p>有一定概率出现 502 错误，刷新浏览器或者再次更新配置即可。</p>
<h2 id="Gitlab-汉化"><a href="#Gitlab-汉化" class="headerlink" title="Gitlab 汉化"></a>Gitlab 汉化</h2><p>由于服务对象是广大师生，为了降低新手上手的难度，所有进行汉化也是非常有必要的。好在国内有人已经进行了这方面的工作，我们只需要共享其成果即可（欢迎向<a href="https://gitlab.com/larryli/gitlab" target="_blank" rel="external">原项目</a>提交高质量翻译）。</p>
<p>首先确认版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</span><br></pre></td></tr></table></figure>
<p>并确认当前汉化版本的 VERSION 是否相同，当前最新的汉化版本为 8.6 。<br>如果安装版本小于当前汉化版本，请先升级。如果安装版本大于当前汉化版本，请在本项目中提交新的 issue。<br>如果版本相同，首先在本地 clone 仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># GitLab.com 仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitlab.com/larryli/gitlab.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或 Coding.net 镜像</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.coding.net/larryli/gitlab.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据我的测试， Coding.net 的镜像不完整，clone 之后无法 checkout</p>
</blockquote>
<p>然后比较汉化分支和原分支，导出 patch 用的 diff 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 8.1 版本的汉化补丁</span></span><br><span class="line">git diff origin/8-6-stable..8-6-zh &gt; ../8.6.diff</span><br></pre></td></tr></table></figure>
<p>然后上传 <code>8.6.diff</code> 文件到服务器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止 gitlab</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line">sudo patch <span class="_">-d</span> /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 8.6.diff</span><br></pre></td></tr></table></figure>
<p>确定没有 .rej 文件，重启 GitLab 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure>
<p>如果汉化中出现问题，请重新安装 GitLab（<strong>注意备份数据</strong>）。</p>
<h1 id="Gitlab-运维"><a href="#Gitlab-运维" class="headerlink" title="Gitlab 运维"></a>Gitlab 运维</h1><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动所有 gitlab 组件：</span></span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有 gitlab 组件：</span></span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启所有 gitlab 组件：</span></span><br><span class="line">sudo gitlab-ctl restart</span><br></pre></td></tr></table></figure>
<h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>备份GitLab repositories and GitLab metadata<br>在 crontab 中加入如下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create</span><br></pre></td></tr></table></figure></p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>首先进入备份 gitlab 的目录，这个目录是配置文件中的<code>gitlab_rails[&#39;backup_path&#39;]</code>，默认为<code>/var/opt/gitlab/backups</code>。</p>
<p>然后停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl stop unicorn</span><br><span class="line"><span class="comment"># ok: down: unicorn: 0s, normally up</span></span><br><span class="line">sudo gitlab-ctl stop sidekiq</span><br><span class="line"><span class="comment"># ok: down: sidekiq: 0s, normally up</span></span><br></pre></td></tr></table></figure>
<p>然后恢复数据，1406691018为备份文件的时间戳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gitlab-rake gitlab:backup:restore BACKUP=1406691018</span><br></pre></td></tr></table></figure>
<h2 id="修改数据存储地址"><a href="#修改数据存储地址" class="headerlink" title="修改数据存储地址"></a>修改数据存储地址</h2><p>默认情况下，gitlab 将数据存储在<code>/var/opt/gitlab/git-data</code>目录下，受限于分区情况&amp;方便管理，我们需要将数据迁移到别的目录下。</p>
<h3 id="无需数据迁移"><a href="#无需数据迁移" class="headerlink" title="无需数据迁移"></a>无需数据迁移</h3><p>如果还没有投入使用，则可以直接在配置文件中添加：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">git_data_dir <span class="string">"/path/to/git-data"</span></span><br></pre></td></tr></table></figure>
<p>然后执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>就可以生效了。</p>
<h3 id="进行数据迁移"><a href="#进行数据迁移" class="headerlink" title="进行数据迁移"></a>进行数据迁移</h3><p>如果已经有数据了，则需要进行迁移。</p>
<p>首先需要暂停服务，避免用户在迁移期间读写数据：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl stop</span><br></pre></td></tr></table></figure>
<p>然后使用rsync数据进行迁移：</p>
<blockquote>
<p>注意前一个地址不需要<code>/</code>，后一个地址需要<code>/</code>，且只需要迁移<code>repositories</code>目录即可</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rsync -av /var/opt/gitlab/git-data/repositories /path/to/git-data/</span><br></pre></td></tr></table></figure>
<p>然后运行配置工具以更新并重启服务：</p>
<blockquote>
<p>官网文档是先更新配置再启动服务，但我在使用中发现先更新配置会提示无法连接上服务器，出现这种问题时可以先启动服务再更新配置。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br><span class="line">sudo gitlab-ctl start</span><br></pre></td></tr></table></figure>
<p>最后不要忘了在网页端确认数据的地址是否正确。</p>
<blockquote>
<p>关于权限问题<br>在使用中，我一开始创建了一个<code>gitlabhq</code>用户并创建了一个文件夹，然后修改地址，服务正常启动后提示500。<br>后来使用<code>root</code>账户在<code>/home</code>下直接创建文件夹解决了这个问题。<br>如果有遇到类似问题的，可以尝试用<code>root</code>创建目录。</p>
</blockquote>
<h2 id="监听IPv6"><a href="#监听IPv6" class="headerlink" title="监听IPv6"></a>监听IPv6</h2><p>教育网拥有得天独厚的IPv6资源，所以为我们的gitlab服务添加IPv6支持很有必要。</p>
<p>修改<code>/etc/gitlab/gitlab.rb</code>文件中的：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx['listen_addresses'] = ['*']</span></span><br></pre></td></tr></table></figure>
<p>为</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">nginx[<span class="string">'listen_addresses'</span>] = [<span class="string">'*'</span>, <span class="string">'[::]'</span>]</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>然后就可以通过IPv6访问了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://about.gitlab.com/downloads/" target="_blank" rel="external">Gitlab 下载</a></li>
<li><a href="https://gitlab.com/larryli/gitlab/wikis/home" target="_blank" rel="external">GitLab Community Edition · Wiki</a></li>
<li><a href="http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/crontab.html" target="_blank" rel="external">crontab 定时任务</a></li>
<li><a href="https://gitlab.com/gitlab-org/gitlab-ce/blob/master/doc/raketasks/backup_restore.md" target="_blank" rel="external">Backup restore</a></li>
<li><a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/configuration.md#storing-git-data-in-an-alternative-directory" target="_blank" rel="external">Storing Git data in an alternative directory</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年04月14日 首次发布</li>
<li>2016年04月18日 新增数据迁移&amp;监听IPv6配置</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;在跟网络中心的老师沟通成立镜像站的相关事宜的时候，意外地接下来搭建一套校内的 Git 服务的任务。&lt;br&gt;&lt;a href=&quot;https://imnerd.org/&quot;&gt;@怡红公子&lt;/a&gt; 曾经搭建过一套类似的服务，但由于服务器端没有开启 VT 虚拟化导致不能安装 64 位的操作系统，再加上 Gitlab 不提供 32 位的安装包，所以长期以来怡红公子一直都是自行编译并配置 Gitlab 。考虑到后续维护的方便，我们决定趁着这个机会使用另一台支持安装 64 位操作系统的服务器，一劳永逸地解决这个问题。&lt;br&gt;我们的服务器环境是 &lt;strong&gt;CentOS 7.2 64bit&lt;/strong&gt; ，以下所有操作均以此为基准。&lt;/p&gt;
    
    </summary>
    
      <category term="Operate" scheme="https://xuanwo.org/categories/Operate/"/>
    
    
      <category term="运维" scheme="https://xuanwo.org/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="CUGBLUG" scheme="https://xuanwo.org/tags/CUGBLUG/"/>
    
      <category term="Gitlab" scheme="https://xuanwo.org/tags/Gitlab/"/>
    
  </entry>
  
  <entry>
    <title>docopt——好用的Python命令行参数解释器</title>
    <link href="https://xuanwo.org/2016/04/04/docopt-intro/"/>
    <id>https://xuanwo.org/2016/04/04/docopt-intro/</id>
    <published>2016-04-04T21:39:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://github.com/Xuanwo/qingchat" target="_blank" rel="external"><code>Qingchat</code></a> 使用的命令行参数解释器是 <a href="http://docopt.org/" target="_blank" rel="external"><code>docopt</code></a>，用下来感觉非常棒，所以决定介绍一下这个库。（<em>奉劝各位看官，珍爱生命，远离argparse。</em>）</p>
<a id="more"></a>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>docopt 本质上是在 Python 中引入了一种针对命令行参数的形式语言，在代码的最开头使用<code>&quot;&quot;&quot;</code>文档注释的形式写出符合要求的文档，就会自动生成对应的parse，体验非常赞。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>docopt的使用非常简单，以Qingchat为例，你只需要在代码最开头加入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Qingchat CLI</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  qingchat config ip &lt;ip&gt;</span><br><span class="line">  qingchat config port &lt;port&gt;</span><br><span class="line">  qingchat config login</span><br><span class="line">  qingchat group list</span><br><span class="line">  qingchat group choose &lt;group_name&gt;...</span><br><span class="line">  qingchat group clean</span><br><span class="line">  qingchat group send -t &lt;content&gt;</span><br><span class="line">  qingchat group send -i &lt;media&gt;</span><br><span class="line">  qingchat group send -f &lt;file&gt; [&lt;delaytime&gt;]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h --help     Show this screen.</span><br><span class="line">  -v --version     Show version.</span><br><span class="line">"""</span></span><br></pre></td></tr></table></figure>
<p>然后在执行代码中加入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arguments = docopt(__doc__, version=<span class="string">'Qingchat 0.3.2'</span>)</span><br></pre></td></tr></table></figure>
<p>就会在你的程序中导入一个<code>arguments</code>字典，这个字典中的内容形如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">'-f'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'-i'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'-t'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'&lt;content&gt;'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'&lt;file&gt;'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'&lt;group_name&gt;'</span>: [],</span><br><span class="line">    <span class="string">'&lt;ip&gt;'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    <span class="string">'&lt;media&gt;'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'&lt;port&gt;'</span>: <span class="keyword">None</span>,</span><br><span class="line">    <span class="string">'choose'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'clean'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'config'</span>: <span class="keyword">True</span>,</span><br><span class="line">    <span class="string">'group'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'ip'</span>: <span class="keyword">True</span>,</span><br><span class="line">    <span class="string">'list'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'login'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'send'</span>: <span class="keyword">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样应该就能很容易看出来，我们在文档中写的每一个短语，都被转化为一个对应的类型。只要直接调用<code>arguments[&#39;xxx&#39;]</code>就可以判断或者使用对应的值，从而实现对应的功能。</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>前面我们举了一个例子，下面我们来详细介绍一下如何完成一个符合 <code>docopt</code> 要求的注释文档。</p>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>所有出现在<code>usage:</code>（区分大小写）和一个空行之间的文本都会被识别为一个命令组合，<code>usage</code>后的第一个字母将会被识别为这个程序的名字，所有命令组合的每一个部分（空格分隔）都会成为字典中的一个key。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>形如 <code>&lt;argument&gt;</code> 或者 <code>ARGUMENT</code> 的文本将会被识别为参数。<br>在转化后的字典中的取值为 <code>True</code> 或者 <code>False</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program &lt;host&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>形如 <code>-o</code> 或者 <code>--option</code> 的文本将会被识别为选项。<br>在转化后的字典中的取值为 <code>True</code> 或者 <code>False</code> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program -f &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>Tips:</p>
<ul>
<li>短选项可以组合起来，比如<code>-abc</code>等价于<code>-a -b -c</code></li>
<li>长选项需要的参数需要使用 <code>=</code> 或者空格来分隔，<code>--input=ARG</code> 等价于 <code>--input ARG</code></li>
<li>短选项可以不需要空格， <code>-f FILE</code> 等价于 <code>-fFILE</code></li>
</ul>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>其他不满足 <code>--options</code> 或者 <code>&lt;arguments&gt;</code> 的文本将会被识别为（子）命令。<br>在转化后的字典中取值为 <code>True</code> 或者 <code>False</code>。</p>
<h4 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h4><p>形如 <code>[optional elements]</code> 的文本是可选项。<br><code>elements</code>包括上述的三种类型：参数，选项以及命令。</p>
<p>在相同或者不同的括号中都是一样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program [command --option &lt;argument&gt;]</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program [command] [--option] [&lt;argument&gt;]</span><br></pre></td></tr></table></figure>
<h4 id="必填项"><a href="#必填项" class="headerlink" title="必填项"></a>必填项</h4><p>形如 <code>(required elements)</code> 的文本是必填项。<br>上述三种元素默认都是必填项，<code>()</code>符号用在一些比较特殊的情形下，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program (--either-this &lt;<span class="keyword">and</span>-that&gt; | &lt;<span class="keyword">or</span>-this&gt;)</span><br></pre></td></tr></table></figure>
<h4 id="选择项"><a href="#选择项" class="headerlink" title="选择项"></a>选择项</h4><p>形如 <code>element|another</code> 的文本是选择项，你可以从中选择一个值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program go (--up | --down | --left | --right)</span><br></pre></td></tr></table></figure>
<h4 id="列表项"><a href="#列表项" class="headerlink" title="列表项"></a>列表项</h4><p>形如 <code>element...</code> 的文本是列表项，你可以输入多个参数。</p>
<p>比如说：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Usage: my_program open &lt;file&gt;...</span><br></pre></td></tr></table></figure>
<p>然后你可以通过<code>arguments[&#39;&lt;file&gt;&#39;]</code> 来访问这个列表。</p>
<h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><p><code>Option</code> 部分用于指定某些特殊情形，比如：</p>
<ul>
<li>将某个短参数与长参数关联起来，比如<code>-i &lt;file&gt;, --input &lt;file&gt;</code></li>
<li>某个选项有一个参数</li>
<li>选项的默认值，比如<code>--coefficient=K  The K coefficient [default: 2.95]</code></li>
</ul>
<h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p>如果对自己完成的文档有疑问，可以使用<a href="http://try.docopt.org/" target="_blank" rel="external">在线工具</a>进行校验。</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年04月04日 首次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Xuanwo/qingchat&quot;&gt;&lt;code&gt;Qingchat&lt;/code&gt;&lt;/a&gt; 使用的命令行参数解释器是 &lt;a href=&quot;http://docopt.org/&quot;&gt;&lt;code&gt;docopt&lt;/code&gt;&lt;/a&gt;，用下来感觉非常棒，所以决定介绍一下这个库。（&lt;em&gt;奉劝各位看官，珍爱生命，远离argparse。&lt;/em&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Python" scheme="https://xuanwo.org/tags/Python/"/>
    
      <category term="qingchat" scheme="https://xuanwo.org/tags/qingchat/"/>
    
  </entry>
  
  <entry>
    <title>微信多群直播的新探索——Qingchat</title>
    <link href="https://xuanwo.org/2016/04/01/qingchat-intro/"/>
    <id>https://xuanwo.org/2016/04/01/qingchat-intro/</id>
    <published>2016-04-01T22:03:00.000Z</published>
    <updated>2016-09-12T18:05:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我之前写过的一篇文章中，我曾经探索过类似的问题：<a href="https://xuanwo.org/2016/02/28/wechat-remove/">微信群重复人员识别</a>。当初我就提出过能否自动获取相关数据，但因为种种原因的限制不了了之了。后来发现了<a href="https://github.com/sjdy521/Mojo-Weixin" target="_blank" rel="external">Mojo-Weixin</a>这个库之后，我决定在这个的基础上实现一个微信多群直播的工具——Qingchat。（<em>尽管在刚刚实现完不久，微信就更新了转发到多个群的功能，Sad。</em>）探索的成果如下： <a href="https://github.com/Xuanwo/qingchat" target="_blank" rel="external">Qingchat</a>，目前仅支持 python3 ，欢迎各位看官提 issues ，交 code ，或者拍砖。<br>接下来我会先介绍一下 Qingchat 的原理，然后介绍 Qingchat 的使用，最后展望一下 Qingchat 未来的发展方向。</p>
<a id="more"></a>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Qingchat 基于 <a href="https://github.com/sjdy521/Mojo-Weixin" target="_blank" rel="external">Mojo-Weixin</a> 进行开发，通过调用 Mojo－Winxin 的 http 接口与微信服务器进行通信以实现群发功能。目前主要支持微信群发工作，可以从文件中读取内容，并根据内容长度设置发送延时以模拟真人输入效果。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>想要使用Qingchat，首先需要在服务器或者本地配置好 Mojo－Weixin 环境。</p>
<h3 id="测试-amp-安装perl环境"><a href="#测试-amp-安装perl环境" class="headerlink" title="测试&amp;安装perl环境"></a>测试&amp;安装perl环境</h3><p>除了 Windows 环境，大部门环境下已经默认预装了 perl 环境，可以通过｀perl －－version｀查看。本环境要求 perl 5.10 以上。<br>缺乏相关环境的，可以安装对应系统的集成包：</p>
<table>
<thead>
<tr>
<th>平台</th>
<th>推荐选择</th>
<th>下载地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td>1. <strong>StrawberryPerl</strong><br>2. ActivePerl<br></td>
<td><a href="http://strawberryperl.com/" target="_blank" rel="external">StrawberryPerl下载地址</a><br><a href="http://www.activestate.com/activeperl/downloads" target="_blank" rel="external">ActivePerl下载地址</a></td>
</tr>
<tr>
<td>Linux</td>
<td>1. <strong>ActivePerl</strong><br>2. 官方源码<br>3. yum/apt等包管理器<br>4. Mojo-ActivePerl</td>
<td><a href="http://www.activestate.com/activeperl/downloads" target="_blank" rel="external">ActivePerl下载地址</a><br><a href="https://github.com/sjdy521/Mojo-ActivePerl" target="_blank" rel="external">Mojo-ActivePerl下载地址</a></td>
</tr>
<tr>
<td>Mac</td>
<td>1. <strong>ActivePerl</strong></td>
<td><a href="http://www.activestate.com/activeperl/downloads" target="_blank" rel="external">ActivePerl下载地址</a>｜</td>
</tr>
</tbody>
</table>
<h3 id="安装-Mojo-Weixin-模块"><a href="#安装-Mojo-Weixin-模块" class="headerlink" title="安装 Mojo::Weixin 模块"></a>安装 Mojo::Weixin 模块</h3><p>首先需要安装 cpanm 工具：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpan -i App::cpanminus</span><br></pre></td></tr></table></figure></p>
<p>然后通过 cpanm 工具安装 Mojo::Weixin</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpanm Mojo::Weixin</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>将如下代码使用utf－8编码保存为源码文件：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env perl</span></span><br><span class="line"><span class="keyword">use</span> Mojo::Weixin;</span><br><span class="line"><span class="keyword">my</span> ($host,$port,$post_api);</span><br><span class="line"></span><br><span class="line">$host = <span class="string">"0.0.0.0"</span>; <span class="comment">#发送消息接口监听地址，修改为自己希望监听的地址</span></span><br><span class="line">$port = <span class="number">3000</span>;      <span class="comment">#发送消息接口监听端口，修改为自己希望监听的端口</span></span><br><span class="line"><span class="comment">#$post_api = 'http://xxxx';  #接收到的消息上报接口，如果不需要接收消息上报，可以删除或注释此行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $client = Mojo::Weixin-&gt;new(<span class="string">log_level=&gt;</span><span class="string">"info"</span>,<span class="string">ua_debug=&gt;</span><span class="number">0</span>,<span class="string">qrcode_path=&gt;</span><span class="string">"qrcode.jpg"</span>);</span><br><span class="line">$client-&gt;login();</span><br><span class="line">$client-&gt;load(<span class="string">"ShowMsg"</span>);</span><br><span class="line">$client-&gt;load(<span class="string">"Openwx"</span>,<span class="string">data=&gt;</span>&#123;<span class="string">listen=&gt;</span>[&#123;<span class="string">host=&gt;</span>$host,<span class="string">port=&gt;</span>$port&#125;], <span class="string">post_api=&gt;</span>$post_api&#125;);</span><br><span class="line">$client-&gt;run();</span><br></pre></td></tr></table></figure>
<p>上述代码保存为 <code>test.pl</code> ， 并通过 perl 来运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perl test.pl</span><br></pre></td></tr></table></figure>
<p>然后就会产生一个监听 3000 端口的 http 服务器。</p>
<p>未竟事宜可以参考<a href="https://github.com/sjdy521/Mojo-Weixin/blob/master/README.md" target="_blank" rel="external">此处</a></p>
<h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>为了方便调用二维码，还需要配置一个 Web 服务器。安装Nginx，在配置文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server ipv6only=on;</span><br><span class="line"></span><br><span class="line">    root /path/to/your/qrcode; # </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，能在浏览器中以 <code>http://xxx.xxx.xxx.xxx/qrcode.jpg</code> 的形式访问到二维码即配置成功。</p>
<h2 id="安装Qingchat"><a href="#安装Qingchat" class="headerlink" title="安装Qingchat"></a>安装Qingchat</h2><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>Qingchat已经上传到了pypi，只需要使用pip进行安装即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install qingchat</span><br></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>Qingchat最新开发版代码位于： <a href="https://github.com/Xuanwo/qingchat/tree/dev" target="_blank" rel="external">https://github.com/Xuanwo/qingchat/tree/dev</a></p>
<p>你可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install <span class="_">-e</span> git+https://github.com/Xuanwo/qingchat/tree/dev</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Xuanwo/qingchat/tree/dev</span><br><span class="line"><span class="built_in">cd</span> qingchat</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>以进行安装。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Qingchat 的使用非常简单：</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>通过如下命令配置后端服务器的 ip 地址和端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat config ip &lt;ip&gt;</span><br><span class="line">qingchat config port &lt;port&gt;</span><br></pre></td></tr></table></figure>
<p>配置文件默认会保存在<code>~/.config/qingchat/config.yml</code>。</p>
<blockquote>
<p>Win下可能需要设置<code>HOME</code>环境变量才能正常运行</p>
</blockquote>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>配置完毕后，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat config login</span><br></pre></td></tr></table></figure>
<p>就会自动弹出一个二维码，使用微信扫描并登录后即可。如果出现问题，请再次执行此命令。</p>
<h3 id="群发消息"><a href="#群发消息" class="headerlink" title="群发消息"></a>群发消息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat group list</span><br></pre></td></tr></table></figure>
<p>此命令可以列出你保存到通讯录中的所有群组。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat group choose &lt;group_name&gt;</span><br></pre></td></tr></table></figure>
<p>此命令可以将指定群组加入列表，支持正则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat group clean</span><br></pre></td></tr></table></figure>
<p>此命令可以清除列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qingchat group send -t &lt;content&gt;</span><br><span class="line">qingchat group send -i &lt;media&gt;</span><br><span class="line">qingchat group send <span class="_">-f</span> &lt;file&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t</code> 参数用于发送文本信息</li>
<li><code>-i</code> 参数用于发送媒体信息，图片会直接显示，其他类型将以文件形式传输</li>
<li><code>-f</code> 参数用于指定文件，逐行发送，在开头添加<code>!</code>可以发送媒体信息</li>
</ul>
<h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>Qingchat 目前还处于开发阶段，功能不完善，BUG也很多，部署也相当麻烦。接下来，我将努力完成以下工作：</p>
<ul>
<li>更好的二维码呈现机制</li>
<li>基于 Web 的图形化界面</li>
<li>支持消息上报的 Server 端</li>
<li>更多功能的实现，支持好友管理&amp;群组管理等</li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年04月01日 初次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在我之前写过的一篇文章中，我曾经探索过类似的问题：&lt;a href=&quot;https://xuanwo.org/2016/02/28/wechat-remove/&quot;&gt;微信群重复人员识别&lt;/a&gt;。当初我就提出过能否自动获取相关数据，但因为种种原因的限制不了了之了。后来发现了&lt;a href=&quot;https://github.com/sjdy521/Mojo-Weixin&quot;&gt;Mojo-Weixin&lt;/a&gt;这个库之后，我决定在这个的基础上实现一个微信多群直播的工具——Qingchat。（&lt;em&gt;尽管在刚刚实现完不久，微信就更新了转发到多个群的功能，Sad。&lt;/em&gt;）探索的成果如下： &lt;a href=&quot;https://github.com/Xuanwo/qingchat&quot;&gt;Qingchat&lt;/a&gt;，目前仅支持 python3 ，欢迎各位看官提 issues ，交 code ，或者拍砖。&lt;br&gt;接下来我会先介绍一下 Qingchat 的原理，然后介绍 Qingchat 的使用，最后展望一下 Qingchat 未来的发展方向。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
  </entry>
  
  <entry>
    <title>罹患痛风感言</title>
    <link href="https://xuanwo.org/2016/03/13/gout/"/>
    <id>https://xuanwo.org/2016/03/13/gout/</id>
    <published>2016-03-13T13:44:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<p>其实我很想写出获奖感言的感觉，但是痛风发作的时候真的好疼啊。。。</p>
<a id="more"></a>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>从高中开始，中指的关节就一直有一些不明的肿胀，摸上去硬硬的，平时也不会痛，只是屈伸和握拳的时候有些困难。一直到了大学，我女朋友一直非常在意我的手，总是催我去医院看看。于是假期的时候，我跟我妈去医院挂了骨科，还拍了CT，但是医生却说骨头没有问题，关节也没异常，让我去别的科室看看。其实我是有些懵逼的，因为我原来预想的最差的结果就是动一下手术，然后休息个把个月。现在这种状况让我有些隐约的不妙，毕竟未知才是最可怕的东西。<br>因为对家乡的医院水平比较怀疑，所以到了北京之后又挂了北医三院的号，然后做了一堆检查，那个医生让我挂一个副教授的号= =，说他不能确定，以前没有见过。好吧，我再挂一个副教授的号。然后副教授告诉我他也不能确定，让我去做一个更厉害的测试（RMB800+）。等到下一次又挂上号之后，他告诉我有了这个单子之后就能确诊我是痛风了。然后叮嘱我不要吃海鲜和啤酒，要多注意饮食，多喝水，控制体内尿酸含量，然后开了一堆降低尿酸的药。</p>
<h1 id="服药"><a href="#服药" class="headerlink" title="服药"></a>服药</h1><p>收了药之后就开始了一段稳定的服药阶段，医生给我开了三种药：苯溴马隆，痛风定和碳酸氢钠片。 <em>当然，我也是后来才知道医生给我开的药的搭配合理之处，不过那个时候的我还不太了解，所以才有了之后的磨难。</em> 苯溴马隆每天一片，痛风定每日三次，每次一片，碳酸氢钠每日三次，每次一片。那几天我基本上每天嘴巴里面都是药味，然后每天手里都捧着我的水杯喝个不停。主要的原因还是因为自己对于痛风以及伴随痛风而来的疼痛的恐惧，当然有些过激，但是现在感觉很有必要，只是那个时候还不是很明白。<br>除了吃药之外，每天的饮食也有一些变化，肉食倒是没有断，只是不再吃鱼了，这个让我那个喜欢吃鱼的女朋友非常难过。平时也不怎么喝酒，所以戒酒对于我来说倒是没有什么问题，反而多了一个可以合理拒绝敬酒的理由。<br>这种境况一直持续到我回家，我妈妈以及很多亲人都劝我不要再吃药了，主要的想法是这样的：这个病治不好的，吃药没有用，主要依靠饮食控制。很多药，比如苯溴马隆的副作用又很大，对肾不好等等。这么想也有道理，于是我就停了药，只是每天依然坚持多喝一些水。只是量没有达到医生的要求，医生当初给我开药的时候让我每天喝2.5升水，我在家的几天估计只喝了1升每天。</p>
<h1 id="发作"><a href="#发作" class="headerlink" title="发作"></a>发作</h1><p>再次开学之后，我已经停药大概一个月左右，身体没有发现任何异常，中指的关节还有一些变小的趋势，一切都在往好的方向发展。于是我做了一个现在挺后悔的决定：去打球。<br>第一次是周二，跟我的同学在一起打得。打得非常尽兴，由于很久没有运动，打完之后浑身酸软，第二天起床基本抬不起手的那种。<del>我不是很明白这其中的机理，可能是运动产生的乳酸通过某种形式转化为了尿酸，然后沉积了起来。</del>症状不明显，中指有些轻微发热而已，我以为是乳酸分解的正常现象，没有及时采取措施。然后周四晚上我又去跟公司里面的同事打球了，当然同样也很开心，虽说右手活动起来有些困难。回校之后，中指就开始以肉眼可见的速度肿胀起来。这个时候还没有觉得痛，只是行动稍微有些不便，跟女朋友说了之后，也只是让我好好休息，多喝喝水而已。一直到了周六的晚上，右手中指时不时地开始抽痛，左手食指的根部也开始红肿了起来，我有些紧张，开始大量喝茶，希望可以把尿酸都排出去。但，事与愿违。<br>到了周日的晚上，中指越来越严重的刺痛感已经让我完全睡不着觉了。那天晚上我抱着水杯通宵看完了 QG 与 Fnatic 的比赛（QG还输了，Sad），好不容易睡着之后，第二天发现情况并没有变好，反而感觉更加严重了——我完全没有办法忍受哪怕是穿衣服这种时候给我手指带来的疼痛感。没有办法，我打电话给我女朋友说明了情况，跟公司里面请了假，让舍友替我请假，全天呆在宿舍里面，只干一件事情——喝水。<br>那几天真的让我女朋友操碎了心，她把每种食物的嘌呤含量都背了下来，然后只给我买低嘌呤含量的东西送给我吃。但即使是这样，我的疼痛感也没有减轻很多。万般无奈之下，女朋友带我去挂了急诊，结果急诊的护士冷冰冰地告诉我们这个是痛风，让我们第二天来挂风湿免疫科。在好心人的指点下，我们去药房买了秋水仙碱，那个据说对缓解痛风急性发作由奇效的药。回去之后，我按照说明书，一个小时吃一片，吃了六个小时，但是感觉没有什么用。后来看了一个医生的博客，我采用了一次性吃两片，过一个小时之后再吃一片的策略。到了第二天，关节的肿痛有了很大的改善，配合上大量饮水，基本上已经可以正常生活了。<br>后来同样是痛风患者大胖哥告诉我，剧烈运动导致的痛风发作机理是这样的：血液中的PH保持一定范围，无氧运动导致的乳酸增多会降低尿酸的溶解度，所以在尿酸不一定很高的情况下就有可能导致结晶。只要有新生结晶的棱角状尖锐晶体，马上会让白细胞产生排异反应，这就是发炎，也就是痛风发作的症状。</p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>秋水仙碱作为一个剧毒物果然名不虚传，我被它的药效支配了很久，在我们宿舍的门口把我吃的一整碗炒饭全都吐了出来。不仅如此，我还腹泻了好几天，基本上没过多久就要上一次大号。<br>时至今日，我的左手食指根红肿已经全部退去，右手中指关节还有些肿，但是已经不会再有抽痛感，已经可以恢复正常生活了。</p>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>首先要非常感谢我女朋友对我的无微不至的照顾（尽管她并不看我的博客），她记下了每一种食物的嘌呤含量，专门买了PH值8.0的苏打水给我喝，如果没有她的帮助和支持，我不知道如何度过噩梦般的那几天；其次要感谢我的室友，他们帮我带饭，帮我请假，帮我穿衣服（恩- -，只是外套而已），在我呕吐之后替我打扫，喂我喝水甚至包括帮我开矿泉水的瓶盖和拉开宿舍的门等等，没有他们的话，我可能真的就只能躺在床上什么都做不了了；最后要感谢公司的同事们承担了本来属于我的工作，只对我说一句好好休息而已。<br>非常感谢你们，你们是我在那几天痛苦的回忆里面唯一的亮色。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>痛风发作是一件非常痛苦的事情，所以平时各位一定要注意饮食，养成良好的习惯，有条件的话定期去医院做检查，将疾病扼杀在摇篮之中。</p>
<p>即使患上了痛风，也不要自暴自弃，控制饮食，合理用药，完全可以保证以后不再发作。如果已经产生了痛风石，每天都需要大量饮水，保证每天的排尿量在3-5L左右。饮水量加大加上用碳酸氢钠能够降低肾脏发生尿酸钠结晶的风险，降低肾结石和肾衰竭的概率。</p>
<ul>
<li>痛风急性发作时：服用秋水仙碱（一次性两片，过一个小时后再服一片，如果不见好转，12小时后再服一片）和止疼药（布洛芬等等）。如果医院比较近的华，建议去医院静脉注射碳酸氢钠，少吃秋水仙碱。</li>
<li>痛风间歇期时：服用苯溴马隆（一天一片）以促进尿酸排泄，碳酸氢钠（碱化尿液，便于尿酸排出）</li>
<li>长期用药：别嘌呤醇（副作用大），痛风定非布索坦（副作用小，但极贵），痛风定胶囊（中药，可减少嘌呤生成）</li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年03月13日 首次发布</li>
<li>2016年08月03日 根据大胖哥的经验修改了部分不正确的内容，补充了一些痛风用药的知识。</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我很想写出获奖感言的感觉，但是痛风发作的时候真的好疼啊。。。&lt;/p&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://xuanwo.org/categories/Daily/"/>
    
    
  </entry>
  
  <entry>
    <title>Neovim慢速升级攻略</title>
    <link href="https://xuanwo.org/2016/03/12/neovim-slow-upgrade/"/>
    <id>https://xuanwo.org/2016/03/12/neovim-slow-upgrade/</id>
    <published>2016-03-12T11:00:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直都非常羡慕那些能把vim用得非常溜的人，但是自己总是不情愿去学，总是觉得vim的操作方式非常反人类，难度曲线太陡，不适合我。真正让我下定决心去学的，是因为系统切换到Ubuntu Gnome之后发现，Sublime Text 3 不能原生支持中文输入。同时我也发现，如果我不上来就折腾spf13这样的东西的话，其实vim非常好懂。于是，Neovim的慢速升级攻略就这样诞生了。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装可以参考<a href="https://github.com/neovim/neovim/wiki/Installing-Neovim" target="_blank" rel="external">此处</a><br>如果是Ubuntu 的话，则可以执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:neovim-ppa/unstable</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install neovim</span><br></pre></td></tr></table></figure>
<h1 id="Neovim常用操作"><a href="#Neovim常用操作" class="headerlink" title="Neovim常用操作"></a>Neovim常用操作</h1><h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p><code>gg</code> 移动到文件开头<br><code>G</code> 移动到文件末尾</p>
<h3 id="文件操作相关"><a href="#文件操作相关" class="headerlink" title="文件操作相关"></a>文件操作相关</h3><p><code>:w &lt;filename&gt;</code> 按照<filename>保存文件<br><code>:wq</code> 保存并退出<br><code>:q!</code> 退出不保存<br><code>:e</code> 打开新的文件并关闭当前文件，使用Tab可以补全</filename></p>
<h3 id="文件编辑相关"><a href="#文件编辑相关" class="headerlink" title="文件编辑相关"></a>文件编辑相关</h3><p><code>dd</code> 删除当前行<br><code>y</code> 复制<br><code>yy</code> 复制当前行<br><code>yG</code> 复制光标以上全部行<br><code>ygg</code> 复制光标以下全部行<br><code>p</code> 粘贴<br><code>u</code> 撤销</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="使用内置终端"><a href="#使用内置终端" class="headerlink" title="使用内置终端"></a>使用内置终端</h3><p><code>:terminal</code> 打开终端，输入exit并使用<code>esc</code>或<code>enter</code>即可退出</p>
<h3 id="与系统剪切板集成"><a href="#与系统剪切板集成" class="headerlink" title="与系统剪切板集成"></a>与系统剪切板集成</h3><p>这个地方折腾了好久，Neovim默认是支持<code>+</code>寄存器的，但是我通过<code>&quot;+y</code>命令调用寄存器时却提示<code>Clipboard No Provider</code>。通过阅读<a href="https://github.com/neovim/neovim/blob/master/runtime/doc/nvim_clipboard.txt#L19-L27" target="_blank" rel="external">文档</a>之后，我得知，必须要安装下列三个包中的至少一个，才能正常使用剪切板：</p>
<ul>
<li>xclip</li>
<li>xsel (newer alternative to xclip)</li>
<li>pbcopy/pbpaste (only for Mac OS X)</li>
</ul>
<p>安装好之后再打开，就可以正常使用了。</p>
<p><em>快速复制全文的技巧： 在Normal模式下，<code>gg</code>跳转到文章开头，<code>VG</code>选中全文，<code>&quot;+y</code>复制到剪切板。</em></p>
<h1 id="Neovim插件"><a href="#Neovim插件" class="headerlink" title="Neovim插件"></a>Neovim插件</h1><h2 id="vim-airline"><a href="#vim-airline" class="headerlink" title="vim-airline"></a>vim-airline</h2><p><a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="external">vim-airline</a>是一个vim的状态栏插件，同样支持neovim。</p>
<p><img src="https://github.com/vim-airline/vim-airline/wiki/screenshots/demo.gif" alt="vim-airline demo"></p>
<blockquote>
<p>安装此插件后启动nvim会报错，自行编译后错误消失，不知道具体的原因。</p>
</blockquote>
<h3 id="Smarter-tab-line"><a href="#Smarter-tab-line" class="headerlink" title="Smarter tab line"></a>Smarter tab line</h3><p>在<code>init.vim</code>中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos; 开启tabline功能</span><br><span class="line">let g:airline#extensions#tabline#enabled = 1</span><br><span class="line">&apos; 设置tabline分隔符</span><br><span class="line">let g:airline#extensions#tabline#left_sep = &apos; &apos;</span><br><span class="line">let g:airline#extensions#tabline#left_alt_sep = &apos;|&apos;</span><br></pre></td></tr></table></figure>
<p>支持的一些快捷操作命令：</p>
<p><code>:bn</code>: 跳转下一个buffer<br><code>:bp</code>: 往上一个buffer<br><code>:b&lt;n&gt;</code>: 跳往第n个buffer<br><code>:bd</code>: 关掉目前buffer</p>
<h3 id="vim-airline-themes"><a href="#vim-airline-themes" class="headerlink" title="vim-airline-themes"></a>vim-airline-themes</h3><p>个人比较偏爱<code>solarized</code>的暗色皮肤，所以需要使用这个库来安装airline配套的皮肤。<br>在<code>init.vim</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plug &apos;vim-airline/vim-airline-themes&apos;</span><br></pre></td></tr></table></figure>
<p>然后修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let g:airline_theme=&quot;solarized&quot;</span><br></pre></td></tr></table></figure>
<p>即可</p>
<h2 id="vim-colors-solarized"><a href="#vim-colors-solarized" class="headerlink" title="vim-colors-solarized"></a>vim-colors-solarized</h2><p>顾名思义，这是<code>solarized for vim</code>。<br>在<code>init.vim</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Plug &apos;altercation/vim-colors-solarized&apos;</span><br></pre></td></tr></table></figure>
<p>然后修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set background=dark</span><br><span class="line">colorscheme solarized</span><br></pre></td></tr></table></figure>
<p>即可</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年03月12日 首次发布</li>
<li>2016年03月15日 增加air-line相关内容</li>
<li>2016年06月16日 增加主题配置相关内容，并添加了部分常用快捷键</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一直都非常羡慕那些能把vim用得非常溜的人，但是自己总是不情愿去学，总是觉得vim的操作方式非常反人类，难度曲线太陡，不适合我。真正让我下定决心去学的，是因为系统切换到Ubuntu Gnome之后发现，Sublime Text 3 不能原生支持中文输入。同时我也发现，如果我不上来就折腾spf13这样的东西的话，其实vim非常好懂。于是，Neovim的慢速升级攻略就这样诞生了。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="vim" scheme="https://xuanwo.org/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>微信群重复人员识别</title>
    <link href="https://xuanwo.org/2016/02/28/wechat-remove/"/>
    <id>https://xuanwo.org/2016/02/28/wechat-remove/</id>
    <published>2016-02-28T10:05:00.000Z</published>
    <updated>2016-09-12T18:05:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于微信的限制，人数超过一百以后，只有邀请才能加入。所以，如果想要组织大型的在线活动，就只有建立很多个分群。然而分群的问题在于，会有很多人重复加群，挤占了本来就缺乏的空间。所以需要找到一个可行的办法，清除两个群中的重复人员。</p>
<a id="more"></a>
<h1 id="可行的方法"><a href="#可行的方法" class="headerlink" title="可行的方法"></a>可行的方法</h1><p>在微信网页版中，通过点击群名称右侧的向下箭头，可以打开一个有所有人昵称的面板，通过审查工具可以得到对应的代码，右击选择<code>Edit As HTML</code>，全选复制，保存到<code>a.txt</code>中，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat a.txt | grep -o <span class="string">"\"&gt;.*&lt;/p&gt;"</span> &gt; fen.txt</span><br></pre></td></tr></table></figure>
<p>我们便可以将所有人的名字都输出到<code>fen.txt</code>中，尽管还有着一些<code>&lt;</code>，<code>&gt;</code>的符号，但是已经不影响识别了，故不再做处理。</p>
<p>对两个群分别如此操作之后，我们得到了两个群的成员名单。<br>然后执行如下Python代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&apos;fen.txt&apos;, &apos;r&apos;) as f:</span><br><span class="line">    fen = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line">with open(&apos;main.txt&apos;, &apos;r&apos;) as f:</span><br><span class="line">    main = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line">for i in main:</span><br><span class="line">    for j in fen:</span><br><span class="line">        if i == j:</span><br><span class="line">            print(i)</span><br></pre></td></tr></table></figure>
<p>得到的输出就是两个群中重复的成员，然后一一删除即可。</p>
<h1 id="方案反思"><a href="#方案反思" class="headerlink" title="方案反思"></a>方案反思</h1><h2 id="存在的缺陷"><a href="#存在的缺陷" class="headerlink" title="存在的缺陷"></a>存在的缺陷</h2><ul>
<li>自动化程度较低</li>
<li>如果存在用户同名的话，会导致删除错误的用户。</li>
</ul>
<h2 id="可能的改进"><a href="#可能的改进" class="headerlink" title="可能的改进"></a>可能的改进</h2><ul>
<li>获取资料不需要手动点击审查元素，通过jQuery的text()函数也可以实现。</li>
<li>最后实现删除的过程可以进一步优化，通过模拟用户点击的脚本实现（存在隐私泄漏风险）。</li>
<li>可以获取用户的UUID，以避免重名现象。</li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年02月28日  首次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于微信的限制，人数超过一百以后，只有邀请才能加入。所以，如果想要组织大型的在线活动，就只有建立很多个分群。然而分群的问题在于，会有很多人重复加群，挤占了本来就缺乏的空间。所以需要找到一个可行的办法，清除两个群中的重复人员。&lt;/p&gt;
    
    </summary>
    
      <category term="Opinion" scheme="https://xuanwo.org/categories/Opinion/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="微信" scheme="https://xuanwo.org/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>记一次debug的经历及反思</title>
    <link href="https://xuanwo.org/2016/02/26/debug-for-hexo-1775/"/>
    <id>https://xuanwo.org/2016/02/26/debug-for-hexo-1775/</id>
    <published>2016-02-26T12:54:00.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p><a href="https://github.com/hexojs/hexo/issues/1775" target="_blank" rel="external">hexojs/hexo #1775</a><br>BUG非常明显，在使用hexo 3.1.1搭建一个位于子目录下的博客，然后会发现home以及categories的链接全都忽略了子目录的设定。</p>
<a id="more"></a>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>收到反馈之后，我在我的测试环境中也复现了这个bug。一开始还怀疑是主题的问题，专门测试了next主题，结果发现也存在这样的问题，于是就排除了主题方面的bug。<br>首先我们可以初步判断这个url生成出现了问题，参考landscape主题中此处的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% for (var i in theme.menu)&#123; %&gt;</span><br><span class="line">    &lt;a class=&quot;main-nav-link&quot; href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>这里调用了一个<code>url_for</code>函数来生成超链接，代码如下（去除了与本BUG无关的部分）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function urlForHelper(path, options) &#123;</span><br><span class="line">  path = path || &apos;/&apos;;</span><br><span class="line">  </span><br><span class="line">  if (path[0] === &apos;#&apos; || path.substring(0, 2) === &apos;//&apos;) &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var config = this.config;</span><br><span class="line">  var root = config.root;</span><br><span class="line">  var data = url.parse(path);</span><br><span class="line"></span><br><span class="line">  // Exit if this is an external path</span><br><span class="line">  if (data.protocol) &#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prepend root path</span><br><span class="line">  path = root + path;</span><br><span class="line"></span><br><span class="line">  return path.replace(/\/&#123;2,&#125;/g, &apos;/&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直觉告诉我，这个问题很有可能就是这个函数写搓了。</p>
<p>然而我仔细研究了一下，发现<code>url_for</code>的逻辑并没有什么问题。而且根据我脑补的代码执行情况来看，应该生成一个正确的链接才对，但是<code>config.root</code>偏偏就丢了。<br>真的是非常奇怪，一时之间，我完全懵逼展开了，不明白到底发生了什么。</p>
<h2 id="转折"><a href="#转折" class="headerlink" title="转折"></a>转折</h2><p>后来我跟我的朋友聊天的时候提到这个bug，结果他告诉我，这个<code>url_for</code>写搓了，我点点头，应该就是这样。然后他说，一个判断都没有中，直接返回自身了，还贴了一张图。图中的代码大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function urlForHelper(path, options)&#123;</span><br><span class="line">  /* jshint validthis: true */</span><br><span class="line">  path = path || &apos;/&apos;;</span><br><span class="line"></span><br><span class="line">  var config = this.config;</span><br><span class="line">  var root = config.root;</span><br><span class="line">  var data = url.parse(path);</span><br><span class="line"></span><br><span class="line">  // Exit if this is an external path</span><br><span class="line">  if (data.protocol || path.substring(0, 2) === &apos;//&apos;)&#123;</span><br><span class="line">    return path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Prepend root path</span><br><span class="line">  if (path[0] !== &apos;/&apos;)&#123;</span><br><span class="line">    return root + path;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到图我立马懵逼了，连忙说，不对啊，你这个不是最新版本的代码。他被我这气场吓到，弱弱回复，我是刚安装的hexo…。<br>我顿时明白自己错在哪里了，npm源里面的稳定版还是3.1.1，但是我们github库中的代码已经是3.2beta了。使用最新的代码测试以后，发现这个bug已经不存在了。<br>也就是说，我花一个下午的时间，对着最新版的代码找一个已经被fix的bug…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一次的事情非常乌龙，事后想想觉得自己真的太傻逼了。<br>吃一堑长一智，以后做debug工作的时候一定要分清楚线上和线下的代码，首先就要明确出问题的是哪个版本，然后再开展相应的分析。<br>除此以外，还跟我不重视流程有关系。尽管我总是让人提供各种version信息，但是我却总是在分析问题的时候忽略这些信息，没有把这些关键的信息加入到自己的分析过程中。<br>总结起来就是，too young ，姿势水平还有待提高。</p>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>2016年02月26日 初次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/hexojs/hexo/issues/1775&quot;&gt;hexojs/hexo #1775&lt;/a&gt;&lt;br&gt;BUG非常明显，在使用hexo 3.1.1搭建一个位于子目录下的博客，然后会发现home以及categories的链接全都忽略了子目录的设定。&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Hexo" scheme="https://xuanwo.org/tags/Hexo/"/>
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="Nodejs" scheme="https://xuanwo.org/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>北地网费新政策下的生存攻略</title>
    <link href="https://xuanwo.org/2016/02/17/ipv6-in-cugb/"/>
    <id>https://xuanwo.org/2016/02/17/ipv6-in-cugb/</id>
    <published>2016-02-17T18:59:02.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<p>主旨只有两条：开源，节流</p>
<a id="more"></a>
<h1 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h1><p>根据国家推广ipv6应用的相关规定，IPv6的流量依然是不计费的，所以我们需要充分利用IPv6的广泛资源。</p>
<blockquote>
<p>互联网通讯协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是互联网协议的最新版本，用于分组交换互联网络的网络层协议，旨在解决IPv4地址枯竭问题。</p>
</blockquote>
<h2 id="如何开启ipv6"><a href="#如何开启ipv6" class="headerlink" title="如何开启ipv6"></a>如何开启ipv6</h2><blockquote>
<p>下面内容仅适用于<strong>地大校园有线网</strong>，不适用于CUGBNET，不适用于绝大多数USB网卡。</p>
</blockquote>
<h3 id="检查自己的电脑是否已经打开ipv6支持"><a href="#检查自己的电脑是否已经打开ipv6支持" class="headerlink" title="检查自己的电脑是否已经打开ipv6支持"></a>检查自己的电脑是否已经打开ipv6支持</h3><p>打开浏览器访问： <a href="http://test-ipv6.com/" target="_blank" rel="external">http://test-ipv6.com/</a></p>
<p>如果所有项目都显示为绿勾，说明你已经可以正常使用IPv6了，如果有红叉，则需要打开系统对IPv6的支持</p>
<h3 id="打开ipv6"><a href="#打开ipv6" class="headerlink" title="打开ipv6"></a>打开ipv6</h3><p>Win + R 快捷键调出“运行”对话框，输入“ncpa.cpl”。如图：</p>
<p><img src="/imgs/opinion/ipv6-1.png" alt="Win+R"></p>
<p>回车后打开网络连接，在<code>以太网</code>上右击，选择最后一项<code>属性</code>，打开以太网属性，如图：</p>
<p><img src="/imgs/opinion/ipv6-2.png" alt="以太网属性"></p>
<p>向下浏览，确保<code>TCP/IPv6</code>这一项已经被选中。</p>
<p>然后使用<a href="http://gate.cugbteam.org" target="_blank" rel="external">此网址</a>登陆，深澜自带的登录器貌似有BUG，IPv6不会进行拨号。</p>
<h2 id="IPv6应用"><a href="#IPv6应用" class="headerlink" title="IPv6应用"></a>IPv6应用</h2><h3 id="PT下载"><a href="#PT下载" class="headerlink" title="PT下载"></a>PT下载</h3><blockquote>
<p>PT（Private Tracker）是一种改良自BitTorrent协议的P2P下载方式，“Private Tracker”指私有种子服务器。与BT最大的不同点分别为可进行私密范围下载，及可统计每个用户的上传及下载量。<br>PT可进行私密范围下载，因此提供PT的讨论区大多非公开的，采用邀请制或是不定时开放注册。用户注册后会得到一个passkey，因此可借由passkey辨识每个用户，用户从某PT站下载种子后，该种子即带有用户的passkey。因此PT的种子是不可外流到其他地方，且不允许一个用户有过多IP（通常上限为3个IP）同时上下传。<br>为了控制用户数量，关闭自由注册的PT网站一般采用邀请码制度，由已注册的用户向自己所信任的人发送邀请，以确保用户质量。<br>借由这些机制，传统P2P下载常发生一些client端只下载而不分享上传的“吸血”行为将可杜绝。而BT种子在一两周后做种者大幅减少，以致后来下载者无法顺利完档的缺点在PT获得改善。</p>
</blockquote>
<p>在教育网中，由于IPv6没有带宽和流量限制，所以PT下载得到了极大的发展。相对于IPv4下的下载，PT下载通常有以下优点：</p>
<ul>
<li>下载速度飞快，没有上限。在宿舍可以达到10M/s，在实验室可以达到100M/s。</li>
<li>国家正在推广IPv6，故IPv6不进行计费，所有IPv6的流量都是免费的。</li>
<li>资源丰富。由于PT站的私密特性，很多资源都保存地非常好，新的资源也更新地非常及时。</li>
</ul>
<p>老司机友情提醒，欲求先予，如果只下载不上传的话，很容易被删号的。在加入一个PT站的时候一定要先阅读PT站的说明，谨防封号。每个PT站基本都有着邀请制度，需要使用邀请码才能进入。</p>
<p>下面给出一些常用的PT站：</p>
<ul>
<li><a href="http://pt.cugb.edu.cn" target="_blank" rel="external">北地PT</a> <em>无需邀请，荒废多年，不过借这波机会应该会复苏了~</em></li>
<li><a href="http://bt.byr.cn/" target="_blank" rel="external">北邮人PT</a> <em>我校IPv6入口就在北邮，速度相当快，资源也很多，非常活跃</em></li>
<li><a href="http://bt.neu6.edu.cn/" target="_blank" rel="external">六维空间</a> <em>应当是教育网最大的PT站了，资源最多，非常活跃</em></li>
</ul>
<p>推荐的PT下载工具：</p>
<ul>
<li><a href="http://ll.www.utorrent.com/intl/en/" target="_blank" rel="external">utorrent</a></li>
<li><a href="http://www.bittorrent.com/" target="_blank" rel="external">bittorrent</a></li>
</ul>
<p><strong>绝对禁止使用迅雷下载，严重者可能导致封号。</strong></p>
<h3 id="IPv6电视"><a href="#IPv6电视" class="headerlink" title="IPv6电视"></a>IPv6电视</h3><p>IPv6电视就相对显得比较简单易懂了，直接在线收看即可，不消耗IPv4流量。</p>
<p>下面同样给出一些地址：</p>
<ul>
<li><a href="http://ipv6.pku.edu.cn/" target="_blank" rel="external">北京大学IPv6</a></li>
<li><a href="http://tv.byr.cn/" target="_blank" rel="external">北京邮电大学IPv6</a></li>
<li><a href="http://iptv.pdsu6.edu.cn/" target="_blank" rel="external">IPv6电视直播墙</a></li>
</ul>
<h3 id="IPv6转换"><a href="#IPv6转换" class="headerlink" title="IPv6转换"></a>IPv6转换</h3><p>当然也可以通过将IPv4流量转换为IPv6来逃开计费。</p>
<p>需要安装<a href="http://www.6kuaibo.com/" target="_blank" rel="external">六快拨浏览器</a>，使用该浏览器即可免费上网。</p>
<blockquote>
<p>利益无关，没有测试，不知速度如何。</p>
</blockquote>
<h1 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h1><h2 id="网络游戏流量消耗"><a href="#网络游戏流量消耗" class="headerlink" title="网络游戏流量消耗"></a>网络游戏流量消耗</h2><p>网络游戏耗费的流量不多，比如英雄联盟，一分钟只消耗一兆不到。所以玩游戏的童鞋们大可放心，按照每天撸三个小时来算，也不过是5.4G不到而已，不慌。</p>
<h2 id="内网文件传输"><a href="#内网文件传输" class="headerlink" title="内网文件传输"></a>内网文件传输</h2><p>可以用<a href="http://www.ipmsg.org.cn/" target="_blank" rel="external">飞鸽传书</a>，如果不放心可以在不登录网关的时候传输文件，只需要对方也安装了飞鸽传书即可。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在充分利用ipv6资源并辅以适当的节流方式下，可以将网费控制在20元(25G)以下。所以童鞋们大可不必惊慌。我的想法是，付费可以，但是请地大提供更加优秀的网络环境。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="external">IPv6</a></li>
<li><a href="https://zh.wikipedia.org/wiki/PT%E4%B8%8B%E8%BC%89" target="_blank" rel="external">PT下载</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年02月17日 初次发布</li>
<li>2016年02月20日 修复网关登录链接，补充PT下载工具</li>
<li>2016年03月11日 修复北京邮电大学IPv6电视链接</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主旨只有两条：开源，节流&lt;/p&gt;
    
    </summary>
    
      <category term="Opinion" scheme="https://xuanwo.org/categories/Opinion/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="CUGB" scheme="https://xuanwo.org/tags/CUGB/"/>
    
  </entry>
  
  <entry>
    <title>Chocolatey——Windows下的包管理工具</title>
    <link href="https://xuanwo.org/2016/02/15/chocolatey-intro/"/>
    <id>https://xuanwo.org/2016/02/15/chocolatey-intro/</id>
    <published>2016-02-15T20:15:46.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://chocolatey.org/" target="_blank" rel="external">Chocolatey</a>是一个基于Nuget的Windows包管理工具，截止到我更新此文章的时候，一共有3.7k多个独立包。本文旨在介绍Chocolatey这一工具的安装和用法，希望能有更多人享受到该工具的便利之处。</p>
<a id="more"></a>
<h1 id="安装chocolatey"><a href="#安装chocolatey" class="headerlink" title="安装chocolatey"></a>安装chocolatey</h1><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>打开一个具有管理员权限的命令行窗口，执行如下命令：<br><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy Bypass -Command <span class="string">"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))"</span> &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</span><br></pre></td></tr></table></figure></p>
<h2 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h2><p>打开一个具有管理员权限的PowerShell窗口，执行如下命令：<br><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">iex ((<span class="built_in">new-object</span> net.webclient).DownloadString(<span class="string">'https://chocolatey.org/install.ps1'</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="使用chocolatey"><a href="#使用chocolatey" class="headerlink" title="使用chocolatey"></a>使用chocolatey</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>安装包十分的容易，只需要打开管理员权限的命令行即可：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco install &lt;package&gt;</span><br></pre></td></tr></table></figure>
<h2 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h2><p>卸载也同样十分简单，打开管理员权限命令行，执行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco uninstall &lt;package&gt;</span><br></pre></td></tr></table></figure>
<h2 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h2><p>更新包则需要使用如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco upgrade &lt;package&gt;</span><br></pre></td></tr></table></figure>
<h1 id="为chocolatey做贡献"><a href="#为chocolatey做贡献" class="headerlink" title="为chocolatey做贡献"></a>为chocolatey做贡献</h1><p>Chocolatey的一个特点就是社区化的环境，每一个人都可以向它提交自己喜爱的包。因为Chocolatey总是从官方下载所需要的包，所以避免了授权等问题。当然，本来收费的软件，同样需要收费，比如JetBrains系列的产品。</p>
<h2 id="注册APIKey"><a href="#注册APIKey" class="headerlink" title="注册APIKey"></a>注册APIKey</h2><p>提交包则会略为复杂一点，首先你需要在<a href="https://chocolatey.org/" target="_blank" rel="external">https://chocolatey.org/</a> 注册一个账号，并获取跟你账户绑定的唯一APIKey。然后在命令行中执行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco apikey -k &lt;your key here&gt; -s https://chocolatey.org</span><br></pre></td></tr></table></figure>
<h2 id="新建软件包"><a href="#新建软件包" class="headerlink" title="新建软件包"></a>新建软件包</h2><p>在命令行中运行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco new &lt;package name here&gt;</span><br><span class="line"><span class="comment"># 为方便理解，此处使用test做包名</span></span><br></pre></td></tr></table></figure>
<p>则当前目录下就会自动生成一个名为<code>test</code>的文件夹，目录结构如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">test.nuspec</span><br><span class="line">tools</span><br><span class="line">  |--chocolateyinstall.ps1</span><br><span class="line">  |--chocolateyuninstall.ps1</span><br><span class="line">  |--ReadMe.md</span><br></pre></td></tr></table></figure>
<h2 id="完善信息"><a href="#完善信息" class="headerlink" title="完善信息"></a>完善信息</h2><h3 id="修改test-nuspec"><a href="#修改test-nuspec" class="headerlink" title="修改test.nuspec"></a>修改test.nuspec</h3><p>自动生成的描述文件在需要填写的位置都有大写英文注释，只需要按照要求一一填写即可，下面我列举一份已经通过审核的Datagrip的描述文件作为参考：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="comment">&lt;!-- Do not remove this test for UTF-8: if “Ω” doesn’t appear as greek uppercase omega letter enclosed in quotation marks, you should use an editor that supports UTF-8, not this one. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">xmlns</span>=<span class="string">"http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">metadata</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Read this before publishing packages to chocolatey.org: https://github.com/chocolatey/chocolatey/wiki/CreatePackages --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>datagrip<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DataGrip<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">authors</span>&gt;</span>JetBrains<span class="tag">&lt;/<span class="name">authors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">owners</span>&gt;</span>Xuanwo<span class="tag">&lt;/<span class="name">owners</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>Your Swiss Army Knife for Databases and SQL<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>## Intelligent query console</span><br><span class="line">Allows you to execute queries in different modes and provides local history that keeps track of all your activity and protects you from losing your work.</span><br><span class="line">......(省略)</span><br><span class="line"><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">projectUrl</span>&gt;</span>https://www.jetbrains.com/datagrip/<span class="tag">&lt;/<span class="name">projectUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packageSourceUrl</span>&gt;</span>https://github.com/Xuanwo/datagrip-chocolatey-package<span class="tag">&lt;/<span class="name">packageSourceUrl</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;projectSourceUrl&gt;&lt;/projectSourceUrl&gt;</span><br><span class="line">    &lt;docsUrl&gt;&lt;/docsUrl&gt;</span><br><span class="line">    &lt;mailingListUrl&gt;&lt;/mailingListUrl&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bugTrackerUrl</span>&gt;</span>https://youtrack.jetbrains.com/issues/DBE<span class="tag">&lt;/<span class="name">bugTrackerUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tags</span>&gt;</span>datagrip admin jetbrains trial 30days<span class="tag">&lt;/<span class="name">tags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">copyright</span>&gt;</span>Commercial<span class="tag">&lt;/<span class="name">copyright</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;licenseUrl&gt;&lt;/licenseUrl&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">requireLicenseAcceptance</span>&gt;</span>false<span class="tag">&lt;/<span class="name">requireLicenseAcceptance</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;iconUrl&gt;http://cdn.rawgit.com/__REPLACE_YOUR_REPO__/master/icons/datagrip.png&lt;/iconUrl&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency id="" version="__VERSION__" /&gt;</span><br><span class="line">      &lt;dependency id="" /&gt;</span><br><span class="line">    &lt;/dependencies&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releaseNotes</span>&gt;</span>https://confluence.jetbrains.com/display/DBE/DataGrip+1.0.1+Release+Notes<span class="tag">&lt;/<span class="name">releaseNotes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;provides&gt;&lt;/provides&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">files</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">file</span> <span class="attr">src</span>=<span class="string">"tools\**"</span> <span class="attr">target</span>=<span class="string">"tools"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">files</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有一个比较坑的地方是<code>&lt;description&gt;</code>部分是支持Markdown的，内容直接顶着括号写就OK，不用另起一行，也不用自己加缩进。</p>
<h3 id="补充chocolateyinstall-ps1"><a href="#补充chocolateyinstall-ps1" class="headerlink" title="补充chocolateyinstall.ps1"></a>补充chocolateyinstall.ps1</h3><blockquote>
<p><code>chocolateyuninstall</code>可以没有，但是一定要有<code>chocolateyinstall</code>脚本。</p>
</blockquote>
<p><code>chocolateyinstall.ps1</code>如果点击<code>编辑</code>打开的话，会自动调用<code>Windows Powershell ISE</code>编辑器。</p>
<p>下面同样列举一份已经填写完成的样例：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$packageName</span>= <span class="string">'datagrip'</span></span><br><span class="line"><span class="variable">$installerType</span> = <span class="string">'EXE'</span></span><br><span class="line"><span class="variable">$toolsDir</span>   = <span class="string">"$(Split-Path -parent <span class="variable">$MyInvocation</span>.MyCommand.Definition)"</span></span><br><span class="line"><span class="variable">$url</span>        = <span class="string">'https://download.jetbrains.com/datagrip/datagrip-1.0.1.exe'</span></span><br><span class="line"><span class="variable">$silentArgs</span> = <span class="string">'/S'</span></span><br><span class="line"><span class="variable">$validExitCodes</span> = @(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Install-ChocolateyPackage <span class="string">"<span class="variable">$packageName</span>"</span> <span class="string">"<span class="variable">$installerType</span>"</span> <span class="string">"<span class="variable">$silentArgs</span>"</span> <span class="string">"<span class="variable">$url</span>"</span>  -validExitCodes <span class="variable">$validExitCodes</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，填写完毕之后，一定要在Powershell中运行下列代码以删除所有的注释文字：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$f</span>=<span class="string">'c:\path\to\thisFile.ps1'</span></span><br><span class="line">gc <span class="variable">$f</span> | ? &#123;<span class="variable">$_</span> <span class="nomarkup">-notmatch</span> <span class="string">"^\s*#"</span>&#125; | % &#123;<span class="variable">$_</span> <span class="nomarkup">-replace</span> <span class="string">'(^.*?)\s*?[^``]#.*'</span>,<span class="string">'$1'</span>&#125; | <span class="built_in">Out-File</span> <span class="variable">$f</span>+<span class="string">".~"</span> -en utf8; mv -fo <span class="variable">$f</span>+<span class="string">".~"</span> <span class="variable">$f</span></span><br></pre></td></tr></table></figure>
<h3 id="打包上传"><a href="#打包上传" class="headerlink" title="打包上传"></a>打包上传</h3><p>所有的信息填写完成后，在<code>test.nuspec</code>所在目录下执行<code>choco pack</code>就会自动进行打包。<br>如果有重要的信息没有填写，choco将会报错，并红字提示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">LicenseUrl cannot be empty.</span><br><span class="line">ProjectUrl cannot be empty.</span><br><span class="line">PackageSourceUrl cannot be empty.</span><br></pre></td></tr></table></figure>
<p>如果没有问题，则会有如下提示：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Attempting to build package from <span class="string">'datagrip.nuspec'</span>.</span><br><span class="line">Successfully created package <span class="string">'datagrip.1.0.1.nupkg'</span></span><br></pre></td></tr></table></figure>
<p>之后执行 <code>choco push datagrip.1.0.1.nupkg</code>即可将包上传至Chocolatey，通过管理员的审核之后，就会出现在软件列表中供人们下载了。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://chocolatey.org/" target="_blank" rel="external">Chocolatey 官方网站</a></li>
<li><a href="http://isaachan.github.io/blog/2013/02/07/chocolatey-i-love-you/" target="_blank" rel="external">Chocolatey, 我爱你</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年02月15日 初步完成</li>
<li>2016年02月20日 修复脚本中的部分错误</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://chocolatey.org/&quot;&gt;Chocolatey&lt;/a&gt;是一个基于Nuget的Windows包管理工具，截止到我更新此文章的时候，一共有3.7k多个独立包。本文旨在介绍Chocolatey这一工具的安装和用法，希望能有更多人享受到该工具的便利之处。&lt;/p&gt;
    
    </summary>
    
      <category term="Opinion" scheme="https://xuanwo.org/categories/Opinion/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="Windows" scheme="https://xuanwo.org/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>解放你的智能电视</title>
    <link href="https://xuanwo.org/2016/02/04/unlock-your-smart-tv/"/>
    <id>https://xuanwo.org/2016/02/04/unlock-your-smart-tv/</id>
    <published>2016-02-04T23:12:52.000Z</published>
    <updated>2016-09-12T18:05:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在很多人都买了智能电视，但是出于种种你懂得原因，厂商通常都不允许用户自行安装自己想要的APP，比如腾讯视频，优酷视频之类的。本教程旨在突破这些限制，彻底解放智能电视的全部潜力。</p>
<a id="more"></a>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><ul>
<li>一台智能电视（基于安卓平台）</li>
<li>一台电脑</li>
<li>互联网连接</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="自己动手丰衣足食"><a href="#自己动手丰衣足食" class="headerlink" title="自己动手丰衣足食"></a>自己动手丰衣足食</h2><blockquote>
<p>强力推荐，避免第三方软件安装莫名其妙的东西，没有后台驻留</p>
</blockquote>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li>将电视和电脑接入同一个路由器</li>
<li>下载<a href="http://pan.baidu.com/s/1eRbMCca" target="_blank" rel="external"><code>智能电视解放工具</code></a>并解压</li>
<li>获取电视的IP地址</li>
</ol>
<blockquote>
<p>电视的IP地址一般可以通过点击<code>设置</code>-<code>网络设置</code>来获得，是一个形如<code>192.168.1.105</code>的数字串</p>
</blockquote>
<h3 id="连接电视"><a href="#连接电视" class="headerlink" title="连接电视"></a>连接电视</h3><ul>
<li>打开<code>TCPUDP调试工具</code>文件夹中的<code>点我执行.exe</code></li>
</ul>
<p><img src="/imgs/opinion/unlock-smart-tv-self-1.png" alt="TCP调试工具"></p>
<ul>
<li>点击<code>创建连接</code></li>
</ul>
<p><img src="/imgs/opinion/unlock-smart-tv-self-2.png" alt="TCP调试工具"></p>
<ol>
<li>类型选择<code>TCP</code></li>
<li>目标IP填写刚才获取到的电视IP地址</li>
<li>端口填写<code>8090</code></li>
<li>其他的不用修改</li>
<li>确认填写正确后，点击<code>创建</code></li>
</ol>
<ul>
<li>点击<code>连接</code></li>
</ul>
<p>如果没有出现问题，软件的界面将会变成下图式样：</p>
<p><img src="/imgs/opinion/unlock-smart-tv-self-3.png" alt="TCP调试工具"></p>
<ul>
<li>清除上面的发送框中所有文字并输入<code>start adbd</code>，然后点击发送</li>
</ul>
<p><img src="/imgs/opinion/unlock-smart-tv-self-4.png" alt="TCP调试工具"></p>
<p>如果如图，在下面的接受框中出现了<code>ok</code>，说明已经连接成功了~</p>
<h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><ul>
<li>将所有需要安装的APK文件都放到<code>一键安装软件</code>文件夹中</li>
<li>点击<code>双击运行一键安装.bat</code>，按照提示输入IP地址并回车，如图：</li>
</ul>
<p><img src="/imgs/opinion/unlock-smart-tv-self-5.png" alt="TCP调试工具"></p>
<p>等到提示安装成功后，你就已经成功地在电视上安装上了想要的APP了~</p>
<h2 id="一键工具"><a href="#一键工具" class="headerlink" title="一键工具"></a>一键工具</h2><blockquote>
<p>方便快捷，但是会在电视上安装辅助工具</p>
</blockquote>
<p>这个工具名为<code>TV盒子助手</code>，官方网址为： <a href="http://www.cnhezi.com/" target="_blank" rel="external">http://www.cnhezi.com/</a></p>
<p>本质上，这个工具就是将前面的教程打包起来制作而成的，但是它会在电视上安装一个辅助工具，比较奇怪。</p>
<h1 id="推荐应用"><a href="#推荐应用" class="headerlink" title="推荐应用"></a>推荐应用</h1><ul>
<li><a href="http://tv.qq.com/" target="_blank" rel="external">腾讯视频TV版</a></li>
<li><a href="http://pd.youku.com/CIBN" target="_blank" rel="external">CIBN合一影视<em>内容提供方：优酷</em></a></li>
<li><a href="http://app.iqiyi.com/tv/player/" target="_blank" rel="external">银河·奇异果<em>内容提供方：爱奇艺</em></a></li>
</ul>
<h1 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h1><ul>
<li>理论上来说，所有的安卓应用都可以进行安装。但是由于电视操控上的特殊性，没有对电视进行适配的应用非常难以使用，故不推荐进行安装。</li>
<li>大部分智能电视的内存都比较小，故不能同时运行太多软件，所以建议打开应用前先退出别的应用否则容易出现卡顿现象。</li>
<li>原本能用的APP现在不能用了是因为<a href="http://news.xinhuanet.com/politics/2015-11/16/c_128434204.htm" target="_blank" rel="external">广电总局全面封杀了电视盒子</a>，一大批应用都被下架了，而且要求禁止提供APP安装功能。</li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年02月04日 初次发布</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;现在很多人都买了智能电视，但是出于种种你懂得原因，厂商通常都不允许用户自行安装自己想要的APP，比如腾讯视频，优酷视频之类的。本教程旨在突破这些限制，彻底解放智能电视的全部潜力。&lt;/p&gt;
    
    </summary>
    
      <category term="Opinion" scheme="https://xuanwo.org/categories/Opinion/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
  </entry>
  
  <entry>
    <title>如何识别真假链接？</title>
    <link href="https://xuanwo.org/2016/01/13/how-to-differ-invalid-link/"/>
    <id>https://xuanwo.org/2016/01/13/how-to-differ-invalid-link/</id>
    <published>2016-01-13T01:18:51.000Z</published>
    <updated>2016-09-12T18:05:34.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前两天我的朋友圈被微信公开课活动的链接+截图刷屏，随后一大帮“业内人士”站出来说这个是盗号连接，只要点开，微信钱包和支付宝就会被盗。作为半个业内人士，我不能忍了，决定跟大家谈一谈如何识别真假链接。</p>
<a id="more"></a>
<h1 id="域名是什么？"><a href="#域名是什么？" class="headerlink" title="域名是什么？"></a>域名是什么？</h1><p>首先我们来介绍一下域名：域名就是计算机在网络上的名字，免去人们需要记忆IP地址的困扰。<br>域名由若干个英文字母和数字组成，由<code>.</code>分割成几份，形成一个网络上唯一的访问地址。</p>
<p>以<code>https://support.weixin.qq.com</code>为例：</p>
<ul>
<li><code>support.weixin.qq.com</code>为三级域名</li>
<li><code>weixin.qq.com</code>为二级域名</li>
<li><code>qq.com</code>为一级域名</li>
<li><code>.com</code>是顶级域名后缀</li>
</ul>
<h1 id="链接是什么？"><a href="#链接是什么？" class="headerlink" title="链接是什么？"></a>链接是什么？</h1><p>然后我们来介绍一下<code>链接</code>，也就是URL，全称为<code>统一资源定位符</code>，我们也称它们为<code>网址</code>。链接的标准格式一般如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议类型://服务器地址（必要时需加上端口号）/路径/文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>协议类型：常用的有http，https，ftp等</li>
</ul>
<blockquote>
<p>https意味着什么？<br>https又叫做<code>超文本传输安全协议</code>，使用这个协议意味着你与这个网页的所有交互都是加密的，任何第三方都无法窥探你传输的信息（相对而言的，世上没有绝对的安全），经常被用于万维网上的交易支付和企业信息系统中敏感信息的传输。</p>
</blockquote>
<ul>
<li>服务器地址：一般都是域名，有时为IP地址</li>
<li>端口号：http预设的80端口以及https的443端口可以省略</li>
<li>路径：以“/”字元区别路径中的每一个目录名称</li>
<li>查询：GET模式的表单参数，以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题</li>
</ul>
<h1 id="如何分析一个链接？"><a href="#如何分析一个链接？" class="headerlink" title="如何分析一个链接？"></a>如何分析一个链接？</h1><p>比如说我们这次微信公开课活动的链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://support.weixin.qq.com/cgi-bin/xxxxxxxx</span><br></pre></td></tr></table></figure>
<p>对于用户而言，有用的信息如下：协议采用https协议，域名为<code>support.weixin.qq.com</code>。<br>采用https协议意味着你的信息是受到保护的，即使你使用了公共的wifi，同一wifi下的可能存在着的黑客也无法窥探你的私人信息。域名<code>support.weixin.qq.com</code>传递了如下信息，这个网页是归属于<code>qq.com</code>的，这从源头上保证了这一网页的安全性（如果腾讯没有内鬼的话）。</p>
<p>下面我们来看看一个假的链接是怎么样的：</p>
<blockquote>
<p>亲爱的淘宝用户您好，恭喜您在本次活动中获得特等奖iPhone6s一部，请登陆 <a href="http://www.taoba0.com" target="_blank" rel="external">http://www.taoba0.com</a> 领取您的奖品。</p>
</blockquote>
<p>这是一条诈骗短信，我们可以看到骗子给出了这样一个链接<code>http://www.taoba0.com</code>，一定要看清楚是<code>taoba0</code>而不是<code>taobao</code>，然后你就应该明白，这是一条诈骗短信了。值得提醒的是，现在前端技术高度发达，克隆复制一个网页非常容易，所以在网站之间挑战时，一定要确认自己点击的链接是正确的链接，否则极有可能被相似的页面欺骗。</p>
<h1 id="如何保证安全？"><a href="#如何保证安全？" class="headerlink" title="如何保证安全？"></a>如何保证安全？</h1><p>从上一个链接的分析中，我们可以得出以下几个小技巧：</p>
<ul>
<li>尽可能地使用https协议进行访问</li>
<li>认清域名，不轻信非官方域名的页面</li>
<li>网站之间跳转时，确认自己点击的链接是否正确</li>
</ul>
<h1 id="最后的寄语"><a href="#最后的寄语" class="headerlink" title="最后的寄语"></a>最后的寄语</h1><ul>
<li>请开启两部验证。国外的账户大多支持Google的两部验证，请启用这一功能。国内的账户的话，QQ请打开设备锁，QQ邮箱请打开独立密码。</li>
<li>不要贪小便宜！不要贪小便宜！！不要贪小便宜！！！重要的事情说三遍。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D" target="_blank" rel="external">域名-维基百科</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">统一资源定位符-维基百科</a></li>
</ul>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年1月13日 首次发布</li>
<li>2016年1月14日 更新了域名相关知识</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前两天我的朋友圈被微信公开课活动的链接+截图刷屏，随后一大帮“业内人士”站出来说这个是盗号连接，只要点开，微信钱包和支付宝就会被盗。作为半个业内人士，我不能忍了，决定跟大家谈一谈如何识别真假链接。&lt;/p&gt;
    
    </summary>
    
      <category term="Daily" scheme="https://xuanwo.org/categories/Daily/"/>
    
    
      <category term="Software" scheme="https://xuanwo.org/tags/Software/"/>
    
      <category term="科普" scheme="https://xuanwo.org/tags/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>VS2015连接Oracle数据库</title>
    <link href="https://xuanwo.org/2016/01/03/vs-oracle-11g/"/>
    <id>https://xuanwo.org/2016/01/03/vs-oracle-11g/</id>
    <published>2016-01-03T15:31:32.000Z</published>
    <updated>2016-09-12T18:05:34.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><p>宿主机：Win10 + VS2015 + ODP.Net for VS2015<br>虚拟机：Win7 + Oracle 11g + 桥接</p>
<a id="more"></a>
<h1 id="配置ODP-Net"><a href="#配置ODP-Net" class="headerlink" title="配置ODP.Net"></a>配置ODP.Net</h1><p>首先下载 <a href="http://www.oracle.com/technetwork/topics/dotnet/downloads/odacmsidownload-2745497.html" target="_blank" rel="external">Oracle Developer Tools for Visual Studio 2015</a> ，下载此文件需要注册Oracle社区账号并接受相关的协议，此文件提供了以下组件：</p>
<ul>
<li>Oracle Developer Tools for Visual Studio 12.1.0.2.4</li>
<li>Oracle Data Provider for .NET 4 12.1.0.2.0</li>
<li>Oracle Providers for ASP.NET 4 12.1.0.2.0</li>
</ul>
<p>下载完成后运行MSI安装程序进行安装，安装完成后会自动注册VS2015的相关插件，重新启动VS2015后将会看到Oracle的相关命令，比如SQL *PLUS支持等。同时添加数据库时也能看到相应的选项。</p>
<blockquote>
<p>ODP.Net支持所有Oracle版本，因此下载时只需要注意VS的版本即可。</p>
</blockquote>
<h1 id="配置tnsnames-ora"><a href="#配置tnsnames-ora" class="headerlink" title="配置tnsnames.ora"></a>配置tnsnames.ora</h1><blockquote>
<p>ODP.Net默认使用安装目录下的<code>tnsnames.ora</code>，若安装目录在Program Files下，可能会遇到无权限等问题，此时使用管理员权限打开命令行，切换到对应目录并使用notepad编辑。</p>
</blockquote>
<p>复制服务器端的tnsnames.ora文件内容，或者自己手动编辑，格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;数据源别名&gt; =</span><br><span class="line">  (DESCRIPTION =</span><br><span class="line">    (ADDRESS = (PROTOCOL = TCP)(HOST = &lt;主机名或IP&gt;)(PORT = &lt;端口号&gt;))</span><br><span class="line">    (CONNECT_DATA =</span><br><span class="line">      (SERVER = DEDICATED)</span><br><span class="line">      (SERVICE_NAME = &lt;数据库服务名&gt;)</span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h1 id="添加数据库"><a href="#添加数据库" class="headerlink" title="添加数据库"></a>添加数据库</h1><p>打开<code>工具</code>-<code>连接到数据库</code>，数据源修改为<code>Oracle数据库</code>下的<code>ODP.NET,托管驱动程序</code>，然后点击<code>确定</code>，打开<code>添加连接</code>窗口。<br><img src="/imgs/develop/add-database.png" alt="添加连接"><br>填写用户名，密码并选择数据源，然后测试连接，成功的话说明已经连通，点击确定即可。</p>
<blockquote>
<p>使用虚拟机搭建数据库的额外Tips<br>根据某网友分析，Oracle的监听器在通过1521端口连接后，会开启另外一个新的随机端口进行数据通讯，因此使用NAT方式虚拟网卡可能会导致连接失败。这种情况下，请使用桥接方式虚拟网卡，并在<code>net manager</code>中将<code>loaclhost</code>修改为虚拟机当前的IP。重启监听服务后，再试。</p>
</blockquote>
<h1 id="连接数据库并使用"><a href="#连接数据库并使用" class="headerlink" title="连接数据库并使用"></a>连接数据库并使用</h1><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> oradb <span class="keyword">As</span> <span class="built_in">String</span> = <span class="string">"User ID=system;Password=123456;Data Source=lol"</span></span><br><span class="line"><span class="keyword">Dim</span> conn <span class="keyword">As</span> <span class="keyword">New</span> OracleConnection(oradb)</span><br><span class="line">conn.Open()</span><br><span class="line"><span class="keyword">Dim</span> sql <span class="keyword">As</span> <span class="built_in">String</span> = <span class="string">"create table xxx"</span></span><br><span class="line"><span class="keyword">Dim</span> sqlCom <span class="keyword">As</span> <span class="keyword">New</span> OracleCommand</span><br><span class="line">sqlCom.CommandText = sql</span><br><span class="line">sqlCom.Connection = conn</span><br><span class="line">sqlCom.ExecuteNonQuery()</span><br></pre></td></tr></table></figure>
<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><p>成功配置数据源之后，只需要向界面上拖动<code>DataGridView</code>，并进行相关配置，选择自己需要的表即可。</p>
<h2 id="插入图片的正确姿势"><a href="#插入图片的正确姿势" class="headerlink" title="插入图片的正确姿势"></a>插入图片的正确姿势</h2><p>图片作为二进制数据无法直接拼凑出SQL命令，我们需要使用<code>OracleCommand</code>自带的<code>Parameters</code>功能。在SQL命令中用<code>:photo</code>来代表一个参量，然后使用</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">sqlCom.Parameters.Add(<span class="string">"photo"</span>, OracleDbType.Blob, imgData.Length)</span><br></pre></td></tr></table></figure>
<p>来分别指定这个参量的类型和所占空间大小</p>
<p>最后使用</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">sqlCom.Parameters(<span class="number">0</span>).Value = imgData</span><br></pre></td></tr></table></figure>
<p>来指定这个参量的值。</p>
<p>整个插入图片过程的代码如下：</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Dim</span> conn <span class="keyword">As</span> <span class="keyword">New</span> OracleConnection(oradb)</span><br><span class="line"><span class="keyword">Dim</span> imgData(<span class="number">0</span>) <span class="keyword">As</span> <span class="built_in">Byte</span></span><br><span class="line"><span class="keyword">Dim</span> ms <span class="keyword">As</span> <span class="keyword">New</span> System.IO.MemoryStream</span><br><span class="line">PictureBox1.BackgroundImage.Save(ms, PictureBox1.BackgroundImage.RawFormat)</span><br><span class="line"><span class="keyword">ReDim</span> imgData(ms.Length - <span class="number">1</span>)</span><br><span class="line">ms.Read(imgData, <span class="number">0</span>, ms.Length)</span><br><span class="line">ms.Close()</span><br><span class="line">conn.Open()</span><br><span class="line"><span class="keyword">Dim</span> sql <span class="keyword">As</span> <span class="built_in">String</span> = <span class="string">"insert into hero values"</span> &amp; <span class="string">"("</span> &amp; TextBox1.<span class="keyword">Text</span> &amp; <span class="string">":photo"</span> &amp; <span class="string">")"</span></span><br><span class="line"><span class="keyword">Dim</span> sqlCom <span class="keyword">As</span> <span class="keyword">New</span> OracleCommand</span><br><span class="line">sqlCom.CommandText = sql</span><br><span class="line">sqlCom.Connection = conn</span><br><span class="line">sqlCom.Parameters.Add(<span class="string">"photo"</span>, OracleDbType.Blob, imgData.Length)</span><br><span class="line">sqlCom.Parameters(<span class="number">0</span>).Value = imgData</span><br><span class="line">sqlCom.ExecuteNonQuery()</span><br></pre></td></tr></table></figure>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><h2 id="column-not-allowed-here"><a href="#column-not-allowed-here" class="headerlink" title="column not allowed here"></a>column not allowed here</h2><p>数据类型不符，检查对应项目数据类型是否正确。</p>
<h2 id="missing-comma"><a href="#missing-comma" class="headerlink" title="missing comma"></a>missing comma</h2><p>命令格式不对，检查一下自己的SQL命令是否有错误，特别是在有字符串的时候，需要使用<code>&quot;&quot;</code>来代表一个字符串中的<code>&quot;</code>。</p>
<h2 id="identifier-is-too-long"><a href="#identifier-is-too-long" class="headerlink" title="identifier is too long"></a>identifier is too long</h2><p>标识符过长（不得超过30字符），不是非常明白原因，不过我取消掉insert命令中指定位置的部分之后，这个错误消失了。</p>
<h2 id="missing-INTO-keyword"><a href="#missing-INTO-keyword" class="headerlink" title="missing INTO keyword"></a>missing INTO keyword</h2><p>缺少into关键字（手滑打成了inte），检查一下自己的SQL命令是否有错误。</p>
<h2 id="cannot-insert-NULL-into-“SYSTEM”-”HERO”-”HEROCATEGORYID”"><a href="#cannot-insert-NULL-into-“SYSTEM”-”HERO”-”HEROCATEGORYID”" class="headerlink" title="cannot insert NULL into (“SYSTEM”.”HERO”.”HEROCATEGORYID”)"></a>cannot insert NULL into (“SYSTEM”.”HERO”.”HEROCATEGORYID”)</h2><p>这些项都指定了非0值，故不能不赋值，为对应项目赋值即可。</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>2016年01月03日 初步完成</li>
</ul>
<link href="/css/prism-solarizedlight.css" rel="stylesheet">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h1&gt;&lt;p&gt;宿主机：Win10 + VS2015 + ODP.Net for VS2015&lt;br&gt;虚拟机：Win7 + Oracle 11g + 桥接&lt;/p&gt;
    
    </summary>
    
      <category term="Develop" scheme="https://xuanwo.org/categories/Develop/"/>
    
    
      <category term="Database" scheme="https://xuanwo.org/tags/Database/"/>
    
      <category term="Oracle" scheme="https://xuanwo.org/tags/Oracle/"/>
    
      <category term="VB" scheme="https://xuanwo.org/tags/VB/"/>
    
  </entry>
  
</feed>
