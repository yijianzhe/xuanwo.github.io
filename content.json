{"meta":{"title":"Xuanwo's Blog","subtitle":"A Long Way to Go","description":"Keep learning!","author":"Xuanwo","url":"https://xuanwo.org"},"pages":[{"title":"关于我以及本博客","date":"2014-06-05T23:00:00.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"about/index.html","permalink":"https://xuanwo.org/about/index.html","excerpt":"","text":"现状 中国地质大学（北京）本科三年级在读生 信息管理与信息系统专业 青云QingCloud实习中 恋爱ing 奖项 幼儿园时多次获得小红花 第六届蓝桥杯北京赛区二等奖 第一届CCPC铜奖 第三十届ACM/ICPC沈阳站铜奖 兴趣 动漫（偏治愈向，喜欢AB，CL，那朵花，言叶之庭等作。） 游戏（玩过很多，都不精通，撸啊撸郊区黄金） 小说（主要看科幻和玄幻类作品，喜欢大刘和猫腻，正在看择天记） 体育（会打篮球，不是很厉害） 代码（沉浸在代码中会有安静的感觉） 软件（喜欢试用各种稀奇古怪的软件和应用，欢迎推荐） 技能语言类 C/C++ 熟练 html，css，js 初步 python 初步 node.js 初步 工具类 git 熟练 shell/bash 初步（目前最爱 Zsh） 各类艹墙工具 熟练 正在捣鼓 Qingchat 一个比较蠢的微信群发机器人 Jade-ims 系统分析与设计的大作业，基于Flask+Sqlite3 博客更新日志 2014年06月12日 完成现状和兴趣介绍。 2014年07月03日 迁移至Hexo引擎构建博客。 2014年07月08日 修改Google Fonts服务为360字体库，提升了博客加载速度。（屏蔽弄得我生不如死= =） 2014年07月11日 花了两个小时时间成功翻墙，将所有字体库和镜像库修改为Google的服务，加载速度再次提升。恩，计划有空写一篇关于翻墙的教程。 2014年08月05日 完成最近动向板块。经过一段时间的颓废之后，要努力开始学一点东西了！ 2014年08月08日 在学长的劝说下，终于放弃了谷歌字体，转而使用Web安全字体，速度快了一大截= = 2014年08月09日 所有js库全部使用七牛CDN加载，文件使用七牛的空间，再一次提升了加载速度。并且开始使用360网站卫士进行加速，DNS解析时间从1000ms+降到了200ms，可喜可贺。 2014年08月10日 将个人介绍和To-do分开，方面阅读和使用，删除最近动向板块。 2014年08月16日 花钱买下了xuanwo.org这个域名，好好干吧～ 2014年08月29日 新增关于开源项目的介绍。 2014年09月03日 新增关于个人技能的介绍。 2015年01月07日 更换主题，迁移评论 2015年02月19日 更换主题= =，补充最近的成果 2015年03月25日 修改了一些细节= = 2015年06月07日 修改主题，添加了Tags和Category的页面。目前比较丑- -，考完试优化一下。 2015年06月09日 将评论系统迁移到了Disqus，更改主题为NexT。 2015年06月10日 去除了羞耻的黑历史。 2015年06月30日 补充了关于成果的最新动态，标注出了目前失效的链接。 2015年07月27日 更新了一波主题，尝试寻找Material Design的感觉 2015年09月04日 开启了全站HTTPS，迁移至Cloudflare 2015年10月23日 为每一篇文章添加了Copyright信息 2015年12月20日 删除了ACM时期文章的tags 2016年01月15日 为每一篇文章添加了微信公众号&amp;捐赠二维码 2016年06月13日 更新近期动态 2016年08月03日 修改了主题，增加了全文检索"},{"title":"Categories","date":"2016-08-03T04:19:54.422Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"categories/index.html","permalink":"https://xuanwo.org/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-03T04:19:54.474Z","updated":"2016-08-03T04:19:54.474Z","comments":true,"path":"tags/index.html","permalink":"https://xuanwo.org/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"NodeBB 升级迁移总结","slug":"nodebb-upgrade","date":"2016-07-08T10:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/07/08/nodebb-upgrade/","link":"","permalink":"https://xuanwo.org/2016/07/08/nodebb-upgrade/","excerpt":"前言青云用户社区使用了开源的 NodeBB 论坛，部署之初使用0.7版本，因为没有跟随官方进度进行更新，导致论坛版本长期停滞。一方面无法享受到官方的BUG Fix，另一方面也无法使用很多业务需求的插件。思量再三后决定对社区进行升级迁移，不在原论坛直接升级，而是部署一套新的环境，将原有的数据全部导出。","text":"前言青云用户社区使用了开源的 NodeBB 论坛，部署之初使用0.7版本，因为没有跟随官方进度进行更新，导致论坛版本长期停滞。一方面无法享受到官方的BUG Fix，另一方面也无法使用很多业务需求的插件。思量再三后决定对社区进行升级迁移，不在原论坛直接升级，而是部署一套新的环境，将原有的数据全部导出。 可行性分析NodeBB 升级路径NodeBB 自0.3版本后就提供了一套独特升级路径，主要有以下几个要点： NodeBB采用语义化版本号：x.y.z 对z版本号的变动，可以直接升级 只有当z版本号已经是x.y版本下的最新版本，才能升级到x.y+1 数据迁移NodeBB在部署的时候就使用了青云平台上的 Redis 缓存和负载均衡器。这样迁移的问题就会变的简单很多，我只需要将 NodeBB 路径下的public/uploads资源进行打包即可，Redis 缓存和负载均衡器都可以直接使用。 迁移步骤迁移 NodeBB建议在一个新的环境里面创建迁移环境。 Node 版本同样建议使用 nvm 来管理版本，避免其他应用对NodeBB环境产生干扰。 nvm install stablenvm use stable 如果不想每一次退出shell后都要执行nvm use stable，可以手动设置默认版本： nvm alias default stable NodeBB 版本首先下载跟生产环境一致的NodeBB版本： git clone -b v0.7.x 然后使用跟生产环境一致的config.json，NoedBB升级工具会自动更新package.json，所以无需修改。 然后运行./nodebb upgrade以升级数据结构和依赖并打上所有的补丁。 运行完毕后切换到更高版本的分支： git fetchgit checkout v0.8.x 同样运行./nodebb upgrade，以此类推，直至升级到官方最新版本。 迁移数据正如之前所说的，Redis已经被直接升级到最新版本，接下来只需要将用户上传的数据导出即可。 在生产环境中执行如下命令： cd /path/to/nodebb/publictar -cvf nodebb_assets_backup.tar.gz ./upload 切换到迁移环境后执行： cd /path/to/nodebb/publictar -xvf nodebb_assets_backup.tar.gz 注意事项 目前NodeBB不支持降级操作，如果担心破坏生产环境，可以在生成一个 Redis 的备份并重新创建资源，不要对原数据库进行操作。 由于 Redis 中会保存对原论坛的主题和插件等配置，在迁移到新版本后，有很大可能会产生错误，可以执行./nodebb reset -a以清除所有主题和插件配置。确认 NodeBB 运行正常后再逐个启用即可。 在升级时候会因为Node.js版本的问题导致某些依赖无法安装，建议可以使用0.12版本进行升级，升级成功后再切换到更新的版本上重新进行npm install --production 感悟NodeBB的升级路线设计这次升级迁移其实经历很久的论证过程。一开始简单地尝试一下之后认定无法直接进行升级就产生了一些畏难情绪，心里想着不如就让它这样，反正现在线上跑得也挺好的，没有出什么太大的问题。而后种种需求的提出让我有些招架不住了，现有的落后版本缺少很多API和现有的插件，自行开发和维护的成本非唱高。这也是我有一段时间觉得开源在实际应用中并不是那么美好的原因。等到我真的沉下心来仔细研究官方的文档，才发现 NodeBB 看似鬼畜坑爹的升级路线设计其实也有着其优雅之处。数据库的结构可以随之版本同步更新，这样可以避免早期数据库结构设计不合理带来的种种弊端，并防止产生版本之间的Breaking Change。抛开API层面的兼容性不谈，NodeBB可以做到我直接使用原来的 Redis 从 0.7.0 一路升级到 1.0.4，还能保证我的数据没有出现任何丢失，就冲着这一点，我觉得这个升级路线的设计是有价值的。当然，路线是好的，但是在具体实现升级功能的时候还有待商榷之处：不难发现升级过程中有很大一部分的重复操作，其实这些都是可以避免的。每一个x.y版本号之间的更新操作其实都是一致的，完全可以通过脚本实现。 应用部署的灵活性上线任何应用之前都应该考虑其架构的扩展性和迁移能力。很多时候，部署一套应用的目的根本就不是为了去使用他，只是单纯的部署一个玩一玩而已。在这样的心态下，总会干出这样的事情：在一个20G的主机上跑ownCloud；在一个主机上同时跑wordpress，nginx和mysql等应用。当然，这样做并没有什么问题，毕竟是自己的Server，哪怕天天 rm -rf /都是OK的。但是如果是一套需要给别人用的应用，部署时的扩展性和迁移能力就必须考虑在内。这其实是两个很实在的问题：服务器空间耗尽，性能跟不上怎么办？服务器挂了，如何保全自己的数据？自己设计这样一套系统很麻烦，但是如果是在青云上就不一样了。我最喜欢青云的一点就是，青云几乎所有的资源都是可以动态伸缩和扩展的。带宽受限制了，直接扩大；服务器性能不够了，加核心加内存；单个服务器支撑不住了，批量生成十个并使用负载均衡器进行负载均衡操作；想要测试某个最新的特性，直接从线上创建一个Snapshot并生成资源进行测试。在本次迁移的过程中，我们就可以看出来，我们可以直接使用 Redis 进行升级，而不是手动导出数据库备份再执行导入操作。同样地，我们也不需要再重新配置一遍 Nginx ，只需要再创建一个负载均衡器即可。 更新日志 2016年07月08日 首次发布 2016年07月15日 青云社区成功上线","categories":[{"name":"Operation","slug":"Operation","permalink":"https://xuanwo.org/categories/Operation/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuanwo.org/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://xuanwo.org/tags/Node-js/"}]},{"title":"新博客上线&Hexo主题开发入门","slug":"new-blog-new-life","date":"2016-06-29T23:06:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/06/29/new-blog-new-life/","link":"","permalink":"https://xuanwo.org/2016/06/29/new-blog-new-life/","excerpt":"前言曾经看过我的博客的同学大概都会发现，我的博客再一次大变样了~这一次的更新其实酝酿了很久，早在刚开始用Hexo的时候就想着要有一个自己的主题。但是那个时候觉得这是一件很难的事情，要懂HTML，CSS，JavaScript，还要懂Swig，Ejs等模板语言，还要懂Hexo的内部原理，于是就一直搁置了。在独立实现了一个完整的项目之后，我认为自己已经有这样的能力了，于是决定正式开始。在我看来的话，Hexo的使用者大概分为三个层次：第一种用别人的主题，第二种模仿现有的主题，第三种自己独立开发。我原来是第一种，在Next的基础上做了很多改动，这一次进入到了第二个层次。我找了一套自我感觉还不错的模板，然后套用它的CSS设定和页面结构，就成了我现在的主题。利用两天学习和工作的闲暇时间，我大体上完成了这个主题。做得比较糙，很多细节还有待优化，但是我已经急不可耐地想要正式上线了，笑。在未来的话，我希望能把一些配置都能整理出来，优化一下代码，然后开源这个主题，希望大家能够喜欢~庆祝的话已经说的差不多了，下面来讲一讲如何开发一个Hexo主题。","text":"前言曾经看过我的博客的同学大概都会发现，我的博客再一次大变样了~这一次的更新其实酝酿了很久，早在刚开始用Hexo的时候就想着要有一个自己的主题。但是那个时候觉得这是一件很难的事情，要懂HTML，CSS，JavaScript，还要懂Swig，Ejs等模板语言，还要懂Hexo的内部原理，于是就一直搁置了。在独立实现了一个完整的项目之后，我认为自己已经有这样的能力了，于是决定正式开始。在我看来的话，Hexo的使用者大概分为三个层次：第一种用别人的主题，第二种模仿现有的主题，第三种自己独立开发。我原来是第一种，在Next的基础上做了很多改动，这一次进入到了第二个层次。我找了一套自我感觉还不错的模板，然后套用它的CSS设定和页面结构，就成了我现在的主题。利用两天学习和工作的闲暇时间，我大体上完成了这个主题。做得比较糙，很多细节还有待优化，但是我已经急不可耐地想要正式上线了，笑。在未来的话，我希望能把一些配置都能整理出来，优化一下代码，然后开源这个主题，希望大家能够喜欢~庆祝的话已经说的差不多了，下面来讲一讲如何开发一个Hexo主题。 结构主题结构Hexo主题的结构大体如下： .├── _config.yml├── languages│ ├── default.yml│ └── zh-Hans.yml├── layout│ ├── achieve.swig│ ├── category.swig│ ├── index.swig│ ├── _layout.swig│ ├── page.swig│ ├── _partials│ ├── post.swig│ └── tag.swig└── source ├── css ├── fonts ├── img ├── js └── vendors 首先有一个_config.yml负责提供主题级别的配置，可以在layout中通过theme.xxx的形式进行调用。然后languages负责实现博客的i18N功能，如果博客没有多语言的需求，只需要实现一个default.yml即可。其次是最为重要的layout文件夹，这个里面主要存放博客的结构，Hexo 引擎会使用指定的渲染引擎将layout文件渲染成HTML页面。最后是source，把所有主题需要用到的资源，比如CSS，Fonts，JS等都存放到这个文件夹中。 这个主题使用了swig。 页面结构页面结构分为两个维度，一者是我要呈现哪些页面，二者是每个页面上都有哪些内容。 哪些页面？作为一个博客，主要需要的页面有以下这些： 主页 单页 归档页面 分类页面 标签页面 文章页 哪些内容？如果没有什么特别的设计，博客的页面大体上可以分为这几个部分： head：头部文件 body：主体内容 header：题图，导航栏等 content： 内容 footer：尾部的联系方式等 实现前面讲到了 Hexo 的结构，下面来聊一聊具体的实现。 原理Hexo 渲染的入口是_layout.swig，所以一个主题至少需要实现一个_layout.swig。然后Hexo会遍历Hexo目录下source文件夹中的所有Markdown文件，根据Markdown文件所指定的layout进行渲染，默认类型为post。 技巧_layout.swig结构整体的结构基本如下： &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &#123;% include &apos;_partials/head.swig&apos; %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;&lt;body id=&quot;home&quot;&gt; &#123;% include &apos;_partials/menu.swig&apos; %&#125; &lt;div id=&quot;wrap&quot;&gt; &#123;% include &apos;_partials/nav.swig&apos; %&#125; &#123;% include &apos;_partials/header.swig&apos; %&#125; &lt;div id=&quot;start&quot; class=&quot;container content&quot;&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &lt;/div&gt; &#123;% include &apos;_partials/footer.swig&apos; %&#125; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现文章渲染这个地方主要是借鉴了NexT主题的设计，实现了一个swig的宏来生成对应的文章。这个宏主要有两个参数，第一个是post对象，第二个是是否为主页。如果是主页就只显示简略的内容，如果不是就输出全文。 判断的部分实现如下： &#123;% if is_index %&#125; &#123;% if post.excerpt %&#125; &#123;&#123; post.excerpt &#125;&#125; &lt;a class=&quot;&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;Read more&lt;/a&gt; &#123;% endif %&#125;&#123;% else %&#125; &#123;&#123; post.content &#125;&#125;&#123;% endif %&#125; 用到的post页的参数可以我翻译的中文文档 分页插件Hexo 自己实现了一个分页插件，直接使用paginator函数即可。 &#123;% if page.prev or page.next %&#125; &lt;nav class=&quot;pagination&quot;&gt; &#123;&#123; paginator(&#123; prev_text: &apos;&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;&apos;, next_text: &apos;&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;/i&gt;&apos;, mid_size: 1 &#125;) &#125;&#125; &lt;/nav&gt;&#123;% endif %&#125; 评论系统对于Hexo来说，评论系统就是调用一个第三方的JS。所以只需要在合适的位置插入代码即可。 &lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;&lt;script&gt; var disqus_config = function () &#123; this.page.url = &apos;&#123;&#123; page.permalink &#125;&#125;&apos;; this.page.identifier = &apos;&#123;&#123; page.path &#125;&#125;&apos;; &#125;; (function () &#123; var d = document, s = d.createElement(&apos;script&apos;); s.src = &apos;//abc.disqus.com/embed.js&apos;; s.setAttribute(&apos;data-timestamp&apos;, +new Date()); (d.head || d.body).appendChild(s); &#125;)();&lt;/script&gt; 需要注意的坑 page.posts是按照时间排序的，但是site.posts是无序的。 参考资料 Hexo 官方中文文档 更新日志 2016年06月30日 首次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://xuanwo.org/tags/Nodejs/"},{"name":"HTML","slug":"HTML","permalink":"https://xuanwo.org/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuanwo.org/tags/JavaScript/"}]},{"title":"马可波罗珠宝进销存系统开发手记","slug":"jade_ims","date":"2016-06-16T22:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/06/16/jade_ims/","link":"","permalink":"https://xuanwo.org/2016/06/16/jade_ims/","excerpt":"前言这个项目从我们这个学期开了系统分析与设计这门课之后就开始了，首次创建这个项目是在3月26号，实际上真正的开发时间集中在6月上旬。差不多用两个星期的闲暇时间时间完成了这个简单的进销存系统。这个系统基于Flask框架，使用SQLite3数据库，前端则是使用Bootstrap框架，实现了包括客户，库存，销售，进货等管理子系统。说是管理，其实也就是简单的增加和删除而已。前人经常说，不要重复造轮子。既然有类似于Odoo这样强大的ERP系统珠玉在前，我为什么要再自己造一个功能简单，甚至根本不会有人用的轮子呢？从前我确实是这么想的，但是稍微有一点工作经验之后发现再造轮子的原因有两条： 作为一个处在知识积累阶段的学生而言，再造轮子很有必要。不造一次轮子，你就永远不会明白轮子内部的真实构造。很多技术虽然看起来简单，但是想要有一个完善且健壮的实现却有很多坑需要踩。踩这些坑的过程，也正是一个技术人员成长最快的过程。 别人的轮子终究是别人的。你不知道这个轮子最大能承受多少压力，你也不知道这个轮子在什么样的情况下会爆胎。当一个轮子装上企业呼呼向前的列车，再要想把它替换下来是一件很难且成本很高的事情。 接下来，讲讲造这个轮子的一些经历吧~","text":"前言这个项目从我们这个学期开了系统分析与设计这门课之后就开始了，首次创建这个项目是在3月26号，实际上真正的开发时间集中在6月上旬。差不多用两个星期的闲暇时间时间完成了这个简单的进销存系统。这个系统基于Flask框架，使用SQLite3数据库，前端则是使用Bootstrap框架，实现了包括客户，库存，销售，进货等管理子系统。说是管理，其实也就是简单的增加和删除而已。前人经常说，不要重复造轮子。既然有类似于Odoo这样强大的ERP系统珠玉在前，我为什么要再自己造一个功能简单，甚至根本不会有人用的轮子呢？从前我确实是这么想的，但是稍微有一点工作经验之后发现再造轮子的原因有两条： 作为一个处在知识积累阶段的学生而言，再造轮子很有必要。不造一次轮子，你就永远不会明白轮子内部的真实构造。很多技术虽然看起来简单，但是想要有一个完善且健壮的实现却有很多坑需要踩。踩这些坑的过程，也正是一个技术人员成长最快的过程。 别人的轮子终究是别人的。你不知道这个轮子最大能承受多少压力，你也不知道这个轮子在什么样的情况下会爆胎。当一个轮子装上企业呼呼向前的列车，再要想把它替换下来是一件很难且成本很高的事情。 接下来，讲讲造这个轮子的一些经历吧~ 项目启动正如前言中说的，这个项目是系统分析与设计这门课的课程设计，也是贯穿着整个学期的一个主旋律。早在这学期开学之初，我们就知道了自己需要做这样的一个系统。经历了上个学期各种技术炫了半天，最后却只是抄袭各种开源项目草草实现的失败，这个学期我务实了很多。从最开始的讨论就一直跟组员强调技术的可行性，基本上否决了所有试图增大项目复杂度的建议，把主题定在了一个纯粹的进销存管理系统。之所以如此，是因为我的观念发生了很大的变化：原来觉得技术的先进是最重要的，开发项目一定要用最现代的技术，最炫目的特效；现在觉得哪怕是一个用VB写出来的能稳定运行的丑陋系统都要胜过采用了种种最新潮技术却漏洞百出根本没法运行的“先进”系统。在讨论到最极端的时候，我甚至想只做一个仓库的管理系统，只包括进库和出库这样的简单功能。这样的态度曾经闹得有一次讨论直接不欢而散，好在组员都是非常Nice的人，在我主动表达歉意之后大度地表示没什么。经过多次讨论之后，我们终于达成了共识，要做一个进销存系统，功能尽可能简单，在实现基础功能的前提下，再考虑加入新的功能。接下来的事情就没有什么大的分歧了，整体系统采用B/S架构，开发语言选用我个人比较喜欢的Python，使用Flask框架，数据库选用无需配置的SQLite。然后服务器选择阿里云的学生机，系统选择成熟稳定的CentOS 7.2，Web Server选用Nginx，也就是我个人目前比较喜欢的开发平台——LESP(Linux, Nginx, SQLite, Python)。 项目细节下面再介绍一下项目的细节。 设计模式项目大体上采用了MVC的思想，不过在具体的实现上并没有太过纠结于概念上的东西。所有的网页模板都在templates文件夹下，静态资源都扔到了static目录，使用一个models.py模块来单独存放所有的数据库定义，然后所有的路由以及操作都在views中实现。对于我来说，快速地实现需求才是头等大事，是不是符合正统的MVC理念并不是十分重要。实际上现在这样的结构开发起来感觉也蛮顺手的，需要调整前端的样式和表单就在templates文件夹下操作，需要修改程序的逻辑就去views，他们基本上是一一对应的关系。这里有更加清晰的讲解，值得一看。 项目中的问题&amp;解决方案在Flask框架中同时使用蓝图与Flask_SQLAlchemyhttps://segmentfault.com/q/1010000005640527 感谢@Ethan和@，他们强有力地向我证明了有师傅带路的好处。 这个问题纯粹是因为一直以来都是一个脚本Boy，没有系统性的学习过软件开发导致的。很显然，按照我原来的代码去产生实例，就会导致循环导入的错误。想要解决这样的问题，就需要使用工厂函数去生成实例，而不是自己去生成它。 在__init__.py中添加一个create_app()函数，在函数中进行参数配置，初始化和导入蓝图的操作： bps = ['jade_ims.views.dashboard:dashboard', 'jade_ims.views.install:install', 'jade_ims.views.login:login', 'jade_ims.views.sale:sale', 'jade_ims.views.customer:customer', 'jade_ims.views.purchase.inputbill:inputbill', 'jade_ims.views.purchase.supplier:supplier', 'jade_ims.views.stock.enterstockbill:enterstockbill', 'jade_ims.views.stock.leavestockbill:leavestockbill', 'jade_ims.views.stock.stock:stock' ]def create_app(): app = Flask(__name__) app.config.from_object('config') app.config.from_pyfile('config.py') db.init_app(app) for path in bps: bp = import_string(path) app.register_blueprint(bp) return app Flask如何优雅地重定向所有未登录用户到登陆界面https://segmentfault.com/q/1010000005645821 感谢@zwillon和@igaozp 有一个Feature是想要把所有未登录的用户都重定向到登录页面。当时手头上的技术方案主要有两种：第一种是自己包装一个装饰器，并添加在每一个视图函数中；第二种是使用第三方库Flask-Login，在视图函数中添加@login_required。但是感觉姿势都不怎么优雅，因为我需要不断地在视图函数中添加这个装饰器，不太符合DRY(Don’t Repeat Yourself)准则。SF的老司机给了我一个相当优雅的方案——Hook到app的before_request方法。也就是这样来实现： @app.before_requestdef check_need_login(): # 检查登录的逻辑 pass 我第一次是这样实现的： @app.before_requestdef check_need_login(): if 'logged_in' not in session: return redirect(url_for('login.user_login')) 这样就带来了一个问题，对于未登录的用户来说，所有页面都会不断地重定向从而导致整个应用崩溃。因此还需要指定在某些情况下停止重定向，所以我们还需要修改一下check_need_login的逻辑： @app.before_requestdef check_need_login(): if 'logged_in' not in session and request.endpoint not in ('login.user_login', 'static'): return redirect(url_for('login.user_login')) 当session中没有logged_in字段且endpoint不是user_login和static的时候就重定向到登录页面，这样就比较优雅地解决了重定向未登录用户到登陆界面的需求。 flask_sqlalchemy 插入数据时发生错误后如何处理https://segmentfault.com/q/1010000005647431 在实际开发的过程中发现，如果db.session中添加的记录有问题，在commit的时候会出现一个报错。所以我们需要在出错的时候进行一些处理，以保证程序出错之后还能够正常地运行。网友 @学不会编程的永仲 给出的回答是我应该在form中验证数据的正确性。虽然我相信他的理解可能是正确的，但是不太符合我的哲学，我更加倾向于让它崩溃，然后处理异常而不是事先处理好所有的错误。通过查阅文档，了解到db.session.rollback()这一函数可以在出错是进行回滚，于是最后的实现变成了这样： @supplier.route('/purchase/supplier/add', methods=['POST'])def add_supplier(): form = request.form if request.method == 'POST': print(form) supplier = Supplier(form['supplier_name'], form['supplier_constract'], form['supplier_phone'], form['supplier_address'], form['supplier_remark']) try: db.session.add(supplier) db.session.commit() flash('供应商添加成功！', 'success') except: db.session.rollback() flash('输入不合法，请重新输入！', 'danger') return redirect(url_for('supplier.list_supplier')) 项目总结随着答辩的完成，这个项目进入了尾声。因为很多东西需要去学习，有新的东西需要去探索，所以这个项目也很有可能不会再继续维护了。那么这个项目开源出来的价值在哪里呢？我想，这个项目虽然简单，但它毕竟还算是一个完整的Flask项目，除了flask_sqlalchemy之外没有多余的依赖，非常适合一个跟我一样的Python初学者进行入门学习。如果说有人能够因为这个项目少走一些弯路，少在一些死胡同浪费时间，我想这个项目的价值就已经实现了。如果再往大一点来说，开源的价值也就实现了。如果要我自评的话，我觉得这样的项目应该有60分。之所以给一个及格分，是因为这个项目毕竟实现了需求的大多数功能，也有好好地跑在阿里云的服务器上。丢分的话，大体上是因为这个项目毫无注释，没有安装文档，也没有配置手册，很多东西都是硬编码到了代码中。不仅如此，编程的风格也是相当的不佳，在模板部分缺乏良好的顶层设计，出现了大量的重复代码。这些问题希望自己能在下一个项目中得到一些改善。Anyway，随着这个项目的结束，我的大三生涯也要结束了。接下来是波澜壮阔的实习阶段，希望自己能够在实习的时候多踩一些坑，多走一些弯路，多得到一些来自“长者”的指点。 参考资源 Flask 中文文档 文档略有过时，代码以Github上为准 Flask 之旅 Flask-SQLALchemy 中文文档 更新日志 2016年06月17日 首次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Information","slug":"Information","permalink":"https://xuanwo.org/tags/Information/"},{"name":"项目","slug":"项目","permalink":"https://xuanwo.org/tags/项目/"},{"name":"Python","slug":"Python","permalink":"https://xuanwo.org/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"https://xuanwo.org/tags/Flask/"},{"name":"HTML","slug":"HTML","permalink":"https://xuanwo.org/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuanwo.org/tags/JavaScript/"}]},{"title":"在QingCloud上部署弹性扩容的OwnCloud","slug":"owncloud-on-qingcloud","date":"2016-06-03T08:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/06/03/owncloud-on-qingcloud/","link":"","permalink":"https://xuanwo.org/2016/06/03/owncloud-on-qingcloud/","excerpt":"前言因为实在不满意百度云的一些缺陷，我们最终决定部署一套团队内部使用的云存储平台，用于团队协作及资料长期存储。希望能够达到如下目标： 数据安全性高 权限控制能力强 分享功能更强，可以设置密码和过期时间等 允许匿名第三方上传数据 没有文件上传大小限制 支持多平台同步功能 综合考量各开源项目之后，我最终选定基于QingCloud部署一套开源存储项目OwnCloud。","text":"前言因为实在不满意百度云的一些缺陷，我们最终决定部署一套团队内部使用的云存储平台，用于团队协作及资料长期存储。希望能够达到如下目标： 数据安全性高 权限控制能力强 分享功能更强，可以设置密码和过期时间等 允许匿名第三方上传数据 没有文件上传大小限制 支持多平台同步功能 综合考量各开源项目之后，我最终选定基于QingCloud部署一套开源存储项目OwnCloud。 部署在部署之前，我们首先要考虑这套系统大概会有多少人用，会使用多大的空间，需要多少带宽，服务器的配置等问题。我们现在有几个TB的数据，10人使用，未来人数无法预估，各资源使用量也无法预估。但是非常有意思的事情是，在青云QingCloud平台上，一切都是可以动态扩容的，所以我完全可以以最少的资源验证服务是否符合需求，然后再增加服务所使用的资源。 整个部署过程概括为如下4步： 验证功能及预估花费 在QingCloud上创建主机、网络等资源并修改配置 安装OwnCloud环境 使用LVM管理分区，实现空间动态扩容 在网页端安装OwnCloud 资源编排在实际生成需要的资源之前，我先通过青云QingCloud的提供的资源编排功能看看青云是否能够满足我们的需求以及搭建这一套服务需要多少钱： 如图所示，我们在一个私有网络中创建一台主机和一个数据库，并为整个VPC网络分配了一个公网IP和防火墙。 如图，整套资源预计需要每小时0.56元。 创建并修改配置生成模板之后，点击创建。等待大概一分钟之后，所有资源全部创建完毕。在SSH连接上服务器开始实际的配置工作之前，需要先修改VPC的设置。 添加端口转发规则我需要将来自公网的流量转发到我的主机上，主要有两条，一个是SSH，一个是HTTP。 主机的内网地址是192.168.0.2，所以需要把所有来自22和80的端口都转发到这个地址。 添加防火墙规则出于安全性考虑，青云的防火墙默认只开放了22和ICMP。为了可以正常访问到主机，还需要添加80端口的例外规则： 我们看到青云在右边提供了常用端口的配置，选择http即可。 安装OwnCloudOwnCloud为CentOS平台提供了二进制的包，没有特殊需求的话，直接使用即可。首先添加OwnCloud官方的Key文件： rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key 然后添加OwnCloud的repo： wget http://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -O /etc/yum.repos.d/ce:stable.repo 更新repo之后开始安装： yum clean expire-cacheyum install owncloud yum将会自动处理依赖，如果速度不佳的话，可以直接将包下载到本地：直接下载 启用httpd，并测试是否安装正确OwnCloud默认使用Apache作为Web服务器，上一步已经安装了Apache，接下来需要启用它： systemctl start httpd 如需要开机自行启动，可以输入： systemctl enable httpd 然后在浏览器中访问：http://&lt;your ip&gt;/owncloud，如果出现OwnCloud的安装界面，说明已经配置成功了。 使用LVM管理分区，实现空间动态扩容OwnCloud在安装的时候只能选择一个目录，为了能够实现空间的动态扩容，需要使用LVM创建一个逻辑分区并挂载到指定的数据目录下。 首先在青云QingCloud的控制台中创建一块硬盘，然后挂载到主机中。之后，就能够通过/dev/sdb等形式来访问这块硬盘。 需要注意的是，主机在每次重启的时候硬盘的顺序可能会发生改变，所以如果需要自动挂载的话，需要使用UUID或者LABLE的方式来指定硬盘，不能使用设备名。 接下来需要在CentOS下使用LVM来配置分区，实现分区的动态扩容。 安装LVM工具青云QingCloud提供的CentOS 7.2默认映像是没有LVM工具的，所以首先需要安装它： yum install lvm2 创建物理卷（PV）首先检测能够被作为物理卷的设备： lvmdiskscan 然后在指定设备上创建物理卷，所有需要用到的设备都需要执行如下命令： pvcreate /dev/sdb 然后查看已经创建好的物理卷： pvdisplay 输出大概如下： --- Physical volume --- PV Name /dev/sdb PV Size 1000.00 GiB / not usable 4.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 255999 Free PE 255999 Allocated PE 0 PV UUID EHIeTJ-WBPv-rQkQ-LnuI-0IWE-SM4z-bMPAWx 创建卷组（VG）物理卷创建完毕后，需要创建一个卷组来实现物理卷的统一管理： vgcreate owncloud-vg /dev/sdb /dev/sdc /dev/sdd 后续如果需要扩展的话，可以使用如下命令： vgextend owncloud-vg /dev/sde 同样地，使用vgdisplay来查看创建好的卷组： --- Volume group --- VG Name owncloud-vg Format lvm2 Metadata Areas 1 Metadata Sequence No 2 VG Access read/write VG Status resizable MAX LV 0 Cur LV 1 Open LV 1 Max PV 0 Cur PV 1 Act PV 1 VG Size 1000.00 GiB PE Size 4.00 MiB Total PE 255999 Alloc PE / Size 230400 / 900.00 GiB Free PE / Size 25599 / 100.00 GiB VG UUID xCCtSR-QFcZ-StcI-HM7O-KDAz-PvMC-EgYcSV 创建逻辑卷（LV）然后就可以开始创建逻辑卷了： lvcreate -L 900G owncloud-vg -n owncloud-data 创建完毕后，就可以通过/dev/mapper/owncloud--vg-owncloud--data或者/dev/owncloud-vg/owncloud-data来访问这个设备了。 如果需要扩大逻辑卷，可以使用： lvextend -L 1000G /dev/owncloud-vg/owncloud-data 确认扩展成功后，再更新文件系统： resize2fs /dev/owncloud-vg/owncloud-data 创建文件系统并挂载在逻辑卷上创建一个ext4分区： mkfs.ext4 /dev/mapper/owncloud--vg-owncloud--data 然后将分区挂载到期望的目录下，比如/data mount /dev/mapper/owncloud--vg-owncloud--data /data 修改文件夹权限为了OwnCloud能够正确读写数据分区，需要修改/data的所有者和权限： chown -R apache:apache /datachmod 775 /data -R 网页安装OwnCloud全部配置完毕后，可以开始在网页进行OwnCloud安装了。 管理员帐号： 自定义管理员密码： 自定义数据路径：/data数据库用户：root数据库密码：&lt;your password&gt;数据库名称自定义，比如：owncloud数据库地址：&lt;your rdb ip&gt; 在创建RDB时，系统会自动用相同的密码创建Root用户。OwnCloud在安装时需要创建一个新的账户来进行管理，而青云提供的默认用户没有这样的权限。因此需要使用Root用户而不是创建时指定的用户。 提示创建完毕后，就可以使用管理员用户登陆了。 维护自动备份一个存储类的应用，必须要有自动备份的功能，保证用户在最坏的情况下都能找回他们的数据，对于存储着工作资料的私有云存储而言更是如此。所以，需要对主机，硬盘和数据库进行定时备份。 主机和硬盘青云QingCloud 提供了一个叫定时器的功能，可以设置在每天的三点重复执行备份任务。 首先创建一个定时器，每天3：00重复执行： 然后在该定时器中添加对应的定时器任务： 选中需要备份的主机和硬盘即可。 数据库青云QingCloud 上的数据库自带自动备份功能，只需要开启它。 在需要备份的数据库上右击，选择修改自动备份策略： 青云QingCloud 首次备份是全量备份，之后是增量备份。当变化较大时，会自动创建新的备份链。 自动伸缩云存储服务的一个最显著的特点是有明显的高峰期，如果能够实现高峰期时自动增加带宽，低峰期时自动降低带宽就能够节省昂贵的带宽费用的目的。青云QingCloud提供的自动伸缩就能有效地满足这一痛点。 首先创建一个自动伸缩策略： 操作类型为调整公网IP带宽上限，然后选择需要自动伸缩的资源。 然后添加带宽提高和降低的触发条件： 以带宽提高为例，我们可以在公网进流量连续15分钟平均值大于当前带宽的80%时提高带宽。 青云QingCloud的监控周期为5分钟，而数据采样周期为1分钟。 最后添加操作参数： 可以设置每次提高5Mbps，最高允许的带宽为20Mbps。 应用下面来聊一聊OwnCloud的一些应用。 分享功能 分享功能是我比较看重的一个部分。OwnCloud的分享可以选择用户和组，然后还能通过链接进行分享。通过链接分享时，可以指定密码和过期时间，还能允许编辑。这样就可以实现给用户发送需要的资料以及收集来自合作伙伴的视频，文件等功能。 团队协作OwnCloud内建了一个版本管理功能，同一个文件可以提供多个历史版本，这样方便大家进行版本追溯和管理，为团队协作编辑提供了便利。除此以外还有评论系统，实时性能还不错，基本可以用于对具体文档的简单协作。 更新日志 2016年06月03日 首次发布 2016年06月11日 增加自动备份和自动伸缩的配置","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"QingCloud","slug":"QingCloud","permalink":"https://xuanwo.org/tags/QingCloud/"},{"name":"Work","slug":"Work","permalink":"https://xuanwo.org/tags/Work/"}]},{"title":"我从Qingchat中学到的教训","slug":"learn-from-qingchat","date":"2016-05-29T20:57:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/05/29/learn-from-qingchat/","link":"","permalink":"https://xuanwo.org/2016/05/29/learn-from-qingchat/","excerpt":"前言之前的一段时间一直在从事Qingchat的相关开发工作，这个项目是一个基于Mojo-Weixin提供的Rest API开发的一个微信机器人，承担了十余个群，上千人的微信直播活动。秉承着ACM训练出来的“暴力加乱搞”风格，我花了大概一个星期的课余时间，搞出了一个可用的版本。期间也迭代了很多次，既欣慰于Coding的力量，也苦恼于当初设计的不完善带来的种种问题。在这个项目即将大规模重构的前夕，我总结一下开发Qingchat的过程中的经验教训，希望自己能成为一个更好更聪明的Coder。","text":"前言之前的一段时间一直在从事Qingchat的相关开发工作，这个项目是一个基于Mojo-Weixin提供的Rest API开发的一个微信机器人，承担了十余个群，上千人的微信直播活动。秉承着ACM训练出来的“暴力加乱搞”风格，我花了大概一个星期的课余时间，搞出了一个可用的版本。期间也迭代了很多次，既欣慰于Coding的力量，也苦恼于当初设计的不完善带来的种种问题。在这个项目即将大规模重构的前夕，我总结一下开发Qingchat的过程中的经验教训，希望自己能成为一个更好更聪明的Coder。 经验教训没有稳定性的世界从最开始Coding的时候，就有着一个根深蒂固的信念：计算机不会出错。1是1，0是0，只要自己的实现是对的，那最后的结果也一定是对的。然后，真相并非如此：我们存在于一个没有稳定性的世界。你访问的路径可能是不存在的，你访问的文件可能是不存在或者已经上锁，你期望的服务器响应因为网络环境太差变成了超时。不仅如此，有时候你还会遇到神出鬼没的黑客们，稍有不慎你可能就永远失去了对数据的掌控权（我测试用的服务器被人暴力尝试登陆34万次）。所以我们在编程的时候就应当完全抛弃“这个服务是稳定的”这种前提，学会在万物皆有可能出错的假设下编程，不要轻视程序的鲁棒性。你永远都不会知道用户会以何种方式使用你的程序，同样的，你也不会知道用户到底会输入什么样的数据。灵活运用“防御式编程”和“让它出错”两种思想，让你的代码更健壮。 拥抱多线程，走向非阻塞现在回过头来看，自己当初实现的群发功能就是一个彻头彻尾的失败品：容错性差，效率低下。这些问题其实是由同一个原因导致的：我使用了一个单线程阻塞式的实现，不仅如此，还没有做任何异常的处理。这样导致的结果就是只要某个环节出错，整个群发任务就会直接退出。速度是跟微信群的数量成正比的，群的数量上升之后，群发速度过慢成了我的同事们经常向我吐嘈的问题。开发的时候不计算网络传输延时绝对是一个重大失误——实际上，网络延时是整个系统的关键瓶颈。为了解决这个问题，Node.js 采用了一种单线程非阻塞的设计（一家之言，轻喷）。对于Python来说也是一样的，适度地拥抱多线程开发以提高并行效率，多采用非阻塞式设计以避免单个任务执行时间过长拖慢运行速度。在一次去上课的路上，我形象地把这种设计比作“射后不管”，好像是飞毛腿导弹？ 开源非万能我原来是一个开源的死忠粉，认为开源可以解决一切问题，那个时候每天思考的问题就是为什么Windows不开源？等到真的进入业界，才明白自己的这种想法有多么幼稚。除去那些大型的有基金会在背后支撑的项目，绝大多数项目完全依靠开发者个人热情来维持，某些涉及到商业支持的项目更是存在着“人走项目死”的现象。比如我参与管理的Hexo项目在作者tommy开始实习之后就进展缓慢，再比如我接手但是现状非常差的staticfile（很抱歉我并没有能够做出什么正面的贡献，反而让状况变得更加糟糕了）。这些实践都告诉我，开源并不是万能的，真正想要解决一个问题，需要一个完善的制度以及各方面的激励机制。单纯依赖于开发者个人的热情往往不利于一个项目的长远发展，而在自行开发的项目中依赖于一个开源项目往往会带来更多的风险。开发者不一定会开发你期望的功能，开发者也不一定会按照你期望的进度进行开发。作为我个人，我依然是一个热爱开源项目，崇尚开源理念的人；然而作为一个产品的开发者，一个服务的提供者，你必须权衡自行开发，采购商业产品以及使用开源项目之间的利弊。不同的选择取决于不同的项目，不同的需求，不同的自主开发能力，不同的后续维护能力。一味的强调开源理念，不顾实际，往往对开源事业的发展有害无益，挫伤人们对开源的信赖。 未来展望一个项目最具活力与激情的时刻就是在设计之初实现之前，等到实现的时候往往寸步难行，到了后续维护的时候时常想就此了断。我希望这个项目能够存活更长的时间，希望自己向同事们提出的构想都能够一一变为现实。本次重构希望能够实现一个更加稳定更加高效的Qingchat，希望能够进一步减少重复劳动，提高效率。最后感谢同事们的不杀之恩，感谢青云QingCloud的自由空间，可以允许我以自己想要的方式完成工作。最后以青云CTO Reno在某次会上说的话自勉：“你们是青云的Devloper，No excuse。” 更新日志 2016年05月30日 初稿","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuanwo.org/tags/python/"},{"name":"qingchat","slug":"qingchat","permalink":"https://xuanwo.org/tags/qingchat/"},{"name":"实习","slug":"实习","permalink":"https://xuanwo.org/tags/实习/"},{"name":"QingCloud","slug":"QingCloud","permalink":"https://xuanwo.org/tags/QingCloud/"}]},{"title":"基于MSP430G2553的打铃系统开发手记","slug":"msp430g2553-bellring","date":"2016-05-09T08:42:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/05/09/msp430g2553-bellring/","link":"","permalink":"https://xuanwo.org/2016/05/09/msp430g2553-bellring/","excerpt":"前言我萌萌哒的妹纸是一个代码苦手，完全无法理解 C 语言，所以每一次到单片机上机需要交作业的时候都是愁眉苦脸的样子。而我又总是因为自己确实不懂单片机里面的种种奇怪定义（中断，串口，P1.x 之类），所以也一直没有什么好办法去帮她。这一次的作业对编码能力要求较高，但是涉及到的硬件比较少，于是决定以此为契机，开始我的嵌入式开发之旅。","text":"前言我萌萌哒的妹纸是一个代码苦手，完全无法理解 C 语言，所以每一次到单片机上机需要交作业的时候都是愁眉苦脸的样子。而我又总是因为自己确实不懂单片机里面的种种奇怪定义（中断，串口，P1.x 之类），所以也一直没有什么好办法去帮她。这一次的作业对编码能力要求较高，但是涉及到的硬件比较少，于是决定以此为契机，开始我的嵌入式开发之旅。 需求这次的如下： 基本要求 基本计时和显示功能(用 12 小时制显示)。包括上下午标志,时、分的数字显示,秒信号指示。 能设置当前时间(含上、下午,时,分) 能实现基本打铃功能,规定:上午 6:00 起床铃;打铃 5 秒、停 2 秒、再打铃 5 秒。下午 10:30 熄灯铃;打铃 5 秒、停 2 秒、再打铃 5 秒。 铃声可用 LED 灯光显示,如果实验装置没有 LED 发光管,可以用七段显示管的小数点显示,也可以用显示小时的十位数码管的多余段显示。凡是用到铃声功能的均可如此处理。 发挥部分 增加整点报时功能,整点时响铃 5 秒,要求有控制启动和关闭功能。 增加调整起床铃、熄灯铃时间的功能。 增加调整打铃时间长短和间歇时间长短的功能。 增设上午 4 节课的上、下课打铃功能,规定:7:30 上课,8:20 下课;8:30 上课,9:20 下课;9:40 上课,10:30 下课;10:40 上课,11:30 下课;每次铃声 5 秒。 利用板上按键做一个 12 小时/24 小时的显示格式切换 分析 既然我都出动了，肯定不能满足于只完成基本要求，决定把所有功能全都完整的实现。 简单的来说，整体需求可以分为三个部分：显示，打铃，修改。 需要用到的东西有：串口，指示灯和一个按键。 显示遵循简单的前后端分离的思想，我们可以使用三个全局变量 hour ， minute ， second 来存储当前的时间，只需要在显示的时候区分上下午和 12 小时／ 24 小时即可。这两个部分解耦之后会发现，我们后面的利用板上按键修改显示格式也变得容易了很多。通过串口显示也就是需要向指定变量发送字符，将这个功能抽象并封装之后，对于我后续的编程来说，也就是调用一下 Send_Str(str) 的过程。 打铃打铃是这套系统的重头戏，因为学校方面的资源限制，所以使用指示灯示意的方法来代替打铃。指示灯的亮灭是通过控制一个变量的值来确定的，于是我只要在正确时候设置正确的值，打铃系统就能按照我期望的方式工作。 修改修改同样是通过串口进行的。 在最开始的设计文档中，本来是要求使用4个按键来进行设计，也就是说跟一个普通的电子表差不多。但是非常因缺思艇的事情是学校的按键不够了，所以老师要求所有功能都用串口实现。 跟显示有些不同的地方是，通过串口向芯片发送数据需要正确使用串口中断。 综上，这个系统所需要的全部内容就已经实现了。可以看到我做了很多将对硬件的操作抽象化的处理，其实这一点非常重要。因为对于我来说，嵌入式开发最大的难题在于，我不知道里面种种变量的含义，不知道如何操作具体的硬件。将硬件操作抽象化处理之后，我就可以很方便地开展我的后续开发。 问题实现就不再赘述了，想必读者一定都比我强，下面聊一聊遇到的问题以及 debug 的经历。 串口配置串口的收和发其实是分开的，这里用到了两个变量： UCA0TXBUF ， UCA0RXBUF 。从字面意思上可以看出，前一个用于发送，后一个用于接收（相对于开发者来说）。发送和接收其实就是给这两个值赋值的过程，看起来这两个变量在接受到值之后会将这个值传给别的变量，所以只要不断的将值赋给它就行，我们写了这样的函数： #pragma vector=USCIAB0RX_VECTOR //中断服务函数__interrupt void uart() &#123; rec = UCA0RXBUF; //读取到缓冲区 strtmp[strlen++] = rec; strtmp[strlen] = '\\0'; //切换模式 mode = strtmp[0];&#125;//发送字符void Send_Char(char ch) &#123; while (!(IFG2 &amp; UCA0TXIFG)); UCA0TXBUF = ch;&#125;//发送字符串void Send_Str(char *p) &#123; unsigned char i; i = 0; while (*(p + i) != '\\0') &#123; while (!(IFG2 &amp; UCA0TXIFG)); UCA0TXBUF = *(p + i); i++; &#125; Send_Char(0x0d); Send_Char(0x0a);&#125; uart 貌似是一个内置的中断函数，用来处理串口的接收，只要将变量 UCA0RXBUF 的值存储起来即可；后面的 Send_Str 就非常好理解了，将值发送给 UCA0TXBUF ，从而实现串口的输出。 思路如此清晰，但是测试的时候却遇到了问题，我们的输出是空的，转为16进制显示后，全都是0x00。这个问题调试了很久，拿着原来的代码逐行比对之后发现，出了这样的问题： - UCA0BR0 = 130;- UCA0BR1 = 6;+ UCA0BR0 = 104;+ UCA0BR1 = 0; Google 一下才明白，原来 UCA0BR0 和 UCA0BR1 是由系统的时钟速度和波特率决定的值，如果设置错误就会导致串口发送失败。具体的值可以参考用户手册， Ctrl＋F 搜索 Table 15-4. Commonly Used Baud Rates 即可。 串口输出异常前面提到我们直接使用三个变量保存当前时间，在输出时做进一步处理，转为字符串的过程中，我们进行了这样的操作： Time[0] = hour / 10 + '0'; 但有趣的事情是，在初始化之后，我们得到的输出是这样的： 0/:0/:0/ 。随手输出了一下 / 的 ASCII 码，发现它刚好比 0 小一。 难道说，存储器中的默认值不是 0 吗？ Google 一下之后发现，还真的不是 0 。 MSP430G2553 中的 Flash 存储器在默认状态下的值全为 1 ，然后写入时只能将 1 置为 0 ，所以每一次写入数据都需要先清空再写入。那么问题来了，为什么全为 1 会导致最后输出的结果小 1 呢？我来简单的阐述一下我的理解： 假设这个存储器只有 8 位，也就是说，现在的值为 11111111 ，然后我加上一个 1 ，于是我们得到： 11111111+ 1 100000000 显然，我们最后的结果已经移除了，此时会产生截断，也就是说，存储器现在的数据变成了 00000000 ，也就是 0，跟我们期望的结果 1 刚好相差一。 当然，实际的情况要比我上面的举例要复杂的多，不过我想已经足够我们认识到这个 BUG 的本质，就不再多说啦。 Flash 存储器未清空在测试中，我们发现每一次烧录程序之后， Flash 存储器不会清空，依然会从上一次我们保存的时间开始计时。我觉得这是正确的行为，没有在意，但是我妹纸和她的队友告诉我她们在完成上一个作业的时候每次都是会清空的。我对着这次和上次的代码研究了很久，认为代码里面根本就没有清空 Flash 存储器的操作，如果有的话，掉电保存这项功能根本无从谈起。我妹纸她们也同意我的分析，但是她们的实践确实证明了每次都会清空 Flash 存储区。 这个问题也困扰了很久，直到第二天，用别人的电脑重新烧录了一遍程序，发现他们的是会正常清空的。所以说，问题在于 CCS 的版本：我妹纸使用的 CCS 版本是 6.1 ，而他们用的版本是 5.1.1 ，也就是说，不同版本的 CCS 在烧录程序期间的不同行为导致了这次错误。我们换用了 5.1.1 之后，成功解决了这个问题。 总结对嵌入式开发有了初步的了解，向着真·全栈开发工程师又近了一步。 这一次的开发经历遇到了很多因缺思艇的问题，因为嵌入式开发本身比较偏向底层，这次开发甚至还遇到了存储器的存储原理。也有一点将自己看的 CSAPP 融会贯通的感觉，还是很有意思的。 更新日志 2016年05月09日 首次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"C","slug":"C","permalink":"https://xuanwo.org/tags/C/"},{"name":"单片机","slug":"单片机","permalink":"https://xuanwo.org/tags/单片机/"}]},{"title":"Gitlab部署和汉化以及简单运维","slug":"gitlab-install-intro","date":"2016-04-13T23:20:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/04/13/gitlab-install-intro/","link":"","permalink":"https://xuanwo.org/2016/04/13/gitlab-install-intro/","excerpt":"起因在跟网络中心的老师沟通成立镜像站的相关事宜的时候，意外地接下来搭建一套校内的 Git 服务的任务。@怡红公子 曾经搭建过一套类似的服务，但由于服务器端没有开启 VT 虚拟化导致不能安装 64 位的操作系统，再加上 Gitlab 不提供 32 位的安装包，所以长期以来怡红公子一直都是自行编译并配置 Gitlab 。考虑到后续维护的方便，我们决定趁着这个机会使用另一台支持安装 64 位操作系统的服务器，一劳永逸地解决这个问题。我们的服务器环境是 CentOS 7.2 64bit ，以下所有操作均以此为基准。","text":"起因在跟网络中心的老师沟通成立镜像站的相关事宜的时候，意外地接下来搭建一套校内的 Git 服务的任务。@怡红公子 曾经搭建过一套类似的服务，但由于服务器端没有开启 VT 虚拟化导致不能安装 64 位的操作系统，再加上 Gitlab 不提供 32 位的安装包，所以长期以来怡红公子一直都是自行编译并配置 Gitlab 。考虑到后续维护的方便，我们决定趁着这个机会使用另一台支持安装 64 位操作系统的服务器，一劳永逸地解决这个问题。我们的服务器环境是 CentOS 7.2 64bit ，以下所有操作均以此为基准。 Gitlab 安装推荐使用 Install a GitLab CE Omnibus package 安装 ，其他发行版可以点选对应版本，不再赘述。 安装和配置依赖如果需要安装 Postfix 来发送邮件，则需要在安装过程中选择 Internet Site。你也可以使用 Sendmail 之类的第三方发信服务或者使用自行配制的 SMTP 服务器。除此以外，下列命令将会在防火墙中打开 HTTP(80) 和 SSH(22) 对应端口。 sudo yum install curl policycoreutils openssh-server openssh-clientssudo systemctl enable sshdsudo systemctl start sshdsudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfixsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 添加 Gitlab 源并安装curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bashsudo yum install gitlab-ce 这个脚本会在源中添加 Gitlab-CE ，并自动执行yum makecache，然后安装gitlab-ce。由于源在国外，可能速度较慢，也可以手动添加来自 清华tuna 的源： https://mirrors.tuna.tsinghua.edu.cn/help/gitlab-ce/ ， 链接中为各发行版下的教程，感谢 清华tuna 提供镜像。 配置并启动 Gitlab此时已经可以启动服务了： sudo gitlab-ctl reconfigure 进行一长串复杂的启动流程之后， gitlab 就已经可以通过 localhost 进行访问了。 Gitlab 配置修改域名默认的配置文件保存在 /etc/gitlab/gitlab.rb ，执行： sudo vim /etc/gitlab/gitlab.rb 打开文件，并修改： external_url 'http://your.domain' 再次执行 sudo gitlab-ctl reconfigure 即可。 有一定概率出现 502 错误，刷新浏览器或者再次更新配置即可。 Gitlab 汉化由于服务对象是广大师生，为了降低新手上手的难度，所有进行汉化也是非常有必要的。好在国内有人已经进行了这方面的工作，我们只需要共享其成果即可（欢迎向原项目提交高质量翻译）。 首先确认版本： sudo cat /opt/gitlab/embedded/service/gitlab-rails/VERSION 并确认当前汉化版本的 VERSION 是否相同，当前最新的汉化版本为 8.6 。如果安装版本小于当前汉化版本，请先升级。如果安装版本大于当前汉化版本，请在本项目中提交新的 issue。如果版本相同，首先在本地 clone 仓库。 # GitLab.com 仓库git clone https://gitlab.com/larryli/gitlab.git# 或 Coding.net 镜像git clone https://git.coding.net/larryli/gitlab.git 根据我的测试， Coding.net 的镜像不完整，clone 之后无法 checkout 然后比较汉化分支和原分支，导出 patch 用的 diff 文件。 # 8.1 版本的汉化补丁git diff origin/8-6-stable..8-6-zh &gt; ../8.6.diff 然后上传 8.6.diff 文件到服务器。 # 停止 gitlabsudo gitlab-ctl stopsudo patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 8.6.diff 确定没有 .rej 文件，重启 GitLab 即可。 sudo gitlab-ctl start 如果汉化中出现问题，请重新安装 GitLab（注意备份数据）。 Gitlab 运维管理# 启动所有 gitlab 组件：sudo gitlab-ctl start# 停止所有 gitlab 组件：sudo gitlab-ctl stop# 重启所有 gitlab 组件：sudo gitlab-ctl restart 备份备份GitLab repositories and GitLab metadata在 crontab 中加入如下命令：0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create 恢复首先进入备份 gitlab 的目录，这个目录是配置文件中的gitlab_rails[&#39;backup_path&#39;]，默认为/var/opt/gitlab/backups。 然后停止 unicorn 和 sidekiq ，保证数据库没有新的连接，不会有写数据情况。 sudo gitlab-ctl stop unicorn# ok: down: unicorn: 0s, normally upsudo gitlab-ctl stop sidekiq# ok: down: sidekiq: 0s, normally up 然后恢复数据，1406691018为备份文件的时间戳 gitlab-rake gitlab:backup:restore BACKUP=1406691018 修改数据存储地址默认情况下，gitlab 将数据存储在/var/opt/gitlab/git-data目录下，受限于分区情况&amp;方便管理，我们需要将数据迁移到别的目录下。 无需数据迁移如果还没有投入使用，则可以直接在配置文件中添加： git_data_dir \"/path/to/git-data\" 然后执行： sudo gitlab-ctl reconfigure 就可以生效了。 进行数据迁移如果已经有数据了，则需要进行迁移。 首先需要暂停服务，避免用户在迁移期间读写数据： sudo gitlab-ctl stop 然后使用rsync数据进行迁移： 注意前一个地址不需要/，后一个地址需要/，且只需要迁移repositories目录即可 sudo rsync -av /var/opt/gitlab/git-data/repositories /path/to/git-data/ 然后运行配置工具以更新并重启服务： 官网文档是先更新配置再启动服务，但我在使用中发现先更新配置会提示无法连接上服务器，出现这种问题时可以先启动服务再更新配置。 sudo gitlab-ctl reconfiguresudo gitlab-ctl start 最后不要忘了在网页端确认数据的地址是否正确。 关于权限问题在使用中，我一开始创建了一个gitlabhq用户并创建了一个文件夹，然后修改地址，服务正常启动后提示500。后来使用root账户在/home下直接创建文件夹解决了这个问题。如果有遇到类似问题的，可以尝试用root创建目录。 监听IPv6教育网拥有得天独厚的IPv6资源，所以为我们的gitlab服务添加IPv6支持很有必要。 修改/etc/gitlab/gitlab.rb文件中的： # nginx['listen_addresses'] = ['*'] 为 nginx['listen_addresses'] = ['*', '[::]'] 然后执行 sudo gitlab-ctl reconfigure 然后就可以通过IPv6访问了。 参考资料 Gitlab 下载 GitLab Community Edition · Wiki crontab 定时任务 Backup restore Storing Git data in an alternative directory 更新日志 2016年04月14日 首次发布 2016年04月18日 新增数据迁移&amp;监听IPv6配置","categories":[{"name":"Operate","slug":"Operate","permalink":"https://xuanwo.org/categories/Operate/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://xuanwo.org/tags/运维/"},{"name":"CUGBLUG","slug":"CUGBLUG","permalink":"https://xuanwo.org/tags/CUGBLUG/"},{"name":"Gitlab","slug":"Gitlab","permalink":"https://xuanwo.org/tags/Gitlab/"}]},{"title":"docopt——好用的Python命令行参数解释器","slug":"docopt-intro","date":"2016-04-04T21:39:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/04/04/docopt-intro/","link":"","permalink":"https://xuanwo.org/2016/04/04/docopt-intro/","excerpt":"前言Qingchat 使用的命令行参数解释器是 docopt，用下来感觉非常棒，所以决定介绍一下这个库。（奉劝各位看官，珍爱生命，远离argparse。）","text":"前言Qingchat 使用的命令行参数解释器是 docopt，用下来感觉非常棒，所以决定介绍一下这个库。（奉劝各位看官，珍爱生命，远离argparse。） 介绍docopt 本质上是在 Python 中引入了一种针对命令行参数的形式语言，在代码的最开头使用&quot;&quot;&quot;文档注释的形式写出符合要求的文档，就会自动生成对应的parse，体验非常赞。 用法样例docopt的使用非常简单，以Qingchat为例，你只需要在代码最开头加入： \"\"\"Qingchat CLIUsage: qingchat config ip &lt;ip&gt; qingchat config port &lt;port&gt; qingchat config login qingchat group list qingchat group choose &lt;group_name&gt;... qingchat group clean qingchat group send -t &lt;content&gt; qingchat group send -i &lt;media&gt; qingchat group send -f &lt;file&gt; [&lt;delaytime&gt;]Options: -h --help Show this screen. -v --version Show version.\"\"\" 然后在执行代码中加入： arguments = docopt(__doc__, version='Qingchat 0.3.2') 就会在你的程序中导入一个arguments字典，这个字典中的内容形如： &#123; '-f': False, '-i': False, '-t': False, '&lt;content&gt;': None, '&lt;file&gt;': None, '&lt;group_name&gt;': [], '&lt;ip&gt;': '127.0.0.1', '&lt;media&gt;': None, '&lt;port&gt;': None, 'choose': False, 'clean': False, 'config': True, 'group': False, 'ip': True, 'list': False, 'login': False, 'port': False, 'send': False&#125; 这样应该就能很容易看出来，我们在文档中写的每一个短语，都被转化为一个对应的类型。只要直接调用arguments[&#39;xxx&#39;]就可以判断或者使用对应的值，从而实现对应的功能。 详解前面我们举了一个例子，下面我们来详细介绍一下如何完成一个符合 docopt 要求的注释文档。 Usage所有出现在usage:（区分大小写）和一个空行之间的文本都会被识别为一个命令组合，usage后的第一个字母将会被识别为这个程序的名字，所有命令组合的每一个部分（空格分隔）都会成为字典中的一个key。 参数形如 &lt;argument&gt; 或者 ARGUMENT 的文本将会被识别为参数。在转化后的字典中的取值为 True 或者 False 。 Usage: my_program &lt;host&gt; &lt;port&gt; 选项形如 -o 或者 --option 的文本将会被识别为选项。在转化后的字典中的取值为 True 或者 False 。 Usage: my_program -f &lt;file&gt; Tips: 短选项可以组合起来，比如-abc等价于-a -b -c 长选项需要的参数需要使用 = 或者空格来分隔，--input=ARG 等价于 --input ARG 短选项可以不需要空格， -f FILE 等价于 -fFILE 命令其他不满足 --options 或者 &lt;arguments&gt; 的文本将会被识别为（子）命令。在转化后的字典中取值为 True 或者 False。 可选项形如 [optional elements] 的文本是可选项。elements包括上述的三种类型：参数，选项以及命令。 在相同或者不同的括号中都是一样的： Usage: my_program [command --option &lt;argument&gt;] 等价于 Usage: my_program [command] [--option] [&lt;argument&gt;] 必填项形如 (required elements) 的文本是必填项。上述三种元素默认都是必填项，()符号用在一些比较特殊的情形下，比如： Usage: my_program (--either-this &lt;and-that&gt; | &lt;or-this&gt;) 选择项形如 element|another 的文本是选择项，你可以从中选择一个值。 Usage: my_program go (--up | --down | --left | --right) 列表项形如 element... 的文本是列表项，你可以输入多个参数。 比如说： Usage: my_program open &lt;file&gt;... 然后你可以通过arguments[&#39;&lt;file&gt;&#39;] 来访问这个列表。 OptionOption 部分用于指定某些特殊情形，比如： 将某个短参数与长参数关联起来，比如-i &lt;file&gt;, --input &lt;file&gt; 某个选项有一个参数 选项的默认值，比如--coefficient=K The K coefficient [default: 2.95] 校验如果对自己完成的文档有疑问，可以使用在线工具进行校验。 更新日志 2016年04月04日 首次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"python","slug":"python","permalink":"https://xuanwo.org/tags/python/"},{"name":"qingchat","slug":"qingchat","permalink":"https://xuanwo.org/tags/qingchat/"}]},{"title":"微信多群直播的新探索——Qingchat","slug":"qingchat-intro","date":"2016-04-01T22:03:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/04/01/qingchat-intro/","link":"","permalink":"https://xuanwo.org/2016/04/01/qingchat-intro/","excerpt":"前言在我之前写过的一篇文章中，我曾经探索过类似的问题：微信群重复人员识别。当初我就提出过能否自动获取相关数据，但因为种种原因的限制不了了之了。后来发现了Mojo-Weixin这个库之后，我决定在这个的基础上实现一个微信多群直播的工具——Qingchat。（尽管在刚刚实现完不久，微信就更新了转发到多个群的功能，Sad。）探索的成果如下： Qingchat，目前仅支持 python3 ，欢迎各位看官提 issues ，交 code ，或者拍砖。接下来我会先介绍一下 Qingchat 的原理，然后介绍 Qingchat 的使用，最后展望一下 Qingchat 未来的发展方向。","text":"前言在我之前写过的一篇文章中，我曾经探索过类似的问题：微信群重复人员识别。当初我就提出过能否自动获取相关数据，但因为种种原因的限制不了了之了。后来发现了Mojo-Weixin这个库之后，我决定在这个的基础上实现一个微信多群直播的工具——Qingchat。（尽管在刚刚实现完不久，微信就更新了转发到多个群的功能，Sad。）探索的成果如下： Qingchat，目前仅支持 python3 ，欢迎各位看官提 issues ，交 code ，或者拍砖。接下来我会先介绍一下 Qingchat 的原理，然后介绍 Qingchat 的使用，最后展望一下 Qingchat 未来的发展方向。 原理Qingchat 基于 Mojo-Weixin 进行开发，通过调用 Mojo－Winxin 的 http 接口与微信服务器进行通信以实现群发功能。目前主要支持微信群发工作，可以从文件中读取内容，并根据内容长度设置发送延时以模拟真人输入效果。 用法配置想要使用Qingchat，首先需要在服务器或者本地配置好 Mojo－Weixin 环境。 测试&amp;安装perl环境除了 Windows 环境，大部门环境下已经默认预装了 perl 环境，可以通过｀perl －－version｀查看。本环境要求 perl 5.10 以上。缺乏相关环境的，可以安装对应系统的集成包： 平台 推荐选择 下载地址 Windows 1. StrawberryPerl2. ActivePerl StrawberryPerl下载地址ActivePerl下载地址 Linux 1. ActivePerl2. 官方源码3. yum/apt等包管理器4. Mojo-ActivePerl ActivePerl下载地址Mojo-ActivePerl下载地址 Mac 1. ActivePerl ActivePerl下载地址｜ 安装 Mojo::Weixin 模块首先需要安装 cpanm 工具：cpan -i App::cpanminus 然后通过 cpanm 工具安装 Mojo::Weixin cpanm Mojo::Weixin 运行将如下代码使用utf－8编码保存为源码文件： #!/usr/bin/env perluse Mojo::Weixin;my ($host,$port,$post_api);$host = \"0.0.0.0\"; #发送消息接口监听地址，修改为自己希望监听的地址$port = 3000; #发送消息接口监听端口，修改为自己希望监听的端口#$post_api = 'http://xxxx'; #接收到的消息上报接口，如果不需要接收消息上报，可以删除或注释此行my $client = Mojo::Weixin-&gt;new(log_level=&gt;\"info\",ua_debug=&gt;0,qrcode_path=&gt;\"qrcode.jpg\");$client-&gt;login();$client-&gt;load(\"ShowMsg\");$client-&gt;load(\"Openwx\",data=&gt;&#123;listen=&gt;[&#123;host=&gt;$host,port=&gt;$port&#125;], post_api=&gt;$post_api&#125;);$client-&gt;run(); 上述代码保存为 test.pl ， 并通过 perl 来运行： perl test.pl 然后就会产生一个监听 3000 端口的 http 服务器。 未竟事宜可以参考此处 配置Nginx为了方便调用二维码，还需要配置一个 Web 服务器。安装Nginx，在配置文件中添加： server &#123; listen 80 default_server; listen [::]:80 default_server ipv6only=on; root /path/to/your/qrcode; # &#125; 最终，能在浏览器中以 http://xxx.xxx.xxx.xxx/qrcode.jpg 的形式访问到二维码即配置成功。 安装QingchatpipQingchat已经上传到了pypi，只需要使用pip进行安装即可： pip install qingchat 源码Qingchat最新开发版代码位于： https://github.com/Xuanwo/qingchat/tree/dev 你可以使用 pip install -e git+https://github.com/Xuanwo/qingchat/tree/dev 或 git clone https://github.com/Xuanwo/qingchat/tree/devcd qingchatpython setup.py install 以进行安装。 使用Qingchat 的使用非常简单： 配置通过如下命令配置后端服务器的 ip 地址和端口： qingchat config ip &lt;ip&gt;qingchat config port &lt;port&gt; 配置文件默认会保存在~/.config/qingchat/config.yml。 Win下可能需要设置HOME环境变量才能正常运行 登陆配置完毕后，执行 qingchat config login 就会自动弹出一个二维码，使用微信扫描并登录后即可。如果出现问题，请再次执行此命令。 群发消息qingchat group list 此命令可以列出你保存到通讯录中的所有群组。 qingchat group choose &lt;group_name&gt; 此命令可以将指定群组加入列表，支持正则 qingchat group clean 此命令可以清除列表 qingchat group send -t &lt;content&gt;qingchat group send -i &lt;media&gt;qingchat group send -f &lt;file&gt; -t 参数用于发送文本信息 -i 参数用于发送媒体信息，图片会直接显示，其他类型将以文件形式传输 -f 参数用于指定文件，逐行发送，在开头添加!可以发送媒体信息 展望Qingchat 目前还处于开发阶段，功能不完善，BUG也很多，部署也相当麻烦。接下来，我将努力完成以下工作： 更好的二维码呈现机制 基于 Web 的图形化界面 支持消息上报的 Server 端 更多功能的实现，支持好友管理&amp;群组管理等 更新日志 2016年04月01日 初次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[]},{"title":"罹患痛风感言","slug":"gout","date":"2016-03-13T13:44:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/03/13/gout/","link":"","permalink":"https://xuanwo.org/2016/03/13/gout/","excerpt":"其实我很想写出获奖感言的感觉，但是痛风发作的时候真的好疼啊。。。","text":"其实我很想写出获奖感言的感觉，但是痛风发作的时候真的好疼啊。。。 起因从高中开始，中指的关节就一直有一些不明的肿胀，摸上去硬硬的，平时也不会痛，只是屈伸和握拳的时候有些困难。一直到了大学，我女朋友一直非常在意我的手，总是催我去医院看看。于是假期的时候，我跟我妈去医院挂了骨科，还拍了CT，但是医生却说骨头没有问题，关节也没异常，让我去别的科室看看。其实我是有些懵逼的，因为我原来预想的最差的结果就是动一下手术，然后休息个把个月。现在这种状况让我有些隐约的不妙，毕竟未知才是最可怕的东西。因为对家乡的医院水平比较怀疑，所以到了北京之后又挂了北医三院的号，然后做了一堆检查，那个医生让我挂一个副教授的号= =，说他不能确定，以前没有见过。好吧，我再挂一个副教授的号。然后副教授告诉我他也不能确定，让我去做一个更厉害的测试（RMB800+）。等到下一次又挂上号之后，他告诉我有了这个单子之后就能确诊我是痛风了。然后叮嘱我不要吃海鲜和啤酒，要多注意饮食，多喝水，控制体内尿酸含量，然后开了一堆降低尿酸的药。 服药收了药之后就开始了一段稳定的服药阶段，医生给我开了三种药：苯溴马隆，痛风定和碳酸氢钠片。 当然，我也是后来才知道医生给我开的药的搭配合理之处，不过那个时候的我还不太了解，所以才有了之后的磨难。 苯溴马隆每天一片，痛风定每日三次，每次一片，碳酸氢钠每日三次，每次一片。那几天我基本上每天嘴巴里面都是药味，然后每天手里都捧着我的水杯喝个不停。主要的原因还是因为自己对于痛风以及伴随痛风而来的疼痛的恐惧，当然有些过激，但是现在感觉很有必要，只是那个时候还不是很明白。除了吃药之外，每天的饮食也有一些变化，肉食倒是没有断，只是不再吃鱼了，这个让我那个喜欢吃鱼的女朋友非常难过。平时也不怎么喝酒，所以戒酒对于我来说倒是没有什么问题，反而多了一个可以合理拒绝敬酒的理由。这种境况一直持续到我回家，我妈妈以及很多亲人都劝我不要再吃药了，主要的想法是这样的：这个病治不好的，吃药没有用，主要依靠饮食控制。很多药，比如苯溴马隆的副作用又很大，对肾不好等等。这么想也有道理，于是我就停了药，只是每天依然坚持多喝一些水。只是量没有达到医生的要求，医生当初给我开药的时候让我每天喝2.5升水，我在家的几天估计只喝了1升每天。 发作再次开学之后，我已经停药大概一个月左右，身体没有发现任何异常，中指的关节还有一些变小的趋势，一切都在往好的方向发展。于是我做了一个现在挺后悔的决定：去打球。第一次是周二，跟我的同学在一起打得。打得非常尽兴，由于很久没有运动，打完之后浑身酸软，第二天起床基本抬不起手的那种。我不是很明白这其中的机理，可能是运动产生的乳酸通过某种形式转化为了尿酸，然后沉积了起来。症状不明显，中指有些轻微发热而已，我以为是乳酸分解的正常现象，没有及时采取措施。然后周四晚上我又去跟公司里面的同事打球了，当然同样也很开心，虽说右手活动起来有些困难。回校之后，中指就开始以肉眼可见的速度肿胀起来。这个时候还没有觉得痛，只是行动稍微有些不便，跟女朋友说了之后，也只是让我好好休息，多喝喝水而已。一直到了周六的晚上，右手中指时不时地开始抽痛，左手食指的根部也开始红肿了起来，我有些紧张，开始大量喝茶，希望可以把尿酸都排出去。但，事与愿违。到了周日的晚上，中指越来越严重的刺痛感已经让我完全睡不着觉了。那天晚上我抱着水杯通宵看完了 QG 与 Fnatic 的比赛（QG还输了，Sad），好不容易睡着之后，第二天发现情况并没有变好，反而感觉更加严重了——我完全没有办法忍受哪怕是穿衣服这种时候给我手指带来的疼痛感。没有办法，我打电话给我女朋友说明了情况，跟公司里面请了假，让舍友替我请假，全天呆在宿舍里面，只干一件事情——喝水。那几天真的让我女朋友操碎了心，她把每种食物的嘌呤含量都背了下来，然后只给我买低嘌呤含量的东西送给我吃。但即使是这样，我的疼痛感也没有减轻很多。万般无奈之下，女朋友带我去挂了急诊，结果急诊的护士冷冰冰地告诉我们这个是痛风，让我们第二天来挂风湿免疫科。在好心人的指点下，我们去药房买了秋水仙碱，那个据说对缓解痛风急性发作由奇效的药。回去之后，我按照说明书，一个小时吃一片，吃了六个小时，但是感觉没有什么用。后来看了一个医生的博客，我采用了一次性吃两片，过一个小时之后再吃一片的策略。到了第二天，关节的肿痛有了很大的改善，配合上大量饮水，基本上已经可以正常生活了。 尾声秋水仙碱作为一个剧毒物果然名不虚传，我被它的药效支配了很久，在我们宿舍的门口把我吃的一整碗炒饭全都吐了出来。不仅如此，我还腹泻了好几天，基本上没过多久就要上一次大号。时至今日，我的左手食指根红肿已经全部退去，右手中指关节还有些肿，但是已经不会再有抽痛感，已经可以恢复正常生活了。 致谢首先要非常感谢我女朋友对我的无微不至的照顾（尽管她并不看我的博客），她记下了每一种食物的嘌呤含量，专门买了PH值8.0的苏打水给我喝，如果没有她的帮助和支持，我不知道如何度过噩梦般的那几天；其次要感谢我的室友，他们帮我带饭，帮我请假，帮我穿衣服（恩- -，只是外套而已），在我呕吐之后替我打扫，喂我喝水甚至包括帮我开矿泉水的瓶盖和拉开宿舍的门等等，没有他们的话，我可能真的就只能躺在床上什么都做不了了；最后要感谢公司的同事们承担了本来属于我的工作，只对我说一句好好休息而已。非常感谢你们，你们是我在那几天痛苦的回忆里面唯一的亮色。 总结痛风发作是一件非常痛苦的事情，所以平时各位一定要注意饮食，养成良好的习惯，有条件的话定期去医院做检查，将疾病扼杀在摇篮之中。 即使患上了痛风，也不要自暴自弃，控制饮食，合理用药，完全可以保证以后不再发作： 痛风急性发作时：服用秋水仙碱（一次性两片，过一个小时后再服一片，如果不见好转，12小时后再服一片）和止疼药（布洛芬等等） 痛风间歇期时：服用苯溴马隆（一天一片）以促进尿酸排泄，碳酸氢钠（碱化尿液，便于尿酸排出） 长期用药：别嘌呤醇（副作用大），痛风定非布索坦（副作用小，但极贵），痛风定胶囊（中药，可减少嘌呤生成） 更新日志 2016年03月13日 首次发布","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[]},{"title":"Neovim慢速升级攻略","slug":"neovim-slow-upgrade","date":"2016-03-12T11:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/03/12/neovim-slow-upgrade/","link":"","permalink":"https://xuanwo.org/2016/03/12/neovim-slow-upgrade/","excerpt":"前言一直都非常羡慕那些能把vim用得非常溜的人，但是自己总是不情愿去学，总是觉得vim的操作方式非常反人类，难度曲线太陡，不适合我。真正让我下定决心去学的，是因为系统切换到Ubuntu Gnome之后发现，Sublime Text 3 不能原生支持中文输入。同时我也发现，如果我不上来就折腾spf13这样的东西的话，其实vim非常好懂。于是，Neovim的慢速升级攻略就这样诞生了。","text":"前言一直都非常羡慕那些能把vim用得非常溜的人，但是自己总是不情愿去学，总是觉得vim的操作方式非常反人类，难度曲线太陡，不适合我。真正让我下定决心去学的，是因为系统切换到Ubuntu Gnome之后发现，Sublime Text 3 不能原生支持中文输入。同时我也发现，如果我不上来就折腾spf13这样的东西的话，其实vim非常好懂。于是，Neovim的慢速升级攻略就这样诞生了。 安装安装可以参考此处如果是Ubuntu 的话，则可以执行如下代码： sudo add-apt-repository ppa:neovim-ppa/unstablesudo apt-get updatesudo apt-get install neovim Neovim常用操作初步光标移动gg 移动到文件开头G 移动到文件末尾 文件操作相关:w &lt;filename&gt; 按照保存文件:wq 保存并退出:q! 退出不保存:e 打开新的文件并关闭当前文件，使用Tab可以补全 文件编辑相关dd 删除当前行y 复制yy 复制当前行yG 复制光标以上全部行ygg 复制光标以下全部行p 粘贴u 撤销 入门使用内置终端:terminal 打开终端，输入exit并使用esc或enter即可退出 与系统剪切板集成这个地方折腾了好久，Neovim默认是支持+寄存器的，但是我通过&quot;+y命令调用寄存器时却提示Clipboard No Provider。通过阅读文档之后，我得知，必须要安装下列三个包中的至少一个，才能正常使用剪切板： xclip xsel (newer alternative to xclip) pbcopy/pbpaste (only for Mac OS X) 安装好之后再打开，就可以正常使用了。 快速复制全文的技巧： 在Normal模式下，gg跳转到文章开头，VG选中全文，&quot;+y复制到剪切板。 Neovim插件vim-airlinevim-airline是一个vim的状态栏插件，同样支持neovim。 安装此插件后启动nvim会报错，自行编译后错误消失，不知道具体的原因。 Smarter tab line在init.vim中加入 &apos; 开启tabline功能let g:airline#extensions#tabline#enabled = 1&apos; 设置tabline分隔符let g:airline#extensions#tabline#left_sep = &apos; &apos;let g:airline#extensions#tabline#left_alt_sep = &apos;|&apos; 支持的一些快捷操作命令： :bn: 跳转下一个buffer:bp: 往上一个buffer:b&lt;n&gt;: 跳往第n个buffer:bd: 关掉目前buffer vim-airline-themes个人比较偏爱solarized的暗色皮肤，所以需要使用这个库来安装airline配套的皮肤。在init.vim中添加 Plug &apos;vim-airline/vim-airline-themes&apos; 然后修改： let g:airline_theme=&quot;solarized&quot; 即可 vim-colors-solarized顾名思义，这是solarized for vim。在init.vim中添加 Plug &apos;altercation/vim-colors-solarized&apos; 然后修改： set background=darkcolorscheme solarized 即可 更新日志 2016年03月12日 首次发布 2016年03月15日 增加air-line相关内容 2016年06月16日 增加主题配置相关内容，并添加了部分常用快捷键","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"vim","slug":"vim","permalink":"https://xuanwo.org/tags/vim/"}]},{"title":"微信群重复人员识别","slug":"wechat-remove","date":"2016-02-28T10:05:00.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2016/02/28/wechat-remove/","link":"","permalink":"https://xuanwo.org/2016/02/28/wechat-remove/","excerpt":"前言由于微信的限制，人数超过一百以后，只有邀请才能加入。所以，如果想要组织大型的在线活动，就只有建立很多个分群。然而分群的问题在于，会有很多人重复加群，挤占了本来就缺乏的空间。所以需要找到一个可行的办法，清除两个群中的重复人员。","text":"前言由于微信的限制，人数超过一百以后，只有邀请才能加入。所以，如果想要组织大型的在线活动，就只有建立很多个分群。然而分群的问题在于，会有很多人重复加群，挤占了本来就缺乏的空间。所以需要找到一个可行的办法，清除两个群中的重复人员。 可行的方法在微信网页版中，通过点击群名称右侧的向下箭头，可以打开一个有所有人昵称的面板，通过审查工具可以得到对应的代码，右击选择Edit As HTML，全选复制，保存到a.txt中，然后执行 cat a.txt | grep -o \"\\\"&gt;.*&lt;/p&gt;\" &gt; fen.txt 我们便可以将所有人的名字都输出到fen.txt中，尽管还有着一些&lt;，&gt;的符号，但是已经不影响识别了，故不再做处理。 对两个群分别如此操作之后，我们得到了两个群的成员名单。然后执行如下Python代码： with open(&apos;fen.txt&apos;, &apos;r&apos;) as f: fen = f.readlines() f.close()with open(&apos;main.txt&apos;, &apos;r&apos;) as f: main = f.readlines() f.close()for i in main: for j in fen: if i == j: print(i) 得到的输出就是两个群中重复的成员，然后一一删除即可。 方案反思存在的缺陷 自动化程度较低 如果存在用户同名的话，会导致删除错误的用户。 可能的改进 获取资料不需要手动点击审查元素，通过jQuery的text()函数也可以实现。 最后实现删除的过程可以进一步优化，通过模拟用户点击的脚本实现（存在隐私泄漏风险）。 可以获取用户的UUID，以避免重名现象。 更新日志 2016年02月28日 首次发布","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"微信","slug":"微信","permalink":"https://xuanwo.org/tags/微信/"}]},{"title":"记一次debug的经历及反思","slug":"debug-for-hexo-1775","date":"2016-02-26T12:54:00.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2016/02/26/debug-for-hexo-1775/","link":"","permalink":"https://xuanwo.org/2016/02/26/debug-for-hexo-1775/","excerpt":"起因hexojs/hexo #1775BUG非常明显，在使用hexo 3.1.1搭建一个位于子目录下的博客，然后会发现home以及categories的链接全都忽略了子目录的设定。","text":"起因hexojs/hexo #1775BUG非常明显，在使用hexo 3.1.1搭建一个位于子目录下的博客，然后会发现home以及categories的链接全都忽略了子目录的设定。 经过收到反馈之后，我在我的测试环境中也复现了这个bug。一开始还怀疑是主题的问题，专门测试了next主题，结果发现也存在这样的问题，于是就排除了主题方面的bug。首先我们可以初步判断这个url生成出现了问题，参考landscape主题中此处的代码： &lt;% for (var i in theme.menu)&#123; %&gt; &lt;a class=&quot;main-nav-link&quot; href=&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%= i %&gt;&lt;/a&gt;&lt;% &#125; %&gt; 这里调用了一个url_for函数来生成超链接，代码如下（去除了与本BUG无关的部分）： function urlForHelper(path, options) &#123; path = path || &apos;/&apos;; if (path[0] === &apos;#&apos; || path.substring(0, 2) === &apos;//&apos;) &#123; return path; &#125; var config = this.config; var root = config.root; var data = url.parse(path); // Exit if this is an external path if (data.protocol) &#123; return path; &#125; // Prepend root path path = root + path; return path.replace(/\\/&#123;2,&#125;/g, &apos;/&apos;);&#125; 直觉告诉我，这个问题很有可能就是这个函数写搓了。 然而我仔细研究了一下，发现url_for的逻辑并没有什么问题。而且根据我脑补的代码执行情况来看，应该生成一个正确的链接才对，但是config.root偏偏就丢了。真的是非常奇怪，一时之间，我完全懵逼展开了，不明白到底发生了什么。 转折后来我跟我的朋友聊天的时候提到这个bug，结果他告诉我，这个url_for写搓了，我点点头，应该就是这样。然后他说，一个判断都没有中，直接返回自身了，还贴了一张图。图中的代码大致如下： function urlForHelper(path, options)&#123; /* jshint validthis: true */ path = path || &apos;/&apos;; var config = this.config; var root = config.root; var data = url.parse(path); // Exit if this is an external path if (data.protocol || path.substring(0, 2) === &apos;//&apos;)&#123; return path; &#125; // Prepend root path if (path[0] !== &apos;/&apos;)&#123; return root + path; &#125; return path;&#125; 看到图我立马懵逼了，连忙说，不对啊，你这个不是最新版本的代码。他被我这气场吓到，弱弱回复，我是刚安装的hexo…。我顿时明白自己错在哪里了，npm源里面的稳定版还是3.1.1，但是我们github库中的代码已经是3.2beta了。使用最新的代码测试以后，发现这个bug已经不存在了。也就是说，我花一个下午的时间，对着最新版的代码找一个已经被fix的bug… 总结这一次的事情非常乌龙，事后想想觉得自己真的太傻逼了。吃一堑长一智，以后做debug工作的时候一定要分清楚线上和线下的代码，首先就要明确出问题的是哪个版本，然后再开展相应的分析。除此以外，还跟我不重视流程有关系。尽管我总是让人提供各种version信息，但是我却总是在分析问题的时候忽略这些信息，没有把这些关键的信息加入到自己的分析过程中。总结起来就是，too young ，姿势水平还有待提高。 更新日志 2016年02月26日 初次发布","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://xuanwo.org/tags/Nodejs/"}]},{"title":"北地网费新政策下的生存攻略","slug":"ipv6-in-cugb","date":"2016-02-17T18:59:02.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/02/17/ipv6-in-cugb/","link":"","permalink":"https://xuanwo.org/2016/02/17/ipv6-in-cugb/","excerpt":"主旨只有两条：开源，节流","text":"主旨只有两条：开源，节流 开源根据国家推广ipv6应用的相关规定，IPv6的流量依然是不计费的，所以我们需要充分利用IPv6的广泛资源。 互联网通讯协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是互联网协议的最新版本，用于分组交换互联网络的网络层协议，旨在解决IPv4地址枯竭问题。 如何开启ipv6 下面内容仅适用于地大校园有线网，不适用于CUGBNET，不适用于绝大多数USB网卡。 检查自己的电脑是否已经打开ipv6支持打开浏览器访问： http://test-ipv6.com/ 如果所有项目都显示为绿勾，说明你已经可以正常使用IPv6了，如果有红叉，则需要打开系统对IPv6的支持 打开ipv6Win + R 快捷键调出“运行”对话框，输入“ncpa.cpl”。如图： 回车后打开网络连接，在以太网上右击，选择最后一项属性，打开以太网属性，如图： 向下浏览，确保TCP/IPv6这一项已经被选中。 然后使用此网址登陆，深澜自带的登录器貌似有BUG，IPv6不会进行拨号。 IPv6应用PT下载 PT（Private Tracker）是一种改良自BitTorrent协议的P2P下载方式，“Private Tracker”指私有种子服务器。与BT最大的不同点分别为可进行私密范围下载，及可统计每个用户的上传及下载量。PT可进行私密范围下载，因此提供PT的讨论区大多非公开的，采用邀请制或是不定时开放注册。用户注册后会得到一个passkey，因此可借由passkey辨识每个用户，用户从某PT站下载种子后，该种子即带有用户的passkey。因此PT的种子是不可外流到其他地方，且不允许一个用户有过多IP（通常上限为3个IP）同时上下传。为了控制用户数量，关闭自由注册的PT网站一般采用邀请码制度，由已注册的用户向自己所信任的人发送邀请，以确保用户质量。借由这些机制，传统P2P下载常发生一些client端只下载而不分享上传的“吸血”行为将可杜绝。而BT种子在一两周后做种者大幅减少，以致后来下载者无法顺利完档的缺点在PT获得改善。 在教育网中，由于IPv6没有带宽和流量限制，所以PT下载得到了极大的发展。相对于IPv4下的下载，PT下载通常有以下优点： 下载速度飞快，没有上限。在宿舍可以达到10M/s，在实验室可以达到100M/s。 国家正在推广IPv6，故IPv6不进行计费，所有IPv6的流量都是免费的。 资源丰富。由于PT站的私密特性，很多资源都保存地非常好，新的资源也更新地非常及时。 老司机友情提醒，欲求先予，如果只下载不上传的话，很容易被删号的。在加入一个PT站的时候一定要先阅读PT站的说明，谨防封号。每个PT站基本都有着邀请制度，需要使用邀请码才能进入。 下面给出一些常用的PT站： 北地PT 无需邀请，荒废多年，不过借这波机会应该会复苏了~ 北邮人PT 我校IPv6入口就在北邮，速度相当快，资源也很多，非常活跃 六维空间 应当是教育网最大的PT站了，资源最多，非常活跃 推荐的PT下载工具： utorrent bittorrent 绝对禁止使用迅雷下载，严重者可能导致封号。 IPv6电视IPv6电视就相对显得比较简单易懂了，直接在线收看即可，不消耗IPv4流量。 下面同样给出一些地址： 北京大学IPv6 北京邮电大学IPv6 IPv6电视直播墙 IPv6转换当然也可以通过将IPv4流量转换为IPv6来逃开计费。 需要安装六快拨浏览器，使用该浏览器即可免费上网。 利益无关，没有测试，不知速度如何。 节流网络游戏流量消耗网络游戏耗费的流量不多，比如英雄联盟，一分钟只消耗一兆不到。所以玩游戏的童鞋们大可放心，按照每天撸三个小时来算，也不过是5.4G不到而已，不慌。 内网文件传输可以用飞鸽传书，如果不放心可以在不登录网关的时候传输文件，只需要对方也安装了飞鸽传书即可。 总结在充分利用ipv6资源并辅以适当的节流方式下，可以将网费控制在20元(25G)以下。所以童鞋们大可不必惊慌。我的想法是，付费可以，但是请地大提供更加优秀的网络环境。 参考资料 IPv6 PT下载 更新日志 2016年02月17日 初次发布 2016年02月20日 修复网关登录链接，补充PT下载工具 2016年03月11日 修复北京邮电大学IPv6电视链接","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"CUGB","slug":"CUGB","permalink":"https://xuanwo.org/tags/CUGB/"}]},{"title":"Chocolatey——Windows下的包管理工具","slug":"chocolatey-intro","date":"2016-02-15T20:15:46.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2016/02/15/chocolatey-intro/","link":"","permalink":"https://xuanwo.org/2016/02/15/chocolatey-intro/","excerpt":"前言Chocolatey是一个基于Nuget的Windows包管理工具，截止到我更新此文章的时候，一共有3.7k多个独立包。本文旨在介绍Chocolatey这一工具的安装和用法，希望能有更多人享受到该工具的便利之处。","text":"前言Chocolatey是一个基于Nuget的Windows包管理工具，截止到我更新此文章的时候，一共有3.7k多个独立包。本文旨在介绍Chocolatey这一工具的安装和用法，希望能有更多人享受到该工具的便利之处。 安装chocolateyCMD打开一个具有管理员权限的命令行窗口，执行如下命令：@powershell -NoProfile -ExecutionPolicy Bypass -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin PowerShell打开一个具有管理员权限的PowerShell窗口，执行如下命令：iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) 使用chocolatey安装包安装包十分的容易，只需要打开管理员权限的命令行即可： choco install &lt;package&gt; 卸载包卸载也同样十分简单，打开管理员权限命令行，执行： choco uninstall &lt;package&gt; 更新包更新包则需要使用如下命令： choco upgrade &lt;package&gt; 为chocolatey做贡献Chocolatey的一个特点就是社区化的环境，每一个人都可以向它提交自己喜爱的包。因为Chocolatey总是从官方下载所需要的包，所以避免了授权等问题。当然，本来收费的软件，同样需要收费，比如JetBrains系列的产品。 注册APIKey提交包则会略为复杂一点，首先你需要在https://chocolatey.org/ 注册一个账号，并获取跟你账户绑定的唯一APIKey。然后在命令行中执行如下命令： choco apikey -k &lt;your key here&gt; -s https://chocolatey.org 新建软件包在命令行中运行 choco new &lt;package name here&gt;# 为方便理解，此处使用test做包名 则当前目录下就会自动生成一个名为test的文件夹，目录结构如下： test.nuspectools |--chocolateyinstall.ps1 |--chocolateyuninstall.ps1 |--ReadMe.md 完善信息修改test.nuspec自动生成的描述文件在需要填写的位置都有大写英文注释，只需要按照要求一一填写即可，下面我列举一份已经通过审核的Datagrip的描述文件作为参考： &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- Do not remove this test for UTF-8: if “Ω” doesn’t appear as greek uppercase omega letter enclosed in quotation marks, you should use an editor that supports UTF-8, not this one. --&gt;&lt;package xmlns=\"http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd\"&gt; &lt;metadata&gt; &lt;!-- Read this before publishing packages to chocolatey.org: https://github.com/chocolatey/chocolatey/wiki/CreatePackages --&gt; &lt;id&gt;datagrip&lt;/id&gt; &lt;title&gt;DataGrip&lt;/title&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;authors&gt;JetBrains&lt;/authors&gt; &lt;owners&gt;Xuanwo&lt;/owners&gt; &lt;summary&gt;Your Swiss Army Knife for Databases and SQL&lt;/summary&gt; &lt;description&gt;## Intelligent query consoleAllows you to execute queries in different modes and provides local history that keeps track of all your activity and protects you from losing your work.......(省略)&lt;/description&gt; &lt;projectUrl&gt;https://www.jetbrains.com/datagrip/&lt;/projectUrl&gt; &lt;packageSourceUrl&gt;https://github.com/Xuanwo/datagrip-chocolatey-package&lt;/packageSourceUrl&gt; &lt;!--&lt;projectSourceUrl&gt;&lt;/projectSourceUrl&gt; &lt;docsUrl&gt;&lt;/docsUrl&gt; &lt;mailingListUrl&gt;&lt;/mailingListUrl&gt;--&gt; &lt;bugTrackerUrl&gt;https://youtrack.jetbrains.com/issues/DBE&lt;/bugTrackerUrl&gt; &lt;tags&gt;datagrip admin jetbrains trial 30days&lt;/tags&gt; &lt;copyright&gt;Commercial&lt;/copyright&gt; &lt;!--&lt;licenseUrl&gt;&lt;/licenseUrl&gt;--&gt; &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt; &lt;!--&lt;iconUrl&gt;http://cdn.rawgit.com/__REPLACE_YOUR_REPO__/master/icons/datagrip.png&lt;/iconUrl&gt;--&gt; &lt;!--&lt;dependencies&gt; &lt;dependency id=\"\" version=\"__VERSION__\" /&gt; &lt;dependency id=\"\" /&gt; &lt;/dependencies&gt;--&gt; &lt;releaseNotes&gt;https://confluence.jetbrains.com/display/DBE/DataGrip+1.0.1+Release+Notes&lt;/releaseNotes&gt; &lt;!--&lt;provides&gt;&lt;/provides&gt;--&gt; &lt;/metadata&gt; &lt;files&gt; &lt;file src=\"tools\\**\" target=\"tools\" /&gt; &lt;/files&gt;&lt;/package&gt; 有一个比较坑的地方是&lt;description&gt;部分是支持Markdown的，内容直接顶着括号写就OK，不用另起一行，也不用自己加缩进。 补充chocolateyinstall.ps1 chocolateyuninstall可以没有，但是一定要有chocolateyinstall脚本。 chocolateyinstall.ps1如果点击编辑打开的话，会自动调用Windows Powershell ISE编辑器。 下面同样列举一份已经填写完成的样例： $packageName= 'datagrip'$installerType = 'EXE'$toolsDir = \"$(Split-Path -parent $MyInvocation.MyCommand.Definition)\"$url = 'https://download.jetbrains.com/datagrip/datagrip-1.0.1.exe'$silentArgs = '/S'$validExitCodes = @(0)Install-ChocolateyPackage \"$packageName\" \"$installerType\" \"$silentArgs\" \"$url\" -validExitCodes $validExitCodes 需要注意的是，填写完毕之后，一定要在Powershell中运行下列代码以删除所有的注释文字： $f='c:\\path\\to\\thisFile.ps1'gc $f | ? &#123;$_ -notmatch \"^\\s*#\"&#125; | % &#123;$_ -replace '(^.*?)\\s*?[^``]#.*','$1'&#125; | Out-File $f+\".~\" -en utf8; mv -fo $f+\".~\" $f 打包上传所有的信息填写完成后，在test.nuspec所在目录下执行choco pack就会自动进行打包。如果有重要的信息没有填写，choco将会报错，并红字提示： LicenseUrl cannot be empty.ProjectUrl cannot be empty.PackageSourceUrl cannot be empty. 如果没有问题，则会有如下提示： Attempting to build package from 'datagrip.nuspec'.Successfully created package 'datagrip.1.0.1.nupkg' 之后执行 choco push datagrip.1.0.1.nupkg即可将包上传至Chocolatey，通过管理员的审核之后，就会出现在软件列表中供人们下载了。 参考资料 Chocolatey 官方网站 Chocolatey, 我爱你 更新日志 2016年02月15日 初步完成 2016年02月20日 修复脚本中的部分错误","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Windows","slug":"Windows","permalink":"https://xuanwo.org/tags/Windows/"}]},{"title":"解放你的智能电视","slug":"unlock-your-smart-tv","date":"2016-02-04T23:12:52.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/02/04/unlock-your-smart-tv/","link":"","permalink":"https://xuanwo.org/2016/02/04/unlock-your-smart-tv/","excerpt":"前言现在很多人都买了智能电视，但是出于种种你懂得原因，厂商通常都不允许用户自行安装自己想要的APP，比如腾讯视频，优酷视频之类的。本教程旨在突破这些限制，彻底解放智能电视的全部潜力。","text":"前言现在很多人都买了智能电视，但是出于种种你懂得原因，厂商通常都不允许用户自行安装自己想要的APP，比如腾讯视频，优酷视频之类的。本教程旨在突破这些限制，彻底解放智能电视的全部潜力。 前提 一台智能电视（基于安卓平台） 一台电脑 互联网连接 操作自己动手丰衣足食 强力推荐，避免第三方软件安装莫名其妙的东西，没有后台驻留 前期准备 将电视和电脑接入同一个路由器 下载智能电视解放工具并解压 获取电视的IP地址 电视的IP地址一般可以通过点击设置-网络设置来获得，是一个形如192.168.1.105的数字串 连接电视 打开TCPUDP调试工具文件夹中的点我执行.exe 点击创建连接 类型选择TCP 目标IP填写刚才获取到的电视IP地址 端口填写8090 其他的不用修改 确认填写正确后，点击创建 点击连接 如果没有出现问题，软件的界面将会变成下图式样： 清除上面的发送框中所有文字并输入start adbd，然后点击发送 如果如图，在下面的接受框中出现了ok，说明已经连接成功了~ 安装应用 将所有需要安装的APK文件都放到一键安装软件文件夹中 点击双击运行一键安装.bat，按照提示输入IP地址并回车，如图： 等到提示安装成功后，你就已经成功地在电视上安装上了想要的APP了~ 一键工具 方便快捷，但是会在电视上安装辅助工具 这个工具名为TV盒子助手，官方网址为： http://www.cnhezi.com/ 本质上，这个工具就是将前面的教程打包起来制作而成的，但是它会在电视上安装一个辅助工具，比较奇怪。 推荐应用 腾讯视频TV版 CIBN合一影视内容提供方：优酷 银河·奇异果内容提供方：爱奇艺 附言 理论上来说，所有的安卓应用都可以进行安装。但是由于电视操控上的特殊性，没有对电视进行适配的应用非常难以使用，故不推荐进行安装。 大部分智能电视的内存都比较小，故不能同时运行太多软件，所以建议打开应用前先退出别的应用否则容易出现卡顿现象。 原本能用的APP现在不能用了是因为广电总局全面封杀了电视盒子，一大批应用都被下架了，而且要求禁止提供APP安装功能。 更新日志 2016年02月04日 初次发布","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"如何识别真假链接？","slug":"how-to-differ-invalid-link","date":"2016-01-13T01:18:51.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2016/01/13/how-to-differ-invalid-link/","link":"","permalink":"https://xuanwo.org/2016/01/13/how-to-differ-invalid-link/","excerpt":"前言前两天我的朋友圈被微信公开课活动的链接+截图刷屏，随后一大帮“业内人士”站出来说这个是盗号连接，只要点开，微信钱包和支付宝就会被盗。作为半个业内人士，我不能忍了，决定跟大家谈一谈如何识别真假链接。","text":"前言前两天我的朋友圈被微信公开课活动的链接+截图刷屏，随后一大帮“业内人士”站出来说这个是盗号连接，只要点开，微信钱包和支付宝就会被盗。作为半个业内人士，我不能忍了，决定跟大家谈一谈如何识别真假链接。 域名是什么？首先我们来介绍一下域名：域名就是计算机在网络上的名字，免去人们需要记忆IP地址的困扰。域名由若干个英文字母和数字组成，由.分割成几份，形成一个网络上唯一的访问地址。 以https://support.weixin.qq.com为例： support.weixin.qq.com为三级域名 weixin.qq.com为二级域名 qq.com为一级域名 .com是顶级域名后缀 链接是什么？然后我们来介绍一下链接，也就是URL，全称为统一资源定位符，我们也称它们为网址。链接的标准格式一般如下： 协议类型://服务器地址（必要时需加上端口号）/路径/文件名 协议类型：常用的有http，https，ftp等 https意味着什么？https又叫做超文本传输安全协议，使用这个协议意味着你与这个网页的所有交互都是加密的，任何第三方都无法窥探你传输的信息（相对而言的，世上没有绝对的安全），经常被用于万维网上的交易支付和企业信息系统中敏感信息的传输。 服务器地址：一般都是域名，有时为IP地址 端口号：http预设的80端口以及https的443端口可以省略 路径：以“/”字元区别路径中的每一个目录名称 查询：GET模式的表单参数，以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题 如何分析一个链接？比如说我们这次微信公开课活动的链接： https://support.weixin.qq.com/cgi-bin/xxxxxxxx 对于用户而言，有用的信息如下：协议采用https协议，域名为support.weixin.qq.com。采用https协议意味着你的信息是受到保护的，即使你使用了公共的wifi，同一wifi下的可能存在着的黑客也无法窥探你的私人信息。域名support.weixin.qq.com传递了如下信息，这个网页是归属于qq.com的，这从源头上保证了这一网页的安全性（如果腾讯没有内鬼的话）。 下面我们来看看一个假的链接是怎么样的： 亲爱的淘宝用户您好，恭喜您在本次活动中获得特等奖iPhone6s一部，请登陆 http://www.taoba0.com 领取您的奖品。 这是一条诈骗短信，我们可以看到骗子给出了这样一个链接http://www.taoba0.com，一定要看清楚是taoba0而不是taobao，然后你就应该明白，这是一条诈骗短信了。值得提醒的是，现在前端技术高度发达，克隆复制一个网页非常容易，所以在网站之间挑战时，一定要确认自己点击的链接是正确的链接，否则极有可能被相似的页面欺骗。 如何保证安全？从上一个链接的分析中，我们可以得出以下几个小技巧： 尽可能地使用https协议进行访问 认清域名，不轻信非官方域名的页面 网站之间跳转时，确认自己点击的链接是否正确 最后的寄语 请开启两部验证。国外的账户大多支持Google的两部验证，请启用这一功能。国内的账户的话，QQ请打开设备锁，QQ邮箱请打开独立密码。 不要贪小便宜！不要贪小便宜！！不要贪小便宜！！！重要的事情说三遍。 参考资料 域名-维基百科 统一资源定位符-维基百科 更新日志 2016年1月13日 首次发布 2016年1月14日 更新了域名相关知识","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"科普","slug":"科普","permalink":"https://xuanwo.org/tags/科普/"}]},{"title":"VS2015连接Oracle数据库","slug":"vs-oracle-11g","date":"2016-01-03T15:31:32.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2016/01/03/vs-oracle-11g/","link":"","permalink":"https://xuanwo.org/2016/01/03/vs-oracle-11g/","excerpt":"开发环境宿主机：Win10 + VS2015 + ODP.Net for VS2015虚拟机：Win7 + Oracle 11g + 桥接","text":"开发环境宿主机：Win10 + VS2015 + ODP.Net for VS2015虚拟机：Win7 + Oracle 11g + 桥接 配置ODP.Net首先下载 Oracle Developer Tools for Visual Studio 2015 ，下载此文件需要注册Oracle社区账号并接受相关的协议，此文件提供了以下组件： Oracle Developer Tools for Visual Studio 12.1.0.2.4 Oracle Data Provider for .NET 4 12.1.0.2.0 Oracle Providers for ASP.NET 4 12.1.0.2.0 下载完成后运行MSI安装程序进行安装，安装完成后会自动注册VS2015的相关插件，重新启动VS2015后将会看到Oracle的相关命令，比如SQL *PLUS支持等。同时添加数据库时也能看到相应的选项。 ODP.Net支持所有Oracle版本，因此下载时只需要注意VS的版本即可。 配置tnsnames.ora ODP.Net默认使用安装目录下的tnsnames.ora，若安装目录在Program Files下，可能会遇到无权限等问题，此时使用管理员权限打开命令行，切换到对应目录并使用notepad编辑。 复制服务器端的tnsnames.ora文件内容，或者自己手动编辑，格式如下： &lt;数据源别名&gt; = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = &lt;主机名或IP&gt;)(PORT = &lt;端口号&gt;)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = &lt;数据库服务名&gt;) ) ) 添加数据库打开工具-连接到数据库，数据源修改为Oracle数据库下的ODP.NET,托管驱动程序，然后点击确定，打开添加连接窗口。填写用户名，密码并选择数据源，然后测试连接，成功的话说明已经连通，点击确定即可。 使用虚拟机搭建数据库的额外Tips根据某网友分析，Oracle的监听器在通过1521端口连接后，会开启另外一个新的随机端口进行数据通讯，因此使用NAT方式虚拟网卡可能会导致连接失败。这种情况下，请使用桥接方式虚拟网卡，并在net manager中将loaclhost修改为虚拟机当前的IP。重启监听服务后，再试。 连接数据库并使用连接数据库Dim oradb As String = \"User ID=system;Password=123456;Data Source=lol\"Dim conn As New OracleConnection(oradb)conn.Open()Dim sql As String = \"create table xxx\"Dim sqlCom As New OracleCommandsqlCom.CommandText = sqlsqlCom.Connection = connsqlCom.ExecuteNonQuery() 查询数据成功配置数据源之后，只需要向界面上拖动DataGridView，并进行相关配置，选择自己需要的表即可。 插入图片的正确姿势图片作为二进制数据无法直接拼凑出SQL命令，我们需要使用OracleCommand自带的Parameters功能。在SQL命令中用:photo来代表一个参量，然后使用 sqlCom.Parameters.Add(\"photo\", OracleDbType.Blob, imgData.Length) 来分别指定这个参量的类型和所占空间大小 最后使用 sqlCom.Parameters(0).Value = imgData 来指定这个参量的值。 整个插入图片过程的代码如下： Dim conn As New OracleConnection(oradb)Dim imgData(0) As ByteDim ms As New System.IO.MemoryStreamPictureBox1.BackgroundImage.Save(ms, PictureBox1.BackgroundImage.RawFormat)ReDim imgData(ms.Length - 1)ms.Read(imgData, 0, ms.Length)ms.Close()conn.Open()Dim sql As String = \"insert into hero values\" &amp; \"(\" &amp; TextBox1.Text &amp; \":photo\" &amp; \")\"Dim sqlCom As New OracleCommandsqlCom.CommandText = sqlsqlCom.Connection = connsqlCom.Parameters.Add(\"photo\", OracleDbType.Blob, imgData.Length)sqlCom.Parameters(0).Value = imgDatasqlCom.ExecuteNonQuery() 常见错误column not allowed here数据类型不符，检查对应项目数据类型是否正确。 missing comma命令格式不对，检查一下自己的SQL命令是否有错误，特别是在有字符串的时候，需要使用&quot;&quot;来代表一个字符串中的&quot;。 identifier is too long标识符过长（不得超过30字符），不是非常明白原因，不过我取消掉insert命令中指定位置的部分之后，这个错误消失了。 missing INTO keyword缺少into关键字（手滑打成了inte），检查一下自己的SQL命令是否有错误。 cannot insert NULL into (“SYSTEM”.”HERO”.”HEROCATEGORYID”)这些项都指定了非0值，故不能不赋值，为对应项目赋值即可。 更新日志 2016年01月03日 初步完成","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://xuanwo.org/tags/Database/"},{"name":"Oracle","slug":"Oracle","permalink":"https://xuanwo.org/tags/Oracle/"},{"name":"VB","slug":"VB","permalink":"https://xuanwo.org/tags/VB/"}]},{"title":"最佳跨平台PDF阅读解决方案","slug":"best-pdf-read-solution","date":"2015-12-23T16:15:20.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/12/23/best-pdf-read-solution/","link":"","permalink":"https://xuanwo.org/2015/12/23/best-pdf-read-solution/","excerpt":"前言最近因为学习需要，要大量阅读纯文字的PDF文档。然后我惊讶地发现市场上居然没有哪家提供一套完整可用的跨平台PDF阅读解决方案，于是我在尝试了市面几乎所有叫得上名字的各类阅读器之后，形成了一套自己的跨平台PDF阅读解决方案。本文记录了这套方案的详细内容，希望会有所益处。","text":"前言最近因为学习需要，要大量阅读纯文字的PDF文档。然后我惊讶地发现市场上居然没有哪家提供一套完整可用的跨平台PDF阅读解决方案，于是我在尝试了市面几乎所有叫得上名字的各类阅读器之后，形成了一套自己的跨平台PDF阅读解决方案。本文记录了这套方案的详细内容，希望会有所益处。 目标 跨平台（目前支持Windows和Android） 阅读记录同步 支持标准PDF的批注和高亮等功能 对PDF文件管理方便 思路标准PDF的批注和高亮功能是内嵌在PDF文件中的，只要同步了PDF文件，也就同步了所有在PDF文件上的批注和高亮。因此这个问题很大程度上就变成了解决跨平台文件双向同步问题。 跨平台双向同步在很多人看来是一个已经被Dropbox以及Google Drive解决了问题，但是实际上，它们在PC和移动端的行为是不一样的。PC端是完整的双向同步，而在移动端，为了节省流量和空间，它们都是提供了一个File list，你必须要自己下载指定文件。不仅如此，这个下载下来的文件大多是Read-Only的，用阅读器批注之后，你会发现这个文件无法保存，这样的话，PDF跨平台批注就无从谈起。 解决方案按照上面思路中的讨论，我在每一个平台上的解决方案都分成两个部分，第一是解决PDF阅读、批注问题，第二是解决PDF文件双向同步问题。 WindowsGoodsyncGoodsync是一款非常强大的同步工具，我们通过它来提供本地到Google Drive的双向同步功能。 如果通过SS艹墙，配置Google Drive时请勾选基于WinInet，如图： Foxit ReaderFoxit Reader，也就是福昕阅读器，不多说了，新版的界面还是可以的。（尽管我觉得颜值没有Adobe Reader DC高） 为什么不选Adobe？Adobe最新版本的批注功能在特定的PDF上好像有点问题，我尝试了几个都不能正常保存，总是提示错误110，无奈放弃。 AndroidFlodersyncFlodersync是一款基于安卓平台的非常棒的一款应用，我们通过它来实现安卓平台的双向同步。 开启双向同步请取消勾选不同步删除 Moon+Moon+，静读天下，安卓平台上首屈一指的阅读器，支持格式众多，速度流畅，除了免费版有些功能阉割和广告之外，没有别的问题。 更新日志 2015年12月23日 初始发布","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Read","slug":"Read","permalink":"https://xuanwo.org/tags/Read/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Windows","slug":"Windows","permalink":"https://xuanwo.org/tags/Windows/"},{"name":"Android","slug":"Android","permalink":"https://xuanwo.org/tags/Android/"}]},{"title":"在线视频下载完整解决方案","slug":"online-video-download-solution","date":"2015-12-18T12:49:49.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/12/18/online-video-download-solution/","link":"","permalink":"https://xuanwo.org/2015/12/18/online-video-download-solution/","excerpt":"前言因为学习需要，产生了一个这样的需求：要从Youtube上批量下载视频。自然，出于方便使用的角度来看，音画不能分离，最好带有对应的字幕。一番搜罗之后，我找到了基于Python的开源产品： youtube-dl 值得一提的是，youtube-dl不仅仅能下载youtube上的视频，它支持的视频链接种类多达700+种，几乎囊括了所有在线视频网站，列表参见此处。让我不由得感慨开源的力量。除此以外，某些不存在的网址需要自备梯子，不再赘述。","text":"前言因为学习需要，产生了一个这样的需求：要从Youtube上批量下载视频。自然，出于方便使用的角度来看，音画不能分离，最好带有对应的字幕。一番搜罗之后，我找到了基于Python的开源产品： youtube-dl 值得一提的是，youtube-dl不仅仅能下载youtube上的视频，它支持的视频链接种类多达700+种，几乎囊括了所有在线视频网站，列表参见此处。让我不由得感慨开源的力量。除此以外，某些不存在的网址需要自备梯子，不再赘述。 获取 checked on 2015-12-18 WindowsWindows用户可以使用已经打包好的可执行程序：下载链接 UNIX like类UNIX系统的用户可以使用curl或者wget来获取可执行文件 curlsudo curl https://yt-dl.org/downloads/2015.12.13/youtube-dl -o /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl wgetsudo wget https://yt-dl.org/downloads/2015.12.13/youtube-dl -O /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl HomebrewHomebrew用户可以使用如下命令进行安装：brew install youtube-dl pip同样的，你也可以使用pip来安装它。sudo pip install --upgrade youtube_dl Source自然，你可以选择下载源代码以及docs，链接见此 使用简易最简单的方式就是直接加上视频链接地址就可以自动下载到当前文件夹：youtube-dl.exe url 使用代理以常见的ss代理为例：youtube-dl.exe url --proxy http://127.0.0.1:1080 有一个坑点在于这个参数只支持HTTP/HTTPS代理，所以本地跑SS的话，需要在前面加上一个HTTP的前缀，否则代理不会正常工作。 下载列表以Youtube Playlist为例：youtube-dl.exe --yes-playlist https://www.youtube.com/playlist?list=PLZlv_N0_O1gZg3dTMetmsfm_s4lb4-Tg0 --proxy http://127.0.0.1:1080 下载字幕以Youtube Playlist为例，自动生成字幕并指定下载中文和英文字幕：youtube-dl.exe --yes-playlist https://www.youtube.com/playlist?list=PLZlv_N0_O1gZg3dTMetmsfm_s4lb4-Tg0 --proxy http://127.0.0.1:1080 --write-auto-sub --sub-lang en,cn 字幕相关设定：--write-sub 写字幕文件--write-auto-sub 写入自动生成的字幕文件 (YouTube only)--all-subs 下载所有可提供的字幕--list-subs 列出当前视频支持的所有字幕--sub-format FORMAT 指定字幕格式，比如 \"srt\" 或者 \"ass/srt/best\"--sub-lang LANGS 指定字幕语言，用`,`分隔, 使用 IETF 语言标记，比如 'en,pt' IETF语言标记参见此处 更新日志 2015年12月18日 首次发布","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Video","slug":"Video","permalink":"https://xuanwo.org/tags/Video/"}]},{"title":"断电也能上网！——路由器改造记","slug":"surf-with-poweroff","date":"2015-11-27T01:34:33.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/11/27/surf-with-poweroff/","link":"","permalink":"https://xuanwo.org/2015/11/27/surf-with-poweroff/","excerpt":"介绍前两天我对我们宿舍的路由器进行了小小的改造，使得我们在断电之后也能照常上网。原理非常简单：就是使用充电宝来给路由器供电——因为我们墙上的网口是不会断电的，所以只要解决了路由器没有电的问题，就可以解决断网问题。路由器要求的输入电压为5V，电流为0.3A，恰好跟我们常用的充电宝是一致的，淘宝买一根USB转DV线成功解决问题。","text":"介绍前两天我对我们宿舍的路由器进行了小小的改造，使得我们在断电之后也能照常上网。原理非常简单：就是使用充电宝来给路由器供电——因为我们墙上的网口是不会断电的，所以只要解决了路由器没有电的问题，就可以解决断网问题。路由器要求的输入电压为5V，电流为0.3A，恰好跟我们常用的充电宝是一致的，淘宝买一根USB转DV线成功解决问题。 供电方案我们宿舍现在的路由器供电方案是这样的： 充电器（A型USB接口） ||充电宝（Micro B型USB接口） |内部电路|充电宝（A型USB接口） ||路由器（DV接口） 达成效果现在达成的效果是： 白天：充电器给充电宝充电，充电宝起到了稳流的作用 晚上：充电宝为路由器供电 优点自动循环，自动切换（切换的速度很快，撸啊撸都不会掉线哦~） 缺点充电宝损耗大，不知道我这个已经用了一年的充电宝能坚持多久= = 硬件要求 主流充电宝的电压均为5V1A，有部分充电宝为iPad提供了2A的输出接口，加上充电宝自动限流的功能，所有充电宝这一部分问题不大。路由器很显然必须为5V，如果是12V的路由器还需要另外购买升压模块，电流问题不大，充电宝基本都带得动。 辟谣用充电宝网速是不是会变慢？实测： 不会相反的，由于断电之后同时上网的设备数量减少，在延时，最高速率等参数上还有着更加优秀的表现。 用充电宝会导致无法链接Wifi？舍友反馈的，我只说一句： 不要相信玄学。路由器换一种供电方式会影响到你电脑上的无线网卡的信号发送？这种说法，我肯定是不相信的- -。 更新日志 2015年11月27日 完成初稿","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[{"name":"Hardware","slug":"Hardware","permalink":"https://xuanwo.org/tags/Hardware/"}]},{"title":"文本转换神器——Pandoc","slug":"pandoc","date":"2015-11-14T14:29:18.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/11/14/pandoc/","link":"","permalink":"https://xuanwo.org/2015/11/14/pandoc/","excerpt":"介绍Pandoc是一个用haskell编写的文本转换工具，小巧迅速且支持格式广泛，堪称文本转换应用的瑞士军刀。","text":"介绍Pandoc是一个用haskell编写的文本转换工具，小巧迅速且支持格式广泛，堪称文本转换应用的瑞士军刀。 支持格式输入 markdown reStructuredText textile HTML DocBook LaTeX MediaWiki markup TWiki markup OPML Emacs Org-Mode Txt2Tags Microsoft Word docx LibreOffice ODT EPUB Haddock markup 输出 HTML格式: XHTML, HTML5, 和 HTML slide shows usingSlidy,reveal.js,Slideous,S5, 或DZSlides. 字处理格式: Microsoft Worddocx,OpenOffice/LibreOfficeODT, OpenDocumentXML 电子书: EPUB version 2或3,FictionBook2 文档格式: DocBook, GNUTexInfo, Groffman pages, Haddockmarkup 页面布局格式: InDesignICML 大纲格式: OPML TeX 格式: LaTeX,ConTeXt, LaTeX Beamer slides PDF viaLaTeX 轻量级标记格式:Markdown (includingCommonMark),reStructuredText,AsciiDoc, MediaWikimarkup, DokuWikimarkup, EmacsOrg-Mode,Textile 自定义格式: custom writers can be written inlua. 安装安装Pandoc在此页面上寻找对应平台的二进制安装包 Windows平台需要将Pandoc加入Path目录才能在cmd环境中调用 安装Tex支持（可选，用于编译Tex并输出PDF） Windows平台建议MiKTeX MacOS平台建议BasicTeX并使用tlmgr工具安装需要的包 Linux平台建议Tex Live 使用你可以使用在线的DEMO pandoc x.html -o x.mdpandoc -f html -t markdown http://www.fsf.org -f参数用于指定源文件格式 -t参数用于指定输出文件格式 -o参数用于指定输出文件 如果不使用-f和-t参数，pandoc将会根据输入文件以及-o指定的输出文件格式来确定转换的格式类型 注意事项 Pandoc不支持.doc格式，如果需要进行转换，则需要先将.doc转换为.docx 引用资源 Pandoc官网 需要梯子 Pandoc User Guide 黑魔法利器pandoc Markdown写作进阶：Pandoc入门浅谈 更新日志 2015年11月14日 完成初步使用","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"Python包分发详解","slug":"python-packages","date":"2015-11-03T15:24:06.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/11/03/python-packages/","link":"","permalink":"https://xuanwo.org/2015/11/03/python-packages/","excerpt":"前言用Python写过不少的脚本，现在要把脚本打包成模块并进行发布，然后才明白脚本Boy到正规的码农差距有多大= =。踩了很多天的坑之后，自己学习到了Python的包分发机制，以及如何利用Pypi向全世界分发自己的模块。现在简单地做一些整理。","text":"前言用Python写过不少的脚本，现在要把脚本打包成模块并进行发布，然后才明白脚本Boy到正规的码农差距有多大= =。踩了很多天的坑之后，自己学习到了Python的包分发机制，以及如何利用Pypi向全世界分发自己的模块。现在简单地做一些整理。 Python包机制 包是一个模块或模块/子模块的集合，一般情况下被压缩到一个压缩包中。其中包含 依赖信息 将文件拷贝到标准的包搜索路径的指令。 编译指令(如果在安装前代码必须被编译的话)。 也就是说，为了分发模块，我们需要把模块的依赖信息和模块一起打包。在Python中，这个打包好的可分发的文件一般以.egg结尾，其作用可以理解为java中的jar。Python的包管理以及分发曾经经历过非常混乱的一段时期，但是如今已经基本稳定（或者说，流行？）为两个套件： 打包&amp;分发：Setuptools 安装&amp;管理：pip 准备工作注册Pypi Pypi - the Python Package IndexPypi是Python语言包的仓库，全世界所有开源Python开发者都会在Pypi上提交&amp;下载软件包 为了我们后续的提交操作，我们需要首先注册一个Pypi的账号，注册非常简单，提供用户名，密码以及邮箱，经过验证之后就注册完成了。 目录结构Python没有严格的工程目录要求，只要有__init__.py在的地方，就会被认为是一个Python的包。但是出于方便协作考虑，可以把自己的源代码与各种脚本分开存放。具体的结构可以学习Github上比较流行的Python项目，选择自己喜欢的即可。 环境配置首先你需要有pip，pip自从3.4版本开始已经随python内置发布，如果使用的版本比较低，可以自己手动进行安装： sudo apt-get install python-pip 然后我们需要安装setuptools： pip install setuptools 编写安装脚本准备工作就绪之后，我们就可以开始编写安装脚本了。 填写配置信息基本框架from setuptools import setup, find_packages # 引入setuptools包setup( option = values, # 本质上是一个函数的参数，分行写便于维护) 参数介绍指定整个包指定单独模块依赖关系包内数据其他数据Meta-Data Meta-Data 描述值 name 包名 version 此次发布版本 author 作者名 author_email 作者邮箱 maintainer 维护者名 maintainer_email 维护者邮箱 url 主页 description 简要描述 long_description 详细描述 download_url 下载地址 classifiers 分类，参见此处 platforms 平台列表 license 授权协议 典型配置from setuptools import setup, find_packagessetup( name = \"HelloWorld\", version = \"0.1\", packages = find_packages(), scripts = ['say_hello.py'], # Project uses reStructuredText, so ensure that the docutils get # installed or upgraded on the target machine install_requires = ['docutils&gt;=0.3'], package_data = &#123; # If any package contains *.txt or *.rst files, include them: '': ['*.txt', '*.rst'], # And include any *.msg files found in the 'hello' package, too: 'hello': ['*.msg'], &#125;, # metadata for upload to PyPI author = \"Me\", author_email = \"me@example.com\", description = \"This is an Example Package\", license = \"PSF\", keywords = \"hello world example examples\", url = \"http://example.com/HelloWorld/\", # project home page, if any # could also include long_description, download_url, classifiers, etc.) 打包 这个坑踩了很久- -，没有老司机的带的痛苦与开发环境不同的时候，当用户运行你的包时，使用open等命令是以当前目录为根运行的，所以你必须指定数据所在位置，否则会出现IOError甚至更糟糕的情况 指定需要分发的文件自动处理 当没有MANIFEST.in文件时，Setuptools将会按照下面的原则处理文件： 所有py_modules和packages选项包含的Python源文件 所有ext_modules或libraries选项指定的C源文件 scripts指定的脚本（参见Installing Scripts） 形如test/test*.py的文件 README.txt（或README），setup.py和setup.cfg 符合package_data选项的所有文件（参见Installing Package Data） 符合data_files选项的所有文件（参见Installing Additional Files） 翻译自Python官方文档 Specifying the files to distribute 手动处理 一般而言，自动处理已经足够，但是如果想要自己指定的话，则需要编辑MANIFEST.in模板文件。MANIFEST.in模板文件很简单，每一行都导入或者导出表示符合正则的一类文件。比如说： # 导入根目录下满足*.txt的文件include *.txt# 递归导入examples目录下满足*.txt和*.py的文件recursive-include examples *.txt *.py# 导入满足examples/sample?/build的文件夹下所有文件prune examples/sample?/build 详细语法参见此处 注意：当根目录下存在MANIFEST.in文件时，Setuptools将不会再采用自动处理的设定，因此需要在MANIFEST.in文件中指明所有需要导入的文件。 调用数据当你需要调用Python包中的文件时，你可以使用下面的方法： from pkg_resources import resource_stringdata = resource_string(__name__, 'data.dat') 此时，指定的data.dat文件将会以二进制文件流的形式赋值到data变量中，你可以按照自己的需要进行进一步处理。比如说： from pkg_resources import resource_string data = resource_string(__name__, &apos;example.yml&apos;) with open(&apos;config.yml&apos;, &apos;w&apos;) as f: f.write(str(data, encoding=&apos;utf-8&apos;)) f.close() 上述代码实现了从example.yml中读取数据并保存到config.yml文件中。 创建源码分发包在包的根目录下执行： python setup.py sdist 默认情况下，sdist命令将会为Unix创建gzip压缩文件，为Windows创建zip压缩文件你也可以添加参数--formats=zip指定生成的文件类型，所有支持的参数见此处 源码分发似乎不会导入package_data中指定的数据，如果上传本分发包可能导致用户通过pip安装的包中没有需要的数据。 创建二进制分发包除了创建源码分发之外，我们还可以创建基于平台的二进制分发包。在包的根目录下执行： python setup.py bdist 默认情况下，这个命令将会创建基于自身平台的分发包。同样的，你也可以添加--format=zip参数来指定生成的文件，支持的参数见此处除此之外，也可以使用以下的命令直接生成对应格式的分发包： 命令 格式 bdist_dumb tar, gztar, bztar, xztar, ztar, zip bdist_rpm rpm, srpm bdist_wininst wininst bdist_msi msi 这一命令无法跨平台， 在Linux上选择制作wininst分发包时会提示缺乏相应的支持。 创建wheel分发包wheel是新出的分发格式，旨在取代egg，你可以通过下列命令进行安装： pip install wheel 然后在包的根目录下执行： python setup.ppy bdist_wheel 上传到Pypi注册包在上传我们的包之前，我们需要首先向Pypi提交包的相关信息。在包的根目录下执行:python setup.py register 没有登陆的话，需要进行登陆；如果已经登陆，直接回车使用默认设置即可。 上传包注册完毕后，我们可以提交我们的包了。在包的根目录下执行：python setup.py sdist bdist_wininst upload 这条命令将会向Pypi提交源码和Win下的安装包，如果需要上传别的包，只要直接写出即可。 参考资料 Python开发生态环境简介 使用Setuptools构建和分发python包 10.8 读取位于包中的数据文件 Creating a Source Distribution Examples 更新日志 2015年11月03日 初步完成 2016年03月30日 修复了部分笔误，添加了一些注释，增加了wheel相关的内容","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://xuanwo.org/tags/Python/"}]},{"title":"在Python中使用JSON","slug":"python-JSON","date":"2015-10-30T23:47:23.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/30/python-JSON/","link":"","permalink":"https://xuanwo.org/2015/10/30/python-JSON/","excerpt":"JSON介绍JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 引用自json.org","text":"JSON介绍JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。 引用自json.org 语法结构JSON只提供了两种结构——字典和数组。也就是说，JSON可以存储一对一或者一对多的键值对关系。 形式对象对象是一个无序的键值对集合。一个对象以{开始，}结束。每个键后跟一个:；键值对之间使用,分隔。 数组数组是值的有序集合，一个键可以对应一个数组。一个数组以[开始，]结束。值之间使用,分隔。 值值可以是双引号括起来的字符串、数值、true、false、 null、对象或者数组。这些结构可以嵌套。 字符串字符串是由双引号包围的任意数量Unicode字符的集合，使用反斜线转义。一个字符即一个单独的字符串。字符串与C/C++中的字符串非常相似，包括常见的各种转义符号。 数值数值与C/C++中的数值非常相似，但没有八进制和十六进制格式。 空白空白符号（包括空格，Tab以及回车）可以加入到任何符号之间，不会影响JSON的含义 Python中的JSON库以Python 3为基准 编码对应类型 Python JSON dict object list, tuple array str string int, float number True true False false None null 函数我们使用JSON库中的dump以及dumps函数来进行JSON编码。dump和dumps各项参数含义基本一致，唯一区别在于dump函数编码产生一个JSON文件流，而dumps编码产生一个JSON字符串。 json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw) obj：编码对象 fp：指定文件流 skipkeys：若skipkeys为真，则非标准类型将会跳过；否则返回TypeError ensure_ascii：若ensure_ascii为真，则输出时将会确保没有非ASCII字符；否则将会原样输出 check_circular：若check_circular为真，则将会检测是否存在循环调用；否则会跳过检测 allow_nan：若allow_nan为真，则将会允许存在空值（无穷大值）；否则会返回ValueError cls：若cls为空值，则使用JSONEncoder；否则使用指定子类进行编码 indent：若indent为空值，则无缩进；否则使用指定值进行缩进 separators：若separators为空值，则使用(&#39;,&#39;, &#39;: &#39;)分隔；否则使用指定的元组进行分隔 default：若default为空值，则使用自带的default方法；否则使用指定值 sort_keys：若sort_keys为真，则输出将会按照键进行排序 示范&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps(['foo', &#123;'bar': ('baz', None, 1.0, 2)&#125;])'[\"foo\", &#123;\"bar\": [\"baz\", null, 1.0, 2]&#125;]'# 排序&gt;&gt;&gt; print(json.dumps(&#123;\"c\": 0, \"b\": 0, \"a\": 0&#125;, sort_keys=True))&#123;\"a\": 0, \"b\": 0, \"c\": 0&#125;# 分隔符&gt;&gt;&gt; json.dumps([1,2,3,&#123;'4': 5, '6': 7&#125;], separators=(',', ':'))'[1,2,3,&#123;\"4\":5,\"6\":7&#125;]'# Unicode输出&gt;&gt;&gt; json.dumps(\"\\u5317\\u4eac\", ensure_ascii=False)'北京' 解码对应类型 JSON Python object dict array list string str number (int) int number (real) float true True false False null None 函数我们使用JSON库中的load以及loads函数来进行JSON解码。load和loads各项参数含义基本一致，唯一区别在于load函数用于解码JSON文件流，而loads用于解码JSON字符串。 json.load(fp, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)json.loads(s, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw) fp：指定文件流 s：指定字符串 encoding：指定字符串编码 cls：若cls为空值，则使用JSONEncoder；否则使用指定子类进行编码 object_hook：若object_hook为空值，对象则返回解码器dict；否则使用自定义类型返回 parse_float：若parse_float为空，则JSON浮点数转换为浮点数；否则转换为指定类型 parse_int：若parse_int为空，则JSON整数转换为整数；否则转换为指定类型 parse_constant若parse_constant为空，则不会处理非法输入；否则抛出异常 object_pairs_hook：若object_pairs_hook为空值，则数组返回解码器dict；否则使用自定义类型返回 示范&gt;&gt;&gt; import json&gt;&gt;&gt; json.loads('[\"foo\", &#123;\"bar\":[\"baz\", null, 1.0, 2]&#125;]')['foo', &#123;'bar': ['baz', None, 1.0, 2]&#125;] 更新日志 2015年10月30日 初步完成","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Python","slug":"Python","permalink":"https://xuanwo.org/tags/Python/"},{"name":"JSON","slug":"JSON","permalink":"https://xuanwo.org/tags/JSON/"}]},{"title":"正则表达式参考手册","slug":"regex","date":"2015-10-29T16:26:47.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/29/regex/","link":"","permalink":"https://xuanwo.org/2015/10/29/regex/","excerpt":"前言一直都知道正则表达式的强大，但是总是觉得正则很难学不会，所以一直不得要领。这次因为工作原因，不得不用到正则，于是顺手将它学了起来。入门之后才发现，花费一点时间学习一下正则非常值得，可以成千上百倍地提升你的工作效率。特别是当你经常和批量数据以及规则文本打交道的时候，你会发现完全离不开正则。闲话到此为止，下面进入正题。","text":"前言一直都知道正则表达式的强大，但是总是觉得正则很难学不会，所以一直不得要领。这次因为工作原因，不得不用到正则，于是顺手将它学了起来。入门之后才发现，花费一点时间学习一下正则非常值得，可以成千上百倍地提升你的工作效率。特别是当你经常和批量数据以及规则文本打交道的时候，你会发现完全离不开正则。闲话到此为止，下面进入正题。 介绍 正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 来自维基百科 语法元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 字符转义如果需要使用元字符本身，你需要使用\\来取消转义. \\\\ 匹配\\ C:\\\\Windows 匹配 C:\\Windows 重复 代码 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 Windows\\d+ 匹配Windows后面跟1个或更多数字 ^\\w+ 匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置) 字符类除了使用元字符意外，我们也可以指定一个字符范围，作为一个字符类： 像[0-9]代表的含意与\\d就是完全一致的：一位数字 [a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话） [abc]表示只匹配abc三个字母中的一个 逻辑判断我们可以使用|来将不同的规则分开匹配分支条件时会从左往右进行匹配，只要满足了某个分支，就不会再考虑之后的。 \\d{5}-\\d{4}|\\d{5} 表示匹配12345-1234或者12345 \\d{5}|\\d{5}-\\d{4} 但如果这样写，12345-1234就只会匹配前面的12345 分组前面讲到了单个字符的重复，如果有多个字符需要重复的话，我们就需要分组——使用(和)。 (\\d{1,3}.){3}\\d{1,3} 表示匹配长得像IP地址的数字串 \\d{1,3}\\.表示一到三位的数字再加上一个点，分组之后再重复三次，然后再加上一个一到三位的数字 反义 代码 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 \\S+ 匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt; 匹配用尖括号括起来的以a开头的字符串。 参考资源 正则表达式30分钟入门教程 searun的博客 跟我学正则表达式系列\\ Python爬虫入门七之正则表达式 | 静觅 更新日志 2015年10月29日 增加了比较简单&amp;常用的使用方法","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"字符串","slug":"字符串","permalink":"https://xuanwo.org/tags/字符串/"}]},{"title":"Hash以及Hash校验工具介绍","slug":"hashsum","date":"2015-10-28T11:14:56.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/28/hashsum/","link":"","permalink":"https://xuanwo.org/2015/10/28/hashsum/","excerpt":"前言前一阵子的Xcodeghost事件给所有人都好好的上了一课——校验的重要性。无论何时，一定要校验！一定要校验！！一定要校验！！！重要的事情重复三遍总是没错的。如果真的无法做到这一点，最起码这些一定要注意： 系统镜像 底层开发工具 选择官方认证的软件源，地址尽可能地使用HTTPS而非HTTP以避免缓存影响","text":"前言前一阵子的Xcodeghost事件给所有人都好好的上了一课——校验的重要性。无论何时，一定要校验！一定要校验！！一定要校验！！！重要的事情重复三遍总是没错的。如果真的无法做到这一点，最起码这些一定要注意： 系统镜像 底层开发工具 选择官方认证的软件源，地址尽可能地使用HTTPS而非HTTP以避免缓存影响 Hash介绍散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用来代表一个短的随机字母和数字组成的字符串。 Checksum介绍校验和（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或者时间（如计算机存储）传送的数据的完整性进行检查的一种简单方法。计算机领域常见的校验和的方法有循环冗余校验（CRC）、MD5、SHA家族等。 Hash校验工具Webhashcalc 基于HTML5HASH修改而来，感谢Stefan Hacker Windowshashcalc LinuxLinux一般都内置了常见的hashsum命令，包括md5sum以及sha家族的ha224sum, sha256sum, sha384sum and sha512sum等。 直接计算md5sum thefile.isosha1sum thefile.iso 与给定的checksum文件比对很多时候下载方都会提供一个checksum文件用来进行比对，这时候我们可以添加一个-c或者--check参数来进行比对 md5sum -c md5.checksum thefile.isosha512sum -c sha512.checksum thefilel.iso Ma OS XMac OS X也内置了和Linux一样的命令，你可以参考Linux进行使用。同时，你也可以选择更加平易近人的应用：哈希码计算器 AndroidHash CheckerHash It! 更新日志 2015年10月28日 完成初稿","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"使用pyQuery解析HTML","slug":"pyquery-intro","date":"2015-10-23T01:03:09.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/23/pyquery-intro/","link":"","permalink":"https://xuanwo.org/2015/10/23/pyquery-intro/","excerpt":"pyQuery介绍pyquery 可以让你用jquery语法来对xml进行查询。这个API和jquery十分类似。如果利用lxml，pyquery对xml和html的操作将更加快速。","text":"pyQuery介绍pyquery 可以让你用jquery语法来对xml进行查询。这个API和jquery十分类似。如果利用lxml，pyquery对xml和html的操作将更加快速。 pyQuery安装 首先，你得有一个python环境，最好是类linux的，因为安装pyquery的过程中需要编译某一个包，在windows上比较难解决依赖问题 安装Python环境sudo apt-get install python python-dev python-pip python 安装python环境 python-dev 安装python开发环境 python-pip 安装pip来进行python包管理 解决pyQuery所需依赖sudo apt-get install libxml2-dev libxslt1-dev libz-dev libxml2-dev和libxslt1-dev是编译lxml所需要的包，缺少会导致编译失败 某些情况下会提示/usr/bin/ld: cannot find -lz，所以需要安装libz-dev 安装pyQuerypip install pyquery 解决了依赖问题之后，就可以进行pyquery的安装了。 有一个坑点是在虚拟机编译lxml的过程中，如果内存过小会导致编译失败。如果出现错误，请把虚拟机的内存调整至1024M或更大。 pyQuery使用最简样例#!/usr/bin/python# -*- coding: UTF-8 -*-from pyquery import PyQuery as pyqhtml = '''&lt;html&gt; &lt;head&gt; &lt;title&gt;这是标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=\"hi\"&gt;Hello&lt;/p&gt; &lt;ul&gt; &lt;li&gt;list1&lt;/li&gt; &lt;div class=\"ha\"&gt; Cool! &lt;/div&gt; &lt;li&gt;list2&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt;'''doc = pyq(html)print doc('title') # 获取 title 标签的源码# &lt;title&gt;这是标题&lt;/title&gt;print doc('title').text() # 获取 title 标签的内容# 这是标题print doc('.ha').text() # 获取 class 为 ha 的标签的内容# Cool!print doc('#hi').text() # 获取 id 为 hi 的标签的内容# Helloprint doc('p:first').text() # 还可以支持伪类li = doc('li') # 处理多个元素for i in li: print pyq(i).text()# list1# list2 指定网址直接访问#!/usr/bin/python# -*- coding: UTF-8 -*-from pyquery import PyQuery as pyqimport urllib# 直接访问并获取相关信息print pyq(url='https://www.google.com') 指定headers#!/usr/bin/python# -*- coding: UTF-8 -*-from pyquery import PyQuery as pyqimport urllib# 以指定headers访问并获取相关信息，好处是不会被某些网站拒绝访问print pyq(url='https://www.google.com', headers=&#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36') 指定文件#!/usr/bin/python# -*- coding: UTF-8 -*-from pyquery import PyQuery as pyqprint pyq(filename=&apos;path/to/html/file&apos;).text() 指定lxml文档#!/usr/bin/python# -*- coding: UTF-8 -*-from pyquery import PyQuery as pyqfrom lxml import etree# pyquery支持etree的APIprint pyq(etree.fromstring(&quot;&lt;html&gt;&lt;/html&gt;&quot;)).text() 参考资料 gawel/pyquery Python使用pyQuery解析HTML内容 error: Setup script exited with error: command ‘x86_64-linux-gnu-gcc’ failed with exit status 1 lxml installation error ubuntu 14.04 (internal compiler error) can’t installing lxml on Ubuntu 12.04 更新日志 2015年10月23日 初步完成","categories":[{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/categories/Develop/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Python","slug":"Python","permalink":"https://xuanwo.org/tags/Python/"},{"name":"HTML","slug":"HTML","permalink":"https://xuanwo.org/tags/HTML/"}]},{"title":"Vagrant——构建虚拟开发环境的新思路","slug":"vagrant-intro","date":"2015-10-22T09:24:57.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/22/vagrant-intro/","link":"","permalink":"https://xuanwo.org/2015/10/22/vagrant-intro/","excerpt":"前言说到虚拟开发环境，人人都觉得好，但是在实际应用中，人们还是在一台电脑上配置所有用到的环境。究其原因，还是因为搭建虚拟开发环境的过程不比在实体机上配置更简单。但是，Vagrant出现了。Vagrant抹平了不同的虚拟化软件的差异，以统一的命令取而代之；抛弃了传统的系统镜像分发安装方式，以直接封装好的虚拟磁盘代替。除此以外，还提供了各种已经封装好的环境下载，搭建一个虚拟开发环境的便利程度有了大幅提高。","text":"前言说到虚拟开发环境，人人都觉得好，但是在实际应用中，人们还是在一台电脑上配置所有用到的环境。究其原因，还是因为搭建虚拟开发环境的过程不比在实体机上配置更简单。但是，Vagrant出现了。Vagrant抹平了不同的虚拟化软件的差异，以统一的命令取而代之；抛弃了传统的系统镜像分发安装方式，以直接封装好的虚拟磁盘代替。除此以外，还提供了各种已经封装好的环境下载，搭建一个虚拟开发环境的便利程度有了大幅提高。 本文主要介绍了Vagrant的配置以及使用，旨在安利这款十分有用的工具，希望能为更多人带来便利 Vagrant介绍Vagrant是一款用来构建虚拟开发环境的工具。对于团队开发而言，可以用来构建一致的开发环境；而对于个人开发而言，则可以方便地搭建不冲突不互相影响的各种开发环境。 Vagrant配置安装Vagrant在此处下载Vagrant。Vagrant主要以二进制安装包形式分发，覆盖了Windows，Mac OS X，DEB以及RPM。均不支持的平台可以自行编译安装，此处不再赘述。 安装ProviderVagrant在本地主要支持两种：VirtualBox ，VMware。我推荐使用小巧且开源的VirtualBox，下载好对应的安装包之后直接安装即可。 配置Path在Windows上使用还需要自行配置Path，否则Vagrant无法调用VirtualBox。在Path中添加Vagrant以及VirtualBox的可执行文件路径即可C:\\HashiCorp\\Vagrant\\bin;C:\\Program Files\\Oracle\\VirtualBox Vagrant初步添加box box介绍在Vagrant中，box是一个打包好了的Vagrant环境，包括特定的系统配置和软件参数。一个box可以在任何支持Vagrant的平台和系统上运行，可以跨平台地提供一致的系统环境，这正是Vagrant的有用之处。 首先在此处下载自己想要的box，然后使用vagrant box add ubuntu\\vivid64 X:\\path\\to\\box来注册一个本地的box以便于后续的使用。 初始化首先使用vagrant init ubuntu/vivid64命令在当前目录下新建一个基于Ubuntu 15.04的配置文件。 此处使用ubuntu 15.04作为演示，更多的box可以在此处下载 启动经过初始化操作后，就可以使用vagrant up启动自己的虚拟机了。默认的情况下，可以使用127.0.0.1:2222来连接虚拟机，你可以非常方便地使用自己喜欢的ssh工具来进行操作。存放着vagrantfile的文件夹会以/vagrant的形式挂载到虚拟机中，你可以毫无障碍的在主机和虚拟机之间传递文件，比如将代码放在此文件夹下，虚拟机就可以直接进行编译并执行，非常酷炫。 Vagrant进阶修改虚拟机默认内存大小VirtualBox的默认内存大小为512MB，在编译某些软件时会因为内存过小导致错误。可以修改Vagrantfile来改变这个参数：config.vm.provider &quot;virtualbox&quot; do |vb|# # Display the VirtualBox GUI when booting the machine# vb.gui = true## # Customize the amount of memory on the VM: vb.memory = &quot;2048&quot;end 修改时需要注意，如果要启用vb.memory这一选项，需要同时取消上面config以及下面的end之前的注释，否则vagrant执行时会因为配置文件格式错误而报错。 更新日志 2015年10月22日 初步完成","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Develop","slug":"Develop","permalink":"https://xuanwo.org/tags/Develop/"}]},{"title":"低成本搭建谷歌镜像","slug":"7ghost-google","date":"2015-10-12T16:53:25.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2015/10/12/7ghost-google/","link":"","permalink":"https://xuanwo.org/2015/10/12/7ghost-google/","excerpt":"前言尽管自己已经搭建好了Shadowsocks等翻墙工具，但是总有一些时刻需要临时地使用Google查看一些网页，这个时候一个可用的谷歌镜像就显得很重要。本文旨在使用低成本方案来搭建一个可用的谷歌镜像服务，用以部分解决这个问题。","text":"前言尽管自己已经搭建好了Shadowsocks等翻墙工具，但是总有一些时刻需要临时地使用Google查看一些网页，这个时候一个可用的谷歌镜像就显得很重要。本文旨在使用低成本方案来搭建一个可用的谷歌镜像服务，用以部分解决这个问题。 条件你需要具备以下条件： 一台支持PHP的境外服务器（主机） 一个可用（未被墙）的域名 如果没有的话，推荐使用Hostinger的免费主机并注册免费一年的.xyz域名。 搭建 以Hostinger为例 下载7ghost程序(墙外，推荐)&amp;(墙内，密码b5te) FTP上传至指定目录 使用域名进行访问 配置 访问http://yourname.xxx/_admin以进行管理 默认密码为123456，可在\\_admin\\data\\config.php中自行修改 在需要代理的网址中填写https://www.google.com/ 点击提交即可 现在可以访问自己的域名测试反代效果了 进阶使用CloudFlare加速 登陆CloudFlare 点击add site 然后修改CloudFlare指定的NS服务器 显示为Actived之后即为配置完成 使用CloudFlare的免费SSL 登陆CloudFlare 点击Crypto选项卡，SSL设置中选择Flexible，等待几个小时后即可 可以选择HSTS（必须保证SSL可用，否则将无法正常访问） 开启全站强制HTTPS 由于反代加上CDN的特殊性，所以无法通过修改.htaccess或者php文件来强制使用HTTPS。不过还是有办法的，可以使用CloudFlare的Page Rules功能。 登陆CloudFlare 切换到Page Rules选项卡 在Add new rule下方的URL pattern中填写http://yourname.xxx/* 选中下方的Always use https 点击Add rule即可 子目录配置 这个是源程序中的一些BUG，好像也跟Google本身页面中的资源引用有关 假定子目录名为sub 登录到管理后台 添加内容替换，查找内容sub/，替换为/ 点击提交即可 注意事项 不建议大规模进行使用，可能会被Google屏蔽或者被GFW干扰 建议使用垃圾域名，万一被BAN也不心疼的那种= = 强烈建议花点时间配置HTTPS 更新日志 2015年10月13日 初步完成 2015年11月05日 增加了修改密码的详细指示 2015年11月29日 增加了子目录的配置","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Google","slug":"Google","permalink":"https://xuanwo.org/tags/Google/"},{"name":"CloudFlare","slug":"CloudFlare","permalink":"https://xuanwo.org/tags/CloudFlare/"},{"name":"FuckWall","slug":"FuckWall","permalink":"https://xuanwo.org/tags/FuckWall/"},{"name":"PHP","slug":"PHP","permalink":"https://xuanwo.org/tags/PHP/"}]},{"title":"我的五样","slug":"my-staff","date":"2015-10-08T11:08:16.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/10/08/my-staff/","link":"","permalink":"https://xuanwo.org/2015/10/08/my-staff/","excerpt":"前言此文用以记录自己用过&amp;在用的各类工具及软件，欢迎推荐","text":"前言此文用以记录自己用过&amp;在用的各类工具及软件，欢迎推荐 PC ThinkPad E531 with Win10 x64 聊天 QQ 微信电脑版 输入法 搜狗拼音输入法 浏览器 Chrome 64bit 下载 迅雷极速版 视频 Potplayer-64 Bits 系统 Xshell Xftp Listary 办公 SumatraPDF XMind 7 Microsoft Office 2016 Evernote 游戏 英雄联盟 龙翼编年史 网络 百度云管家 Shadowsocks Cow 音乐 QQ音乐 编程 Sublime Text 3 Microsoft Visual Studio JetBrains CLion JetBrains PyCharm JetBrains WebStorm JetBrains IDEA Android Studio 解压刻录 WinRAR 迷之工具 HashCalc Git QTranslate Vagrant 更新日志 2015年10月08日 首次发布 2015年11月27日 11月软件更新","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Hardware","slug":"Hardware","permalink":"https://xuanwo.org/tags/Hardware/"}]},{"title":"微信公众平台数据抓取解决方案","slug":"wechat-mp-data-spider","date":"2015-09-30T10:12:58.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2015/09/30/wechat-mp-data-spider/","link":"","permalink":"https://xuanwo.org/2015/09/30/wechat-mp-data-spider/","excerpt":"前言有一个需求是将微信公众平台的数据导出到Excel以进行后续的数据分析。在关注人数等数据上，微信已经提供了Excel导出的接口，但是在图文分析上，尽管有很详细的数据提供，却没有提供一个好的导出接口。所以我需要寻求一个简单的方案来抓取微信公众平台的图文分析数据。 分析图文分析页面是JS加载的，通过后台提交返回数据，然后使用JS渲染生成页面。对着页面分析了一会儿，没有发现比较简单的请求构造方式，但是发现微信给出的数据形式非常有规律，可以采用正则来获取我想要的信息。","text":"前言有一个需求是将微信公众平台的数据导出到Excel以进行后续的数据分析。在关注人数等数据上，微信已经提供了Excel导出的接口，但是在图文分析上，尽管有很详细的数据提供，却没有提供一个好的导出接口。所以我需要寻求一个简单的方案来抓取微信公众平台的图文分析数据。 分析图文分析页面是JS加载的，通过后台提交返回数据，然后使用JS渲染生成页面。对着页面分析了一会儿，没有发现比较简单的请求构造方式，但是发现微信给出的数据形式非常有规律，可以采用正则来获取我想要的信息。 方案适用范围 单页 批量 规则数据 工具 Chrome Sublime Text 3 Excel 2016 流程 使用Chrome访问相关页面，列出公众号指定时段的所有图文消息 Ctrl+A大法，选中所有数据并保存到Sublime中 运用正则批量处理之 导入到Excel 坑点微信公众平台BUG微信公众平台的图文分析的排序规则上有着很明显的BUG，比如按照发表时间排序，但是并不是所有文章都是按照时间排序的。不过这个BUG并不是非常大，输出到Excel之后排序更快更好。除此之外，当选择的时间跨度比较大的时候，还有一定概率会出现错误。这个没有做复现，所以没有进行进一步的分析。 分隔符的选择在本次正则的处理中，我使用了|作为分隔符，但是坑爹之处在于，公众平台的文章标题中，有一部分也使用了|这个符号。导致最后生成的数据中出现了部分标题被分隔为两端的现象，幸好数据不多，自己手动Fix了。 总结经过多次数据抓取的实战，对于前期的分析以及抓取流程已经非常娴熟，但是在后期的数据处理过程中，仍然有着比较大的问题。一个比较明显的问题就是对于数据的特征把握不全面，经常出现所有数据处理完才发现数据中某个特定的值导致批量处理的结果不符合预期。所以以后处理数据时要注意对数据特征的全面把握，不要依赖后期自己的手动Fix。 更新日志 2015年09月30日 完成初稿","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"QingCloud","slug":"QingCloud","permalink":"https://xuanwo.org/tags/QingCloud/"},{"name":"Work","slug":"Work","permalink":"https://xuanwo.org/tags/Work/"},{"name":"爬虫","slug":"爬虫","permalink":"https://xuanwo.org/tags/爬虫/"}]},{"title":"多页批量规则数据抓取解决方案","slug":"multi-page-data-spider","date":"2015-09-24T08:04:13.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/09/24/multi-page-data-spider/","link":"","permalink":"https://xuanwo.org/2015/09/24/multi-page-data-spider/","excerpt":"前言最近完成的一个工作是要抓取某公司的合作伙伴信息，跟上一次的区别在于，这个公司调用了Salesforce之类的第三方CRM服务。合作伙伴的详细信息是需要点开对应的连接之后才可以获得。","text":"前言最近完成的一个工作是要抓取某公司的合作伙伴信息，跟上一次的区别在于，这个公司调用了Salesforce之类的第三方CRM服务。合作伙伴的详细信息是需要点开对应的连接之后才可以获得。 分析毫无疑问，这次的工作难度高了很多。不过还是遵循一样的思路——获取，整理，导入。 获取首先解决获取问题，不难发现每一个合作伙伴的对应详细信息网址都是有规律的，通过传入一个类似于id的参数来获得，也就是说问题转换成如何获取所有合作伙伴的id。通过分析HTML代码可以发现（在F12中查看，而不是直接查看源代码），id出现的位置都有着相当的特征，通过正则即可提取。得到id之后，就可以模仿着构造出对应的请求链接。得到请求链接之后，就可以用各种网络库来下载相关网页了。这一次，我使用了简单粗暴的curl。 整理得到了包含联系方式的文件，我需要从中提取出我需要的信息，自然想到了正则。但是经过多次试错之后发现，正则并不能完美实现我的需求，总是存在部分疏漏。有数据量较大，冗余文本过多，我无法一一排查正则表达式何处出错，故不得不放弃了这一方案。最后实现的思路是通过C++编写相关代码，搜索联系方式前后出现的特征串（比如电话或Phone之类）。 导入数据的导入仍然是通过Excel打开文本的形式导入，不过要处理好号码粘连在一起的部分条目。比如说：开头数字相近的长度为在7到8之间的串，以及一个1开头的长度为11的串。这些处理完毕之后，记得统一一下字体及字号，照顾一下阅读这些数据的人的感受~ 方案适用范围 多页（链接有规律） 批量 规则数据 工具 Chrome curl Sublime Text 3（支持正则表达式） Clion Excel 2016 流程 使用Chrome获得包含合作伙伴id的HTML代码 使用正则获取对应id并构造请求链接 使用curl下载对应的HTML 使用正则提取合作伙伴的联系方式 整理之后导入Excel 坑点想当然的使用正则正则强大是强大，但是如果自己在不了解具体的数据构成方式的时候，错误的随意的使用正则，往往只能得到错误的结果。为了这个坑，我调试了大概有两个小时，铭记在心。 总结这次工作娴熟了很多，对这一类问题已经有了比较系统的思路，区别仅仅是在于如何针对特定的规则改变自己使用工具的方式而已。 更新日志 2015年09月24日 完成初稿","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"QingCloud","slug":"QingCloud","permalink":"https://xuanwo.org/tags/QingCloud/"},{"name":"Work","slug":"Work","permalink":"https://xuanwo.org/tags/Work/"},{"name":"爬虫","slug":"爬虫","permalink":"https://xuanwo.org/tags/爬虫/"}]},{"title":"单页批量规则数据抓取解决方案","slug":"single-page-data-spider","date":"2015-09-22T09:07:22.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/09/22/single-page-data-spider/","link":"","permalink":"https://xuanwo.org/2015/09/22/single-page-data-spider/","excerpt":"前言加入青云后接的第一个活儿是抓取某公司的经销商的全部信息。该公司通过一个动态页面来展示经销商信息，使用后台的POST提交请求数据，并使用JS在页面下方加载请求的经销商信息，而且网址不会发生变化。 分析接到活儿时候还在上课，电脑不在身边，就用手机先看了看页面。每一条数据都不出意外地非常有规律。观察辣个公司的页面源代码，看得头晕脑胀（只有一个萌萌的员工写的一句别删我让我傻乐了一会儿），无收获。没有办法使用BeautifulSoup，也不会用py来模拟用户的操作，我只好另辟蹊径了。","text":"前言加入青云后接的第一个活儿是抓取某公司的经销商的全部信息。该公司通过一个动态页面来展示经销商信息，使用后台的POST提交请求数据，并使用JS在页面下方加载请求的经销商信息，而且网址不会发生变化。 分析接到活儿时候还在上课，电脑不在身边，就用手机先看了看页面。每一条数据都不出意外地非常有规律。观察辣个公司的页面源代码，看得头晕脑胀（只有一个萌萌的员工写的一句别删我让我傻乐了一会儿），无收获。没有办法使用BeautifulSoup，也不会用py来模拟用户的操作，我只好另辟蹊径了。 方案适用范围 单页 批量 规则数据（起码得比较有规则） 工具 Chrome Sublime Text 3 Clion Excel 2016 流程 使用Chrome访问指定页面，列出所有经销商 Ctrl+A，然后Ctrl+C保存到ST3中（是的，你没看错） 使用ST3的查找替换功能处理部分规则文本替换为空格 使用Clion编写C++代码，将部分换行处理为空格 使用Excel的文本导入功能，使用空格作为分隔符，Done 坑点编码需要注意下输入和输出文本中均需使用GB2312(cp936)编码（为什么如此？） 不规范格式辣个公司的部分经销商提供的信息不规范，主要有一下现象： 地址中存在空格（泥煤啊！） 区号和号码之间不使用-分隔 因为Excel会在导入文本时使用行作为行，使用每一个分隔符来区分列。所以这样的不规范信息会导致部分经销商的信息错误，需要手动修复一下。 总结前期的调试和试错工作进行了大概两个小时，最后的实际工作只花了10分钟左右。最后处理了1500+的经销商信息，按照每个经销商需要操作30秒来计算，实际的效率大概提高了5.7倍，自我感觉还是很满意的。不过这次经历也暴露出了我经验不足的缺点：在没有对自己的脚本进行充分测试之后就开始批量处理数据，结果手动处理数据时才发现这些特例数据的量太大，只能推倒重来，浪费了大量时间。 更新日志 2015年09月22日 完成初稿","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"QingCloud","slug":"QingCloud","permalink":"https://xuanwo.org/tags/QingCloud/"},{"name":"Work","slug":"Work","permalink":"https://xuanwo.org/tags/Work/"},{"name":"爬虫","slug":"爬虫","permalink":"https://xuanwo.org/tags/爬虫/"}]},{"title":"译-Ubuntu下五个最好的BT客户端","slug":"translated-five-best-bt-client-in-ubuntu","date":"2015-09-01T10:54:20.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/09/01/translated-five-best-bt-client-in-ubuntu/","link":"","permalink":"https://xuanwo.org/2015/09/01/translated-five-best-bt-client-in-ubuntu/","excerpt":"本文是我加入LCTT后翻译的第一篇文章，感谢LCTT项目组伙伴们的支持，感谢组长wxy的仔细校对，也欢迎大家加入LCTT项目，共同翻译优质的Linux文章~ 在寻找 Ubuntu 中最好的 BT 客户端吗？事实上，Linux 桌面平台中有许多 BT 客户端，但是它们中的哪些才是最好的 Ubuntu 客户端呢？","text":"本文是我加入LCTT后翻译的第一篇文章，感谢LCTT项目组伙伴们的支持，感谢组长wxy的仔细校对，也欢迎大家加入LCTT项目，共同翻译优质的Linux文章~ 在寻找 Ubuntu 中最好的 BT 客户端吗？事实上，Linux 桌面平台中有许多 BT 客户端，但是它们中的哪些才是最好的 Ubuntu 客户端呢？ 我将会列出 Linux 上最好的五个 BT 客户端，它们都拥有着体积轻盈，功能强大的特点，而且还有令人印象深刻的用户界面。自然，易于安装和使用也是特性之一。 Ubuntu 下最好的 BT 客户端考虑到 Ubuntu 默认安装了 Transmission，所以我将会从这个列表中排除了 Transmission。但是这并不意味着 Transmission 没有资格出现在这个列表中，事实上，Transmission 是一个非常好的BT客户端，这也正是它被包括 Ubuntu 在内的多个发行版默认安装的原因。 Deluge Deluge 被 Lifehacker 评选为 Linux 下最好的 BT 客户端，这说明了 Deluge 是多么的有用。而且，并不仅仅只有 Lifehacker 是 Deluge 的粉丝，纵观多个论坛，你都会发现不少 Deluge 的忠实拥趸。 快速，时尚而直观的界面使得 Deluge 成为 Linux 用户的挚爱。 Deluge 可在 Ubuntu 的仓库中获取，你能够在 Ubuntu 软件中心中安装它，或者使用下面的命令： sudo apt-get install deluge qBittorrent 正如它的名字所暗示的，qBittorrent 是著名的 Bittorrent 应用的 Qt 版本。如果曾经使用过它，你将会看到和 Windows 下的 Bittorrent 相似的界面。同样轻巧并且有着 BT 客户端的所有标准功能， qBittorrent 也可以在 Ubuntu 的默认仓库中找到。 它可以通过 Ubuntu 软件仓库安装，或者使用下面的命令： sudo apt-get install qbittorrent Tixati Tixati 是另一个不错的 Ubuntu 下的 BT 客户端。它有着一个默认的黑暗主题，尽管很多人喜欢，但是我例外。它拥有着一切你能在 BT 客户端中找到的功能。 除此之外，它还有着数据分析的额外功能。你可以在美观的图表中分析流量以及其它数据。 下载 Tixati Vuze Vuze 是许多 Linux 以及 Windows 用户最喜欢的 BT 客户端。除了标准的功能，你可以直接在应用程序中搜索种子，也可以订阅系列片源，这样就无需再去寻找新的片源了，因为你可以在侧边栏中的订阅看到它们。 它还配备了一个视频播放器，可以播放带有字幕的高清视频等等。但是我不认为你会用它来代替那些更好的视频播放器，比如 VLC。 Vuze 可以通过 Ubuntu 软件中心安装或者使用下列命令： sudo apt-get install vuze Frostwire Frostwire 是一个你应该试一下的应用。它不仅仅是一个简单的 BT 客户端，它还可以应用于安卓，你可以用它通过 Wifi 来共享文件。 你可以在应用中搜索种子并且播放他们。除了下载文件，它还可以浏览本地的影音文件，并且将它们有条理的呈现在播放器中。这同样适用于安卓版本。 还有一个特点是：Frostwire 提供了独立音乐人的合法音乐下载。你可以下载并且欣赏它们，免费而且合法。 下载 Frostwire 荣誉奖在 Windows 中，uTorrent（发音：mu torrent）是我最喜欢的 BT 应用。尽管 uTorrent 可以在 Linux 下运行，但是我还是特意忽略了它。因为在 Linux 下使用 uTorrent 不仅困难，而且无法获得完整的应用体验（运行在浏览器中）。 可以在这里阅读 Ubuntu下uTorrent 的安装教程。 快速提示:大多数情况下，BT 应用不会默认自动启动。如果想改变这一行为，请阅读如何管理 Ubuntu 下的自启动程序来学习。 你最喜欢的是什么？这些是我对于 Ubuntu 下最好的 BT 客户端的意见。你最喜欢的是什么呢？请发表评论。也可以查看与本主题相关的Ubuntu 最好的下载管理器。如果使用 Popcorn Time，试试 Popcorn Time 技巧 via: http://itsfoss.com/best-torrent-ubuntu/ 作者：Abhishek译者：Xuanwo校对：wxy 本文由 LCTT 原创翻译，Linux中国 荣誉推出","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xuanwo.org/tags/Linux/"},{"name":"翻译","slug":"翻译","permalink":"https://xuanwo.org/tags/翻译/"}]},{"title":"Bestcoder Round 16 C Revenge of Nim II","slug":"Bestcoder-16-Revenge-of-Nim-II","date":"2015-08-17T02:09:37.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2015/08/17/Bestcoder-16-Revenge-of-Nim-II/","link":"","permalink":"https://xuanwo.org/2015/08/17/Bestcoder-16-Revenge-of-Nim-II/","excerpt":"题目源地址： http://acm.hdu.edu.cn/showproblem.php?pid=5088 理解给你N堆石子，你可以除去其中的某些堆（也可以不除），问你能否使得后手必胜。这是一道看起来像博弈的数学题，因为我们都知道如果想使得后手必胜，就只需要使得每一堆石子数的异或和为0即可。也就是说，我们只需要找出其中的某一些，他们的异或和为0，然后剩下的全都除去。如果能找到，输出Yes；找不到，说明不存在，输出No。","text":"题目源地址： http://acm.hdu.edu.cn/showproblem.php?pid=5088 理解给你N堆石子，你可以除去其中的某些堆（也可以不除），问你能否使得后手必胜。这是一道看起来像博弈的数学题，因为我们都知道如果想使得后手必胜，就只需要使得每一堆石子数的异或和为0即可。也就是说，我们只需要找出其中的某一些，他们的异或和为0，然后剩下的全都除去。如果能找到，输出Yes；找不到，说明不存在，输出No。 又由于异或的性质，我们可以知道在[1,pow(2,n)]中的任意多个数的异或和的情况至多有n种。显然的，如果情况数小于n，根据容斥定理我们可以知道，必定会存在至少两个数的值相等。根据异或的公式a^a=0，我们可以让两个相等的数进行异或，就得到了0，说明存在这样的选择方案。那么这个问题就转变了求n个数的异或和的情况数量。我们可以把每一个数用二进制进行表示，可以发现，两个数异或的过程实际上就是对应二进制位进行消去的过程。我们可以看到，对于每一列，只要有1存在，那么就一定可以对这两个数进行异或，从而使得其中一个对应位置上变为0。也就是说，异或和的情况数量与这个二进制矩阵的秩的大小是等价的。那么问题就转换成了如何求解一个二进制矩阵的秩。分析到了这里，我们不难想到可以运用高斯消元对这个二进制矩阵进行处理。 本题的想法来自我的学长——Sio_Five在具体的实现上，学长很多处理让我觉得非常惊艳。 10^10大概是2^40左右，保险起见开到了65。根据前面我们推出的性质，异或和的情况最多只有65种（其实不可能会有这么多），所以，只要n大于65，一定输出Yes。 在高斯消元的过程中，使用xor来代替先判断再消去，姿势更加优美。 运用右移再&amp;1的方法获取这一位的二进制值，比循环中/=2优雅多了。 代码const int maxn = 1010;const int maxm = 65;int t, n;ll a[maxn];int mat[maxm][maxm];int rnk(int mat[][maxm], int n, int m)&#123; int ret = 0; for (int i = 0, it = 0; i &lt; n &amp;&amp; it &lt; m; ++it) &#123; int pos = -1; for (int j = i; j &lt; n; ++j) &#123; if (mat[j][it]) &#123; pos = j; break; &#125; &#125; if (pos == -1) continue; ++ret; if (pos != i) &#123; for (int j = it; j &lt; m; ++j) &#123; swap(mat[i][j], mat[pos][j]); &#125; &#125; for (int j = 0; j &lt; n; ++j) &#123; if (i != j &amp;&amp; mat[j][it]) &#123; for (int k = it; k &lt; m; ++k) &#123; mat[j][k] ^= mat[i][k]; &#125; &#125; &#125; ++i; &#125; return ret;&#125;int main()&#123; scanf(\"%d\", &amp;t); while (t--) &#123; ll sum = 0; memset(mat, 0, sizeof(mat)); scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%I64d\", &amp;a[i]); sum ^= a[i]; &#125; if (sum == 0 || n &gt; maxm) &#123; printf(\"Yes\\n\"); continue; &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; maxm; ++j) &#123; mat[i][j] = (a[i] &gt;&gt; j) &amp; 1; &#125; &#125; int ret = rnk(mat, n, maxm); if (ret &lt; n) printf(\"Yes\\n\"); else printf(\"No\\n\"); &#125; return 0;&#125; 更新日志 2015年8月17日 已AC","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1594 Ducci Sequence","slug":"UVa-1594-Ducci-Sequence","date":"2015-08-16T04:04:26.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/08/16/UVa-1594-Ducci-Sequence/","link":"","permalink":"https://xuanwo.org/2015/08/16/UVa-1594-Ducci-Sequence/","excerpt":"题目源地址： https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4469 理解题意分析题意十分简单，给定一个序列的变换，每一次都把当前位置上的数变为当前位置与下一个位置差的绝对值。然后问你这个序列最后是变成一个循环还是全都变为0。 暴力做法一开始看题目的时候感觉很难下手，不知道应该怎样去判断这个序列能否构成一个循环。但是注意到另外一个条件——题目中给出了最大的循环次数，1000次。再加上n的值比较小，也就是说，我完全可以暴力模拟一千次，如果还是没有全为0的串的话，这个串一定是一个循环的串。基于这种想法，我可以得到一个非常简单的暴力算法。 Floyd判圈算法概述这道题已经AC了，但是问题并没有结束。回到我最一开始的想法——我该如何判断一个序列是否构成了循环呢？这样，我们就引出了一个算法：Floyd判圈算法。是的，这个Floyd就是那个最短路算法的发明者。这个算法可以在有限状态机，迭代函数或者链表上判断是否存在环，并求出该环的起点和长度的算法。","text":"题目源地址： https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4469 理解题意分析题意十分简单，给定一个序列的变换，每一次都把当前位置上的数变为当前位置与下一个位置差的绝对值。然后问你这个序列最后是变成一个循环还是全都变为0。 暴力做法一开始看题目的时候感觉很难下手，不知道应该怎样去判断这个序列能否构成一个循环。但是注意到另外一个条件——题目中给出了最大的循环次数，1000次。再加上n的值比较小，也就是说，我完全可以暴力模拟一千次，如果还是没有全为0的串的话，这个串一定是一个循环的串。基于这种想法，我可以得到一个非常简单的暴力算法。 Floyd判圈算法概述这道题已经AC了，但是问题并没有结束。回到我最一开始的想法——我该如何判断一个序列是否构成了循环呢？这样，我们就引出了一个算法：Floyd判圈算法。是的，这个Floyd就是那个最短路算法的发明者。这个算法可以在有限状态机，迭代函数或者链表上判断是否存在环，并求出该环的起点和长度的算法。 介绍下面请允许我引用维基百科上对于该算法的介绍：&gt;如果有限状态机、迭代函数或者链表上存在环，那么在某个环上以不同速度前进的2个指针必定会在某个时刻相遇。同时显然地，如果从同一个起点(即使这个起点不在某个环上)同时开始以不同速度前进的2个指针最终相遇，那么可以判定存在一个环，且可以求出2者相遇处所在的环的起点与长度。 实现如果有限状态机、迭代函数或者链表存在环，那么一定存在一个起点可以到达某个环的某处(这个起点也可以在某个环上)。 初始状态下，假设已知某个起点节点为节点S。现设两个指针t和h，将它们均指向S。 接着，同时让t和h往前推进，但是二者的速度不同：t每前进1步，h前进2步。只要二者都可以前进而且没有相遇，就如此保持二者的推进。当h无法前进，即到达某个没有后继的节点时，就可以确定从S出发不会遇到环。反之当t与h再次相遇时，就可以确定从S出发一定会进入某个环，设其为环C。 如果确定了存在某个环，就可以求此环的起点与长度。 上述算法刚判断出存在环C时，显然t和h位于同一节点，设其为节点M。显然，仅需令h不动，而t不断推进，最终又会返回节点M，统计这一次t推进的步数，显然这就是环C的长度。 为了求出环C的起点，只要令h仍均位于节点M，而令t返回起点节点S。随后，同时让t和h往前推进，且保持二者的速度相同：t每前进1步，h前进1步。持续该过程直至t与h再一次相遇，设此次相遇时位于同一节点P，则节点P即为从节点S出发所到达的环C的第一个节点，即环C的一个起点。 伪代码t := &amp;Sh := &amp;S //令指针t和h均指向起点节点S。repeat t := t-&gt;next h := h-&gt;next if h is not NULL //要注意这一判断一般不能省略 h := h-&gt;nextuntil t = h or h = NULLif h != NULL //如果存在环的话 n := 0 repeat //求环的长度 t := t-&gt;next n := n+1 until t = h t := &amp;S //求环的一个起点 while t != h t := t-&gt;next h := h-&gt;next P := *t 本题应用具体到本题中，我只需要将输入的数据分别存入两个数组a和b，然后让a每次操作一次，让b每次操作两次。这样就使得a和b有了不一样的速度，然后每次都进行判断，根据前面讲解的算法，只要a和b相等，那就意味着这个数组一定是循环的。然后再处理一下均为0的情况，这道题的Floyd判圈算法的版本就出来了。 速度更快的Brent判圈算法在维基百科的条目中还提到了一个比Floyd判断算法快36%的Brent判圈算法，不过目前貌似资料不足，所以这个部分就暂时按下不表了。 代码暴力算法const int maxn = 100;int t,n,a[maxn],b[maxn];bool judge()&#123; for(int i=1; i&lt;=n; ++i) &#123; if(a[i]!=0) return false; &#125; return true;&#125;void next()&#123; for(int i=1; i&lt;=n; ++i) &#123; b[i]=abs(a[i]-a[i+1]); &#125; for(int i=1; i&lt;=n; ++i) &#123; a[i]=b[i]; &#125; a[n+1]=a[1];&#125;bool ans;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; ans = false; scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); a[0]=a[n]; a[n+1]=a[1]; for(int k=1; k&lt;=1000; ++k) &#123; if(judge()) &#123; ans=true; break; &#125; else &#123; next(); &#125; &#125; if(!ans) printf(&quot;LOOP\\n&quot;); else printf(&quot;ZERO\\n&quot;); &#125;&#125; Floyd判圈算法const int maxn = 100;int t,n,a[maxn];int b[maxn],c[maxn]= &#123;0&#125;;void next(int a[])&#123; for(int i=1; i&lt;=n; ++i) &#123; a[i]=abs(a[i]-a[i+1]); &#125; a[n+1]=a[1];&#125;bool equal(int a[], int b[])&#123; for(int i=1; i&lt;=n; ++i) &#123; if(a[i]!=b[i]) return false; &#125; return true;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); for(int i=1; i&lt;=n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); b[i]=a[i]; &#125; a[n+1]=b[n+1]=a[1]; bool loop =true; for(int i=0; i&lt;1010; ++i) &#123; next(a); next(b); next(b); if(equal(a,c)) &#123; loop = false; break; &#125; if(equal(a,b)) &#123; loop = true; break; &#125; if(equal(b,c)) &#123; loop = false; break; &#125; &#125; if(loop) printf(&quot;LOOP\\n&quot;); else printf(&quot;ZERO\\n&quot;); &#125;&#125; 更新日志 2015年08月16日 本题已经用两种方法AC","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Markdown + Travis CI 构建自己的开源电子书","slug":"OpenSourceBook","date":"2015-08-12T01:31:22.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2015/08/12/OpenSourceBook/","link":"","permalink":"https://xuanwo.org/2015/08/12/OpenSourceBook/","excerpt":"前言作为一只ACMer，一个非常现实的需求就是我们需要准备自己的模板。在我的想象当中，我们的模板应当有如下的这些特性： 可以生成PDF格式，保证在多个平台下的一致性 编辑起来比较简单，我的队友无需学习LaTeX即可开始编辑 共同协作比较方便，我和队友无需将代码互相复制粘贴 代码必须要支持高亮！（很重要！） 代码编辑容易，因为我们的模板白手起家，经常会需要修改。 这些需求，单个实现都比较容易，但是如果想要找到一个全部符合并且简单易行的方案，就有些困难了。在@larrycai推出的中文开源电子书项目的启发下，我想到了使用 Markdown + Github + Travis CI 的一套工具链来构建了我的开源电子书的方法。下面我来简单地介绍一下。","text":"前言作为一只ACMer，一个非常现实的需求就是我们需要准备自己的模板。在我的想象当中，我们的模板应当有如下的这些特性： 可以生成PDF格式，保证在多个平台下的一致性 编辑起来比较简单，我的队友无需学习LaTeX即可开始编辑 共同协作比较方便，我和队友无需将代码互相复制粘贴 代码必须要支持高亮！（很重要！） 代码编辑容易，因为我们的模板白手起家，经常会需要修改。 这些需求，单个实现都比较容易，但是如果想要找到一个全部符合并且简单易行的方案，就有些困难了。在@larrycai推出的中文开源电子书项目的启发下，我想到了使用 Markdown + Github + Travis CI 的一套工具链来构建了我的开源电子书的方法。下面我来简单地介绍一下。 实现方法我的思路非常简单： 所有文件使用Markdown进行编辑，代码文件以代码块的形式保存在Markdown文件中。 原文件通过Git进行管理，通过Travis CI进行自动构建，并将生成的PDF文件以Release形式回传到Github上 Travis CI调用multimarkdown将md文件转换为tex，再使用latex将tex编译为pdf 整套流程看起来需要的操作很多，但是通过Travis CI进行自动构建，我们需要做的仅仅是push我们的代码，几分钟之后，最新编译的PDF就会出现在我们代码库的Release中。下面我详细地介绍一下实现的步骤。 实现流程Fork我的模板第一步是需要先Fork我的模板，使用git将其clone到本地方便我们进行编辑，当然，库名可以随意修改，这个无需在意。 配置Travis CI登陆Travis CI访问Travis CI，点击使用Github账号登陆后，Travis CI将会获得访问你的公开库相关信息的权限。比较看重自己信息安全的朋友也无需担心，Travis CI默认获得的权限是非常的低的只读权限，而且只能访问你的公开库。然后Travis CI将会列出你所有的公开库，我们在勾选OpenSourceBook前面的按钮使得它打开自动构建。 .travis.yml文件配置上一步中，我们打开了自动构建，也就是你的每一次push和pr都会触发Travis CI的自动构建。但是如果没有配置好的脚本，自动构建的结果通常都是失败的，所以我们要配置好相应的脚本。在我的库中已经有了配置好的脚本，只需要做一些细微的修改就可以应用于不同的库。 Travis CI十分强大，有想进一步了解Travis CI的同学可以通过文档来进一步的学习。 配置Github-Release通过前面的操作，我们已经可以通过Travis CI来自动构建我们的PDF文件，但是这个文件并不能上传到Github上来，因为Travis CI默认是不会取得这样的权限的。为了解决这个问题，我们可以使用Github的Release API以及Travis CI的加密。 首先我们需要一个ruby的环境，如果没有的话可以考虑使用Cloud9。安装travis的gem包 xuanwo@ruby:~/workspace $ gem install travisFetching: addressable-2.3.8.gem (100%)Successfully installed addressable-2.3.8（中间省略）Fetching: travis-1.8.0.gem (100%)Successfully installed travis-1.8.018 gems installed 登陆Travis，需要使用Github的账号和密码。 xuanwo@ruby:~/workspace $ cd OpenSourceBook/xuanwo@ruby:~/workspace/OpenSourceBook (master) $xuanwo@ruby:~/workspace/OpenSourceBook (master) $ travis login --autoShell completion not installed. Would you like to install it now? |y|We need your GitHub login to identify you.This information will not be sent to Travis CI, only to api.github.com.The password will not be displayed.Try running with --github-token or --auto if you don&apos;t want to enter your password anyway.Username: XuanwoPassword for Xuanwo: **********Two-factor authentication code for Xuanwo: 147447Successfully logged in as Xuanwo! 使用Travis的Release-Guide生成相应的脚本代码 xuanwo@ruby:~/workspace/OpenSourceBook (master) $ travis setup releasesDetected repository as Xuanwo/OpenSourceBook, is this correct? |yes|//此处错误表明这个库是新建的，Travis CI还没有同步，手动同步即可。repository not known to https://api.travis-ci.org/: Xuanwo/OpenSourceBookxuanwo@ruby:~/workspace/OpenSourceBook (master) $ travis setup releasesUsername: XuanwoPassword for Xuanwo: **********Two-factor authentication code for Xuanwo: 603930//设定需要上传的文件名File to Upload: OpenSourceBook.pdf//设定只从当前库进行上传Deploy only from Xuanwo/OpenSourceBook? |yes|//设定进行API key加密（强烈要求）Encrypt API key? |yes| 到这里，我们已经实现了一本电子书由Markdown到PDF的自动构建，下面我来具体的讲解一下如何使用。 使用方法触发Release发布由于Github的强制要求，所有发布都必须归属于某一个Tags，所以我们在push的时候，需要带上tags，生成的文件才能够上传到Github上去。具体的操作如下： git add --allgit commit -m &quot;update content&quot;git tag -a v0.0.1 -m &quot;tags content&quot;git push --tagsgit push 文件结构介绍所有的源代码文件都保存在content文件夹下，所有文件都遵循Markdown语法。图片保存在content/img目录下，调用时使用![图片描述](img/pic.png)。每一本书分为前言，内容和目录。其中0-prefaceX-xxx.md表示前言的第X章，1-chapterX-xxx.md表示正文的第X章，2-appendixX-xxx.md表示附录的第X章，都是从1开始的。 目前为止，修改封面还需要修改Tex文件 跳过自动构建只是单纯想更新内容，不想生成PDF时，只需要在commit信息中添加[ci skip]即可。比如 git commit -m &quot;[ci skip] commit message&quot; 更新日志 2015年08月12日 初步完成教程","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://xuanwo.org/tags/Github/"},{"name":"CI","slug":"CI","permalink":"https://xuanwo.org/tags/CI/"},{"name":"Read","slug":"Read","permalink":"https://xuanwo.org/tags/Read/"},{"name":"Markdown","slug":"Markdown","permalink":"https://xuanwo.org/tags/Markdown/"}]},{"title":"史上最详细的虚拟机安装Mac OS X图文教程","slug":"vmware-mac-os-x-intro","date":"2015-08-09T01:30:51.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2015/08/09/vmware-mac-os-x-intro/","link":"","permalink":"https://xuanwo.org/2015/08/09/vmware-mac-os-x-intro/","excerpt":"前言最近在电脑上配置了VMware，想要搭建一个Mac OS X的虚拟机以供体验。不过网上的资料过于老旧，版本更新不及时，导致我在配置的过程中遇到了无数的坑，折腾了一个晚上才配置成功。事后我总结了相关的经验和实践完成了这份教程，希望能够对大家有所益处~ Update:因为要用到Vagrant，所以又捣鼓了一番在VirtualBox上安装Mac OS X，同样踩了不少坑，相关的总结如下。","text":"前言最近在电脑上配置了VMware，想要搭建一个Mac OS X的虚拟机以供体验。不过网上的资料过于老旧，版本更新不及时，导致我在配置的过程中遇到了无数的坑，折腾了一个晚上才配置成功。事后我总结了相关的经验和实践完成了这份教程，希望能够对大家有所益处~ Update:因为要用到Vagrant，所以又捣鼓了一番在VirtualBox上安装Mac OS X，同样踩了不少坑，相关的总结如下。 需要准备的东西懒人包镜像 OS X 10.10 懒人包镜像 密码:a5cq 基于Vmware VMware 11.1.1 Unlocker 基于VirtualBox VirtualBox 虚拟机环境配置配置VMware安装并激活VMware首先自然是安装好VMware，然后是一串奇怪的字符序列：1F04Z-6D111-7Z029-AV0Q4-3AEH8，我也不知道怎么用（&gt;.&lt;）。 使用Unlocker解锁VMware VMware Workstation并不支持Mac OS X的安装，只有VMware Fusion（也就是Mac平台上的VMware）才支持。于是有大神推出了这个解锁补丁，安装好这个补丁之后，VMware便可以支持OS X 的虚拟机安装。 下载并解压Unlocker，右击使用管理员权限打开win-install.cmd，当任务执行完毕后，窗口会自动退出。 这时候再打开VMware，你将会看到Apple Mac OX X的字样，说明你已经成功解锁了Mac OS X的安装功能。 基于Vmware配置Mac OS X虚拟机启动新建虚拟机向导没啥好说的，选择典型。 安装客户机操作系统因为我们还需要一些特别的配置，所以这里我们选择稍后安装操作系统。 选择客户机操作系统这里我们选择Apple Mac OS X，版本就选择最新的OS X 10.10，其实这个版本对我们的安装没啥大的影响，主要是涉及到一些硬件兼容性的问题，无须在意。 命名虚拟机在这里我们需要设定虚拟机的名称以及位置，这里就按照自己的喜好设定吧。 指定磁盘容量这里我们需要指定Mac虚拟机最大占用的空间大小，VMware推荐的是40G，如果空间够的话，可以设置的更大一些。然后下面的设置可以根据自己的喜好来，如果对性能比较注重，可以使用存储为单个文件的方式。 开始创建虚拟机到这里，Mac虚拟机的一些简单设置就已经全部完成了，点击完成，我们进入到下一个阶段。 虚拟机故障排除选择cdr镜像在新弹出的页面中选择编辑虚拟机设置，然后点击CD/DVD(SATA)选择浏览，在弹出的浏览ISO映像中，点击右下角的CD-ROM 映像(.iso)，切换成所有文件，然后就可以正常打开我们的cdr镜像了。 修复无法正常引导即使前面的操作全部正确，我们依然无法正常启动我们的虚拟机。为了可以正常引导，我们还需要修改我们虚拟机的vmx文件。进入我们之前设定的虚拟机位置，在文件夹中可以找到xxxxx.vmx这样的文件，右击选择打开方式，使用记事本打开。在smc.present = &quot;TRUE&quot;后面添加smc.version = 0，保存之后退出，便可以解决。 配置VirtualBox安装VirtualBox安装没有什么坑点，一路Next即可 Hack一下VirtualBoxVirtualBox原生支持Mac OS X的安装，但是只有在系统环境为Mac的环境下，才能正常引导，因为在非Mac环境下，安装程序会检测出我们的CPU不是已经识别的型号，从而拒绝进一步的安装。为此，我们需要执行以下命令来Hack： VBoxManage setextradata \"yourvboxname\" \"VBoxInternal/Devices/smc/0/Config/DeviceKey\" \"ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc\" 如果VBoxManage没有被加入PATH的话，可能会提示VBoxManage不是可执行的命令。只需要进入VirtualBox的安装目录下Shift+右键在当前目录打开命令行执行即可~ 原理非常简单：利用VBox的命令行工具在虚拟机的DeviceKey中加入Apple的声明即可。理论上来讲，这应该是侵犯苹果权益的行为，所以请不要用于商业行为，后果自负~ 开始安装Mac OS X经过如上配置之后，我们终于可以进入到Mac OS X的安装界面了~ 加载界面首先附上酷炫的加载界面，我们什么都不用做，静静地等到它加载完成即可。 语言选择然后是语言选择界面，选择自己喜欢的语言吧，不想折腾自己的话就老老实实简体中文吧~ 硬盘分区安装之前，我们必须要对磁盘进行分区。首先我们点击安装界面最上方的实用工具，然后选择磁盘工具，进入分区管理界面。我们首先点击左侧列出的磁盘，然后在右侧选择分区，空间也不大，选择一个分区即可。可以自己设定这个磁盘的名字，格式化类型默认即可，无需改动。配置完成后，我们点击左上角红色的叉叉退出磁盘工具，点击继续，开始我们的安装。 许可协议作为一家有操守的大公司，该推的锅肯定是要推干净，于是有了这份许可协议。还有一个二次确认，如果拒绝，安装就结束了= =，不过反正是虚拟机，我们一路同意即可。 选择安装磁盘这里我们需要选择前面已经设定好的磁盘，选中之后点击继续即可。 默默等待然后就到了真正的安装过程了，这个过程中我们需要做的只有等待。出去溜达两圈，或者搓一把炉石？ 坑点总结使用DMG镜像提取网上的教程大多是使用DMG镜像提取，需要用到UltraISO这款软件。但是不知道是否为版本差异还是我下载的镜像有问题，我每次试图提取出安装镜像的时候，都出现了进度超过100%，剩余时间为负的情况。尝试了大概四五个镜像以及多个UltraISO版本均宣告失败。 VMX文件修改在VMX文件未修改的情况下，VMware无法正常加载相关的镜像，这也是一个非常恼人的坑点。所以在新建完虚拟机之后一定要记得修改VMX文件，当然也可以被坑了一次之后再来修改，233。 更新日志 2015年08月09日 初步完成教程 2015年10月31日 更换懒人包下载链接，请在页面上直接点击~ 2015年11月02日 加入了VirtualBox的相关配置 2015年11月03日 修复了镜像链接错误，新增了10.11的懒人包镜像 2015年11月09日 镜像下载地址被迅雷抓取了，流量持续血崩，更换为百度云 2015年11月16日 据读者反馈10.11懒人包不可用，已移除 2016年02月26日 由于博主系统已切换至Ununtu Gnome，缺乏进一步维护的条件，故本文不再更新，相关问题也不再进行回复，敬请谅解。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","permalink":"https://xuanwo.org/tags/虚拟化/"},{"name":"Mac","slug":"Mac","permalink":"https://xuanwo.org/tags/Mac/"}]},{"title":"动态规划——最长上升子序列问题","slug":"dp-lis","date":"2015-07-31T15:58:35.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/07/31/dp-lis/","link":"","permalink":"https://xuanwo.org/2015/07/31/dp-lis/","excerpt":"介绍最长上升子序列问题，也就是Longest increasing subsequence，缩写为LIS。是指在一个序列中求长度最长的一个上升子序列的问题，是动态规划中一个相当经典问题。在这里我们可以看到，这个上升实质上就是一个对&lt;进行定义的过程，所以我们求解的其实是一类问题，也就是在给定序列中求解长度最长的符合某一性质的子序列的问题。在下面总结的过程中，我还是以递增为例进行阐述。","text":"介绍最长上升子序列问题，也就是Longest increasing subsequence，缩写为LIS。是指在一个序列中求长度最长的一个上升子序列的问题，是动态规划中一个相当经典问题。在这里我们可以看到，这个上升实质上就是一个对&lt;进行定义的过程，所以我们求解的其实是一类问题，也就是在给定序列中求解长度最长的符合某一性质的子序列的问题。在下面总结的过程中，我还是以递增为例进行阐述。 O(n^2)的动态规划方法dp[i]表示以i结尾的子序列中LIS的长度。然后我用dp[j](0&lt;=j&lt;i)来表示在i之前的LIS的长度。然后我们可以看到，只有当a[i]&gt;a[j]的时候，我们需要进行判断，是否将a[i]加入到dp[j]当中。为了保证我们每次加入都是得到一个最优的LIS，有两点需要注意：第一，每一次，a[i]都应当加入最大的那个dp[j]，保证局部性质最优，也就是我们需要找到max(dp[j](0&lt;=j&lt;i))；第二，每一次加入之后，我们都应当更新dp[j]的值，显然，dp[i]=dp[j]+1。如果写成递推公式，我们可以得到dp[i]=max(dp[j](0&lt;=j&lt;i))+(a[i]&gt;a[j]?1:0)。于是我们就能够得到O(n^2)的动态规划方法的实现： const int MAXN = 1010;int n;int a[MAXN];int dp[MAXN];int lis()&#123; memset(dp, 0, sizeof(dp)); int Max; for (int i = 0; i &lt; n; ++i) &#123; Max = 0; for (int j = 0; j &lt; i; ++j) &#123; if (a[i] &gt; a[j]) &#123; Max = max(Max, dp[j]); &#125; &#125; dp[i] = Max + 1; &#125; Max = 0; for (int i = 0; i &lt; n; ++i) &#123; if (dp[i] &gt; Max) Max = dp[i]; &#125; return Max;&#125; O(nlogn)的动态规划+二分方法在前一种方法中，我们花费了很多时间在寻找最大的dp[j]上。如果有办法让这个dp[j]变成一个递增的序列，我们就能使用二分来进行优化，从而使得复杂度下降为O(nlogn)了。幸运的是，这种方法确实是存在的。我们可以使用dp[i]来保存在前i个数中最大的那个数，很容易可以理解，这个dp[i]已经是单调不减的。接下来的处理其实有些贪心的思想，对于每一个a[i]，我们都在dp数组中寻找比它大的第一个数的下标，不妨设为pos，然后用a[i]来更新dp[pos]。于是我们可以明白，len就应当是max(len, pos+1)。 &gt;在这里我们使用lower_bound函数，这个函数将会返回小于等于val的第一个值的指针，如果不存在就返回end指针。 const int MAXN = 1010;int n;int a[MAXN];int dp[MAXN];int lis()&#123; memset(dp, 0, sizeof(int)*n); int len = 1; dp[0] = a[0]; for (int i = 1; i &lt; n; ++i) &#123; int pos = lower_bound(dp, dp + len, a[i]) - dp; dp[pos] = a[i]; len = max(len, pos + 1); &#125; return len;&#125; 更新日志 2015年07月31日 初步总结","categories":[{"name":"Summary","slug":"Summary","permalink":"https://xuanwo.org/categories/Summary/"}],"tags":[{"name":"C","slug":"C","permalink":"https://xuanwo.org/tags/C/"}]},{"title":"Listary——让文件在指尖流动","slug":"listary","date":"2015-07-28T21:48:32.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/07/28/listary/","link":"","permalink":"https://xuanwo.org/2015/07/28/listary/","excerpt":"前言今天想为大家介绍的是我使用了两年的神器——Listary，作为一款Windows文件浏览增强工具，它为Windows自带的资源管理器添加了很多实用的功能，包括智能命令、最近文档以及收藏功能。与此同时，它还能与很多第三方应用集成，包括鼎鼎大名的Total Commander，还有WinRAR，7zip，FileZilla等等。值得一提的是，Listary由国人Channing开发，默认添加了简体中文支持，是不可多得的精品，典型的墙内开花墙外香的典范。可能是由于国人还并不是非常重视效率这个方面，感觉使用Listary的主要人群还是集中在国外，从Listary的论坛上也能看得出来。所以我完成了这样一篇文章，希望我也能为这样的精品应用在国内的推广做出些贡献。恩？说我是水军？唔，谁说我不是呢？官网上的广告语Keep files at your fingertips被我翻译成了让文件在指尖流动，不知道Channing会怎么想~","text":"前言今天想为大家介绍的是我使用了两年的神器——Listary，作为一款Windows文件浏览增强工具，它为Windows自带的资源管理器添加了很多实用的功能，包括智能命令、最近文档以及收藏功能。与此同时，它还能与很多第三方应用集成，包括鼎鼎大名的Total Commander，还有WinRAR，7zip，FileZilla等等。值得一提的是，Listary由国人Channing开发，默认添加了简体中文支持，是不可多得的精品，典型的墙内开花墙外香的典范。可能是由于国人还并不是非常重视效率这个方面，感觉使用Listary的主要人群还是集中在国外，从Listary的论坛上也能看得出来。所以我完成了这样一篇文章，希望我也能为这样的精品应用在国内的推广做出些贡献。恩？说我是水军？唔，谁说我不是呢？官网上的广告语Keep files at your fingertips被我翻译成了让文件在指尖流动，不知道Channing会怎么想~ 初步使用基础配置如果是第一次安装，Listary会有一个引导教程，建议大家都跟着操作一下。在教程的最后会让你设置一个激活Listary的快捷键，这个快捷键的设置完全可以根据自己的喜好来设置，只要不跟系统或者别的软件热键相冲突即可。我使用的是Alt+Q，感觉十分顺手，推荐大家也这样设置~ 基础用法在任一窗体下使用快捷键Alt+Q即可激活Listary，同时光标会自动定位在Listary的输入窗口，只要直接开始输入，Listary就自动进行匹配了。使用快捷键Alt+Q可以在启动程序模式与常规模式间进行切换。Listary的匹配总共有三种，分别为命令，路径，启动程序，下面分别介绍一下。 命令：包括一些常用的系统命令，如打开命令行（基于当前路径）等。 路径：返回匹配的文件以及路径（只要是文件或者路径的一部分都可以识别） 启动程序：可以启动预先设置的路径中的程序（再次使用快捷键Alt+Q就可以在启动程序与常规模式间进行切换） 收藏功能激活Listary之后点击有爱心标识的收藏按钮，就可以打开自己的收藏列表，能够更快捷的打开自己常用的软件或者文件。 历史记录激活Listary之后点击历史记录，就可以打开自己最近打开的文件或者文件夹。 快捷功能激活Listary之后点击快捷功能，就可以弹出一些常用的功能，个人最喜欢的是显示隐藏文件和显示文件扩展名，相当的好用~ 常用功能智能匹配只要输入文件名的一部分就可以找到这个文件，支持中文与英文。比如，我输入测试 md就可以搜索到测XX试OO.md这个文件。自然，输入的越多，返回的结果越精确。随着使用记录的积累，常用的文件或程序会获得更高的优先级。 全盘搜索使用与Everything相似的原理，通过遍历USN journal更新索引，可以实现秒级的索引建立与搜索反馈（只支持NTFS文件系统，FAT32等不支持）。结合前面的智能匹配功能，你可以轻易地找到在你硬盘中的每一个文件。 快速选择在任意一个打开的资源管理器界面（焦点需要锁定在资源管理器界面上），输入关键字，光标会自动跳转到当前文件夹中匹配的文件或者目录上。你只要直接回车就可以打开自己想要的文件，而不需要再去使用鼠标双击打开。真正的让文件在指尖舞蹈~ Pro版功能进阶技巧尾言Channing已经跳票很久了，Listary 5 据说完成度还是不够高，连预览版都木有放出来。这篇文章写在Listary 5 发布之前，希望Channing能够加快速度，早日把这个憋了两年的大招放出来~~ 链接 安装版下载 绿色版下载 官方论坛 更新日志 2015年07月28日 完成初步使用介绍","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Windows","slug":"Windows","permalink":"https://xuanwo.org/tags/Windows/"}]},{"title":"2015年中国地质大学(北京)14级ACM程序设计结课赛","slug":"cugb-2015-acm-final","date":"2015-07-16T20:09:41.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/07/16/cugb-2015-acm-final/","link":"","permalink":"https://xuanwo.org/2015/07/16/cugb-2015-acm-final/","excerpt":"简介本次结课赛中，我共出了三题，分别是个人赛中的B，E以及组队赛中的C。根据队长的指示，题目的难度并不高，基本上都是以字符串的处理为主（然后被大一AK了= =，心塞塞）。下面我针对各个题目，给出一份题解，希望现场赛没有做出来的童鞋可以继续思考。","text":"简介本次结课赛中，我共出了三题，分别是个人赛中的B，E以及组队赛中的C。根据队长的指示，题目的难度并不高，基本上都是以字符串的处理为主（然后被大一AK了= =，心塞塞）。下面我针对各个题目，给出一份题解，希望现场赛没有做出来的童鞋可以继续思考。 占神画蛇（个人赛B题）比较简单的模拟题，找出其中的规律即可。 所有的奇数行均为# 所有能被2整除但不能被4整除的行，最右侧为#，其他均为. 所有能被4整除的行，最左侧为#，其他均为. 没有什么难度，但如何才能写得优美，这才是问题。 范神的黄焖鸡（个人赛E题）这是一道非常简单的模拟题，或者可以理解为一个进制转换题。将4和7理解为0和1，或许会更加清晰一些。但有一处区别，那就是47是存在的，而01并不存在。我们可以写出前面几个数 幸运数 需要 计算式 4 1 1*1 7 2 2*1 44 3 1*2+1*1 47 4 1*2+2*1 74 5 2*2+1*1 77 6 2*2+2*1 444 7 1*4+1*2+1*1 我们可以看出，这个等效于将一个二进制数转化为十进制，区别在于这里的4和7对应转化为1和2而不是0和1。看透了这一点，这道题就是跟裸题一样啦。 好学的琦神（组队赛C题）同样是一道非常简单的模拟题，不过有一个坑点：前导0的处理。首先，按照题意进行转换之后，删去所有的前置零；然后，根据题意，要求输出一个正整数，所有在特例9的情况下，上面的处理会导致本题么有任何输出，所以我们要特判并输出。是的，就是这么简单。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"基于Socket.io的虚拟计算机","slug":"socket-vm","date":"2015-07-06T21:05:38.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/07/06/socket-vm/","link":"","permalink":"https://xuanwo.org/2015/07/06/socket-vm/","excerpt":"前言基于Socket.io有很多特别强大的应用，socket.io官方提供的一个虚拟计算机Demo就非常赞。通过将使用Qemu虚拟取出来的PC界面转发至Socket.io的端口，然后对Canvas不断地进行绘制，形成了近似与远程操控的体验。我们Together项目用到了这个库，但由于这个库发布于很久之前，再加上相关文档过少，导致部署起来极为困难。所以我完成了这篇文章，希望能让后来人少走一些弯路。","text":"前言基于Socket.io有很多特别强大的应用，socket.io官方提供的一个虚拟计算机Demo就非常赞。通过将使用Qemu虚拟取出来的PC界面转发至Socket.io的端口，然后对Canvas不断地进行绘制，形成了近似与远程操控的体验。我们Together项目用到了这个库，但由于这个库发布于很久之前，再加上相关文档过少，导致部署起来极为困难。所以我完成了这篇文章，希望能让后来人少走一些弯路。下文基于Ubuntu 14.04 x64，其他系统请自行转换相应命令，谢谢~ 环境配置安装nodejs使用APT安装 sudo apt-get -y install nodejs-legacy 或使用nvm来管理不同版本的nodejs wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash Canvas库在Debian系的OS上会有些诡异的行为，所以需要格外的做一些处理，感谢@computernewb的回复 sudo ln -s /usr/bin/nodejs /usr/sbin/node 安装依赖sudo apt-get -y install libcairo2-dev libpango1.0-dev libgif-dev build-essential g++ 安装libjpeg9和libjpeg9-devwget http://ftp.us.debian.org/debian/pool/main/libj/libjpeg9/libjpeg9_9a-2_amd64.debdpkg -i libjpeg9_9a-2_amd64.debwget http://ftp.us.debian.org/debian/pool/main/libj/libjpeg9/libjpeg9-dev_9a-2_amd64.debdpkg -i libjpeg9-dev_9a-2_amd64.deb 处理WinXp镜像下载XP镜像下载后使用网盘中转在I Tell You上下载纯净的XP镜像。（如果使用盗版的镜像，VPS可能会因为违反其Tos而封号）比如，WinXP的中文简体专业版： ed2k://|file|CN_WINXP_PRO_ISO.img|530186240|7855069CE4216615D761654E2B75A4F7|/ 使用sftp上传可以使用类似于FileZilla这样的FTP工具直接上传，大部分国内的网盘到国外的速度都不理想= =，百度云还会出现断流，而好用的国外网盘都被墙，本身就需要翻墙上传。所以还不如直接使用sftp传到服务器上。 格式转换I Tell You上下载下来的是img镜像文件，然而我们需要的是ISO，所以还需要进行转换。将img转换为iso，我们需要ccd2iso。 sudo apt-get install ccd2iso 使用方法： ccd2iso &lt;.img filename&gt; &lt;.iso filename&gt; socket.io-computer配置安装依赖sudo apt-get -y install qemu redis-server 虚拟机配置生成一个光盘镜像文件用来加载ISO qemu-img create -f qcow2 winxp.img 10G 运行启动Web服务器node app.js 启动IO服务器node io.js 生成qemu实例COMPUTER_ISO=winxp.iso COMPUTER_IMG=winxp.img node qemu.js 启动虚拟机COMPUTER_IMG=winxp.img node emu-runner.js 运行访问http://localhost:5000 注意若搭建在服务器上，使用IP访问需要修改 var url = process.env.COMPUTER_IO_URL || &apos;http://localhost:6001&apos;; 为 var url = process.env.COMPUTER_IO_URL || &apos;http://your IP address:6001&apos;; 否则无法正常连接 更新日志 2015年07月06日 完成主体框架","categories":[{"name":"Learn","slug":"Learn","permalink":"https://xuanwo.org/categories/Learn/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://xuanwo.org/tags/项目/"},{"name":"实习","slug":"实习","permalink":"https://xuanwo.org/tags/实习/"},{"name":"Together","slug":"Together","permalink":"https://xuanwo.org/tags/Together/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://xuanwo.org/tags/虚拟化/"}]},{"title":"Teambition团队协作实践","slug":"teambition-work","date":"2015-07-02T19:08:55.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/07/02/teambition-work/","link":"","permalink":"https://xuanwo.org/2015/07/02/teambition-work/","excerpt":"前言Together团队组建完成后，一个现实的问题在于：我们怎么样进行协作。经过一番筛选之后，我选中了Teambition，一个简约但是够用的团队协作平台。我们团队围绕着我们的需求，基于Teambition建立了我们自己的协作平台。","text":"前言Together团队组建完成后，一个现实的问题在于：我们怎么样进行协作。经过一番筛选之后，我选中了Teambition，一个简约但是够用的团队协作平台。我们团队围绕着我们的需求，基于Teambition建立了我们自己的协作平台。 功能模块任务管理在任务管理方面，我们使用了Teambition的任务版功能。没有进行复杂的任务分组以及任务阶段设计，我们只使用了Teambition默认的几个阶段及分组。大致情况如图：主要有以下几个要点： 通过普通，紧急与非常紧急对任务的优先级进行分类 使用关联内容功能，将任务与项目内容结合起来 使用子任务功能将任务分解为多个模块并分配到人 通过评论功能对任务进展及问题进行及时的交流 日程管理在这一点上，我一开始是有些矛盾的。因为从我的直觉上来讲，我觉得日程管理跟任务管理其实是有重复的地方的，事实上，在协作的过程中，我的组员也确实把这两个混淆了起来。我预想的安排是，固定了时间地点的活动算入日程，而花费的时间未知的需要去做的事情算入任务。不过这个划分确实有些奇怪而且存在矛盾的地方，不过我也没有再做进一步的修正，毕竟现有的划分已经足够满足我们的需求。这些小小的遗憾日后再跟他人交流吧。 创意分享在项目一开始，我们导师提出的要求就是要有创意。为了不让我们的想法零碎地分布在QQ聊天中，我们使用Teambition的分享墙功能来进行我们的创意交流。大致情况如图：分享墙中的文章可以通过关联内容功能与Teambition的其他模块联系在一起，这是一个非常棒的体验，当然，特色的及时评论功能也带了非常爽快的体验。 文件管理这一块的设计并不符合我们的预期，从图片中也能看出，我们团队分享的文件相当之少。主要原因是QQ实在是太方便了（23333），导致像这样的服务，通常都被QQ群中或讨论组内的文件分享取代了。想在这个方向是做出突破，就必须创造出让人们抛弃QQ传文件的方式的价值。Teambition其实在这一方面做出了非常有效的探索：一方面，Teambition的上传下载速度相当快，通过查看源代码可以看出是使用了又拍云的服务，点个赞；另一方面，常见的文档都可以通过Web页面直接查看其内容，免除了下载再查看的麻烦，看代码可以看出支持预览的有视频，音频，PDF以及office系列的文档，基本上已经满足大众需求了。 财务管理Teambition为团队提供了一个非常简单但是足够好用的财务管理功能。收入，支出，审核，对于像我们这样的团队而言，已经完全足够了。当然了，具体的财务分配还是通过微信AA收款之类的服务搞定的，或许Teambition可以考虑跟微信，支付宝对接，直接拉起一个支付请求？ Teambition缺点 点赞功能有些鸡肋 权限管理偏弱- 主页日程页面显示时常出现重复显示的BUG (已修复) 分享墙中的Markdown功能隐藏太深 分享墙中的文档编辑更新显示存在BUG Teambition的客户端功能比较弱- 2015年7月3日，docx预览有BUG (已修复) 应用中的不足 团队的活跃性不强，交互还是比较少，组员们并没有养成上Teambition看动态的习惯= = 实践中没有完全坚持整套的业务流程，还是在用QQ收发文件&amp;共享信息 以上是我们团队应用Teambition进行团队协作的实践，欢迎大家一起来探讨团队协作，共同进步！ 更新日志 2015年07月02日 完成了协作实践的主要内容 2015年07月03日 新增了刚发现的BUG","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://xuanwo.org/tags/项目/"},{"name":"实习","slug":"实习","permalink":"https://xuanwo.org/tags/实习/"},{"name":"Together","slug":"Together","permalink":"https://xuanwo.org/tags/Together/"},{"name":"协作","slug":"协作","permalink":"https://xuanwo.org/tags/协作/"}]},{"title":"使用Screen管理会话","slug":"screen-ssh","date":"2015-07-01T09:49:31.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/07/01/screen-ssh/","link":"","permalink":"https://xuanwo.org/2015/07/01/screen-ssh/","excerpt":"前言在实现Together项目的过程中，有一个需求是需要下载一个500M左右系统镜像包，由于文件源在国内，国外的下载速度简直感人。在经历多次因为SSH超时导致下载意外终止后，我终于决定要解决掉这个问题。","text":"前言在实现Together项目的过程中，有一个需求是需要下载一个500M左右系统镜像包，由于文件源在国内，国外的下载速度简直感人。在经历多次因为SSH超时导致下载意外终止后，我终于决定要解决掉这个问题。 原因SIGHUP 信号首先介绍Linux/Unix中的几个概念： 进程组（process group）：一个或多个进程的集合，每一个进程组有唯一一个进程组ID，即进程组长进程的ID。会话期（session）：一个或多个进程组的集合，有唯一一个会话期首进程（session leader）。会话期ID为首进程的ID。会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组。其余进程组称为后台进程组。 根据POSIX.1定义： 挂断信号（SIGHUP）默认的动作是终止程序。 当终端接口检测到网络连接断开，将挂断信号发送给控制进程（会话期首进程）。 如果会话期首进程终止，则该信号发送到该会话期前台进程组。 一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于STOP状态，发送SIGHUP和SIGCONT信号到该进程组中所有进程。 也就是说，一旦putty因为超时产生了SIGHUP信号，那么会连带着当前终端正在运行的程序全部终止。所以，只要避免SIGHUP信号的产生，就可以规避这个问题。 Screen简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。 安装很多发行版会预装Screen，如果没有（比如Ubuntu），则需要自行安装，以Ubuntu为例： sudo apt-get install screen 创建直接创建直接在命令行下输入 screen 之后你会看到几页字，按回车跳过之后，你就来到了一个shell的全屏窗口。你可以执行任意shell程序，就像在ssh窗口中那样。在该窗口中键入exit退出该窗口，如果这是该screen会话的唯一窗口，该screen会话退出，否则screen自动切换到前一个窗口。 快捷键创建新窗口在已经激活的Screen会话下，使用快捷键Ctrl+A然后点击C，screen 在该会话内生成一个新的窗口并切换到该窗口。 暂时中断screen还有更高级的功能。你可以不中断screen窗口中程序的运行而暂时断开（detach）screen会话，并在随后时间重新连接（attach）该会话，重新控制各窗口中运行的程序。例如，我们使用wget下载一个文件：之后我们想暂时退出做点别的事情，比如出去散散步，那么在screen窗口键入Ctrl+A然后点击D，Screen会给出detached提示：半个小时之后回来了，找到该screen会话： screen -ls 重新连接会话： screen -r 会话ID 一切工作都会完全回来，区别只在于，他可能已经做好了&gt;_&lt;。 键绑定 你可能注意到给screen发送命令使用了特殊的键组合Ctrl+A。这是因为我们在键盘上键入的信息是直接发送给当前screen窗口，必须用其他方式向screen窗口管理器发出命令，默认情况下，screen接收以Ctrl+A开始的命令。这种命令形式在screen中叫做键绑定（key binding），Ctrl+A叫做命令字符（command character）。 可以通过Ctrl+A ?来查看所有的键绑定，常用的键绑定有： Ctrl+A ? 显示所有键绑定信息 Ctrl+A w 显示所有窗口列表 Ctrl+A Ctrl+A 切换到之前显示的窗口 Ctrl+A c 创建一个新的运行shell的窗口并切换到该窗口 Ctrl+A n 切换到下一个窗口 Ctrl+A p 切换到前一个窗口(与Ctrl+A n相对) Ctrl+A 0..9 切换到窗口0..9 Ctrl+A a 发送 Ctrl+A到当前窗口 Ctrl+A d 暂时断开screen会话 Ctrl+A k 杀掉当前窗口 Ctrl+A [ 进入拷贝/回滚模式 参考资料 linux 技巧：使用 screen 管理你的远程会话 GNU Screen Screen的man page提供了最详细的信息 更新日志 2015年07月01日 完成关于Screen的介绍","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"VPS","slug":"VPS","permalink":"https://xuanwo.org/tags/VPS/"},{"name":"Linux","slug":"Linux","permalink":"https://xuanwo.org/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://xuanwo.org/tags/SSH/"}]},{"title":"Together网站项目设计","slug":"together-project","date":"2015-06-30T11:08:47.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/06/30/together-project/","link":"","permalink":"https://xuanwo.org/2015/06/30/together-project/","excerpt":"本项目仍然处在设计阶段，一切变动以最终成果为准 团队介绍团队分工 丁皓（组长），负责网站后端建设及维护（兼产品经理？） 满全勇，负责网站着陆页设计&amp;文案 何壁伟，负责网站内容页设计 马可，担任网站首席体验师 协同工具 分工：Teambition 交流：QQ，简聊 分享：印象笔记","text":"本项目仍然处在设计阶段，一切变动以最终成果为准 团队介绍团队分工 丁皓（组长），负责网站后端建设及维护（兼产品经理？） 满全勇，负责网站着陆页设计&amp;文案 何壁伟，负责网站内容页设计 马可，担任网站首席体验师 协同工具 分工：Teambition 交流：QQ，简聊 分享：印象笔记 公司简介简介Next公司成立于2015年3月，致力于用业界最先进的技术为人们带来更好地互联网生活体验。 员工目前员工有产品经理兼后端工程师一名，前端工程师两名，用户体验师一名。 产品目前推出的产品有NextNote，已经获得三位种子用户，今天我们将带来我公司第二个产品——Together。 格言Next，我们在路上。 市场分析定义在线教育：即e-learning，通过应用信息科技和互联网技术进行内容传播和快速学习的方法。 特点 突破时空限制、知识获取方式灵活； 碎片化学习、随着移动互联网的发展，移动设备更具便携性； 内容多样化，除了K12教育、高等教育外，还包括各类学前教育、职业教育、兴趣教育等细分领域 前景 据GSV全球教育行业报告预测，2017年全球在线教育市场规模预计将增至2555亿美元，保持23%的年复合增长率。 据天拓咨询估计，2017年中国在线教育市场规模将达到3000亿元人民币左右，保持31.7%的年复合增长率。 数据与图片均引用自南方周末-2014年中国在线教育发展前景有多大？ 产品简介特点 运用最新技术，革命性的改进在线教育交互体验 广泛运用开源技术，与开源社区保持密切合作 服务器要求低，可轻松承载超高并发场景 对比 我们 他们 支持电子白板功能 不支持电子白板功能 支持及时聊天功能 只能做到响应缓慢的聊天 支持虚拟计算机功能 无虚拟计算机功能 支持HTML5原生的视频接口 采用过时的Flash技术 全平台支持 不支持最新的移动系统 功能介绍视频直播运用HTML 5标准中的Canvas以及Jsmpeg技术，我们实现了我们公司高效的支持直播的在线播放器。 当前，此技术已经运用于233手游直播APP，证明有效可行。 在线聊天室运用Node.js以及Socket.io，我们公司搭建了响应迅速的在线交流平台，其特点是可以支持大量用户同时在线交流。源代码 电子白板同样基于Node.js以及Socket.io，我们公司搭建了自研发的电子白板平台，基于教师-学生结构的主控端与受控端模型，支持在线演示。源代码 虚拟计算机运用Node.js以及Socket.io，并结合Linux平台上的Qemu虚拟化技术，我们公司首次实现了在线教育领域中的共享操作功能。 创意总结 用技术改变教育 用开源改变业界 用热情改变未来 商业推广微信推送建立企业服务号，定期推送优质资源 热点聚焦捕捉社会热点，制作相应专辑，获取群众关注 学校合作通过与学校进行合作，获取第一批种子客户 引用资料产生文档 使用Screen管理会话 Teambition团队协作实践 参考文档 Node.js文档 Socket.io文档 开源信息引用的开源库较多，如果发现有用到代码但是没有标注的，请及时通知我加上，谢谢~ 视频直播使用jsmpeg 即时聊天使用chat 在线虚拟机使用socket.io-computer 弹幕功能使用CommentCoreLibrary 阶段总结点此下载创意汇报PPT编辑于PowerPoint 2013，2007以下版本可能无法正常显示2015年07月04日上午完成了创意汇报，导师最后的总结是：创意不是新的技术。除此之外，还指出了我们项目的很多不足，包括策划书格式不规范，内容不完整，缺少盈利模式，没有做风险评估等。当然啦，在导师们一遍又一遍地强调突出信息管理特色，不要太过追求技术的大方向下，我来做这样一个项目，确实有点逆向行驶的味道，最后得到这样的评价也不会觉得奇怪。下一周，除了要加紧完善我们的网站设计之外，我们还要关注一下自己的策划书的内容。相比于别的小组，我们的内容确实有些单薄。其实老师说的也没有错，好的想法太多了，但是要把想法真正落实，还有很多繁琐但不可少的工作要做。 版权申明本项目是中国地质大学（北京）人文经管学院2013级信息管理与信息系统专业的暑期实习作品，以署名-非商业性使用-相同方式共享 4.0 国际协议发布，在此协议下，您可以自由地转载或共享。 小小赞助如果您对本项目感兴趣，欢迎使用支付宝扫一扫进行小额赞助以促成项目尽快上线，谢谢~ 更新日志 2015年06月30日 完成项目设计,更新文档结构 2015年07月02日 添加了项目执行中产生的文档 2015年07月03日 完善并充实项目内容，重新调整了结构 2015年07月04日 添加了阶段报告，并提供创意汇报PPT下载 2015年07月06日 添加了在线聊天室以及电子白板的源代码","categories":[{"name":"Learn","slug":"Learn","permalink":"https://xuanwo.org/categories/Learn/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://xuanwo.org/tags/项目/"},{"name":"实习","slug":"实习","permalink":"https://xuanwo.org/tags/实习/"},{"name":"Together","slug":"Together","permalink":"https://xuanwo.org/tags/Together/"}]},{"title":"信息资源管理复习","slug":"information-manage-review","date":"2015-06-19T16:58:58.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/06/19/information-manage-review/","link":"","permalink":"https://xuanwo.org/2015/06/19/information-manage-review/","excerpt":"概述信息资源的分类，方法和类别分类信息资源的类型可以根据多种标准来划分。 以开发程度为依据，信息资源可划分为潜在的信息资源与现实的信息资源两大类型。","text":"概述信息资源的分类，方法和类别分类信息资源的类型可以根据多种标准来划分。 以开发程度为依据，信息资源可划分为潜在的信息资源与现实的信息资源两大类型。 潜在的信息资源是指个人在认知和创造事物的过程中存储在大脑中的信息资源。现实的信息资源是指潜在的信息资源在经过个人表述和与他人进行交流之后，能够为他人所利用的信息资源。 按信息资源历史顺序可分为：人类文化遗产(指人类已继承和拥有的知识、历史文献等)信息资源、最新产生的信息和知识所形成的信息资源(新信息和新知识所占的份额反映了信息资源的更新程度)。 按信息内容和应用领域可分为：政治信息资源、军事信息资源、经济信息资源、文化信息资源、生活信息资源等。 按存储信息的不同物质材料(载体)可分为：文献信息资源，它包括各种书刊文字资料及其复制品和音像资料；非文献信息资源，它包括口头信息资源、实物信息资源和机构信息资源等。 根据信息资源的使用范围可分为：内部信息资源、外部信息资源、公开信息资源、秘密信息资源。 根据其产生和使用的不同可分为：第一级信息资源、第二级信息资源、第三级信息资源和第四级信息资源。 根据其形态的不同可分为：静态信息资源和动态信息资源。一般的文献资源都是静态信息资源；而临时发布的信息和定时发布的信息(资源)为动态信息资源，如天气预报、新闻发布会等。 根据其用途的不同可分为：单一信息资源和综合信息资源。如关于某一类产品的生产方式资料，属于单一信息资源；而关于这类产品市场销售的资料，属于综合信息资源。 根据其与时间的关系的不同可分为：连续性信息资源和离散性信息资源。连续性信息资源是指相互之间有密切(时间)相关关系的资源，如社会演变过程中的信息资源；离散性信息资源是指相互之间不相关的资源，如各种产品生产的信息资源。 方法类别卢泰宏“三维结构论”理解卢泰宏信息资源管理理论的核心是“三维结构论”。他认为，信息资源管理是三种基本信息管理模式的集约化：对应与信息技术的技术管理模式，其研究内容是新的信息系统、新的信息媒介和新的利用方式；对应与信息经济的经济管理模式，其研究方向是信息商品、信息市场、信息产业和信息经济；对应与信息文化的人文管理模式，其研究方向是信息政策和信息法律等。 信息资源学派IRM的三大流派：即信息系统学派、记录管理学派和信息管理学派。 第一章资源和信息资源概念资源的概念一切可被人类开发和利用的物质、能量和信息的总称，它广泛地存在于自然界和人类社会中，是一种自然存在物或能够给人类带来财富的财富。或者说，资源就是指自然界和人类社会中一种可以用以创造物质财富和精神财富的具有一定量的积累的客观存在形态，如土地资源、矿产资源、森林资源、海洋资源、石油资源、人力资源、信息资源等。 信息资源的概念一是狭义的理解，认为信息资源是指人类社会活动中大量积累起来的经过加工处理有序的、有用信息的集合。这只限于信息本身。二是广义的理解。认为信息资源是人类社会信息活动中积累起来的信息、信息生产者、信息技术、资金等信息活动的各种要素的总称。信息资源是人类社会信息活动中大量积累起来的经过过加工处理的有序、有用信息以及各种信息活动要素（信息生产者、信息技术、设备、设施、资金等）的集合。 资源的分类按资源性质分类 自然资源：一般是指一切物质资源和自然过程，通常是指在一定技术经济环境条件下对人类有益的资源。 从资源的再生性角度可划分为再生资源和非再生资源 –再生资源有两类：一类是可以循环利用的资源，如太阳能、空气、雨水、风和水能、潮汐能等；一类是生物资源。非再生资源：（或耗竭性资源），这类资源的储量、体积可以测算出来，其质量也可以通过化学成分的百分比来反映，如矿产资源。从资源利用的可控性程度，可划分为专有资源和共享资源–专有资源：如国家控制、管辖内的资源。共享资源：如公海、太空、信息资源等。 社会经济资源和技术资源：自然资源、社会经济资源、技术资源通常被称为人类社会的三大类资源。社会经济资源又称社会人文资源，是直接或间接对生产发生作用的社会经济因素。其中人口、劳动力是社会经济发展的主要条件。技术资源广义上也属于社会人文资源，其在经济发展中愈益起着重大作用。 按资源用途分类（1）农业资源（2）工业资源（3）信息资源（含服务性资源） 按资源可利用状况分类（1）现实资源：即已经被认识和开发的资源。（2）潜在资源：即尚未被认识，或虽已认识却因技术等条件不具备还不能被开发利用的资源。（3）废物资源：即传统被认为是废物，而由于科学技术的使用，又使其转化为可被开发利用的资源。信息资源属于可再生的社会资源 资源的属性自然资源根据人类对自然资源的认知度，其主要特点是： 自然资源分布的不平衡性和规律性 自然资源的有限性和无限性（现实资源是有限的，但开发利用及转化是无限的） 自然资源的多功能性 自然资源的系统性等 社会资源 社会性 继承性 主导性 流动性 不均衡性 当代信息特点 数量庞大、分布范围广 增长快、老化加速 载体多样化 传播速度快、传播范围广 获取途径多 第二章信息技术带来的问题 信息污染信息超载、虚假信息、有害信息 计算机病毒 知识产权的侵犯 隐私权的侵犯 计算机犯罪 信息主权的侵犯信息垄断、舆论侵略、文化渗透 信息技术体系结构，三个层次信息技术的体系结构由三个层次组成： 第一个层次是信息基础技术，即有关元器件的制造技术，它是整个信息技术体系的基础； 第二个层次是信息主体技术，即有关信息的获取、传输和处理技术，它是信息技术体系的核心； 第三个层次是信息应用技术，即信息主体技术在社会各个领域繁衍出来的各种具体应用技术，它是信息技术开发的根本目的所在。 第三章信息资源管理过程 信息需求分析 信息源分析 信息资源采集 信息资源加工 信息资源存储 信息资源检索 信息资源开发 信息资源利用 信息资源传递 信息资源反馈 信息用户和信息需求信息需求：人们在从事各种社会活动的过程中，为解决不同的问题所产生的对信息的需要。类同于生理上的需求、安全上的需求。信息用户：具备信息需求又有信息行为的人–可分为个人用户和团体用户。 信息源分类、类型、分布特点分类 按组织边界划分：内部信息源+外部信息源 按信息的数字化形式划分：数字化信息源+非数字化信息源。 按信息的载体形式划分：印刷型+缩微型+电子型+实物型+声像信息源。 按信息的运动形式划分：静态+动态信息源。 分布特点 信息源的地区分布不平衡 信息源的机构分布不平衡 信息源的个人分布不平衡 信息资源检索的类型 按检索内容分：文献检索、数据检索和事实检索。 按检索手段来分：手工检索和机器检索。 按检索的组织方式分：全文检索、超文本检索和超媒体检索。 信息资源开发的含义信息资源开发：有广义和狭义之分。广义信息资源开发是指能够改进和加速信息源交流和利用的一切活动，涵盖了信息资源的建设、二次或三次信息资源（索引、文摘、综述等）的编制、增值信息产品的开发等信息活动。狭义信息资源开发是指一种创造和生产新信息产品的活动，它是信息资源开发的一种高级形式。在此重点讨论后者。 第四章标准化的定义在经济、技术、科学及管理等社会实践中，对重复性事物和概念通过制订、发布和实施标准，达到统一，以获得最佳秩序和社会效益。 标准分级根据其适用领域和有效范围的不同，可分为不同的级别 国际标准：由国际上权威组织制定，并为大多数国家所承认和通用的标准。经国际标准化组织认可的标准，也可视为国际标准。 区域标准：由世界区域性集团的标准化组织制定和发布的标准。 国家标准：对全国经济、技术发展有重大意义，需要在全国范围内统一的标准。 行业标准：没有国家标准而又需要在全国某个行业范围内统一的标准，通常由国家标准化组织下设的某个专业技术委员会负责制定。 地方标准：没有国家标准和行业标准而又需要在省、自治区、直辖市范围内统一的标准。 企业标准：企业因生产的产品没有相应的国家标准和行业标准而自行制定的标准，是企业组织生产的依据。 标准化内容，四个方面 标准化技术 标准化设施 标准化术语 标准化管理过程 信息技术标准的分类，七类 信息的采集，编码与记录标准 中文信息处理标准 数据通信与开放系统互联标准 软件工程标准 信息的安全与保密标准 声像技术标准 文献标准 标准化实施的意义 是进行科学管理和组织生产的重要前提； 是进行技术开发，提高技术水平的重要途径 是保证信息产品质量，进行全面质量管理的重要基础。 是获得最佳经济效益的重要手段。 是开拓市场，提高竞争能力的重要保证。 是开展国际交流，进行国际合作的桥梁。 第五章信息安全的基本要素，五个 机密性 完整性 可用性 审查性 可控性 计算机犯罪的种类和特点种类 数据欺骗 特洛伊木马术 香肠术 逻辑炸弹 线路截收 陷阱术 特点 作案手段智能化、隐蔽性强 犯罪侵害的目标较集中 侦查取证困难，破案难度大，存在较高的犯罪黑数 犯罪后果严重，社会危害性大 保障信息安全的措施 防火墙 安全检查（身份认证） 加密 数字签名 网络交易风险和规避风险 与因特网相关的风险 内部网风险 传输商业交易数据的风险 存储数据的风险 规避建设综合安全基础设施（PKI） 认证 支持密钥管理 数据完整性与不可否认服务 数据保密性服务 公证服务 信息安全的讨论题 如何防止计算机犯罪？ 在电子商务交易中，如何规避安全风险？（以实例说明） 结合专业实际，谈谈自身设计数据库的安全如何保证。 现实生活中的信息安全如何保证？ 第六章信息系统的概念广义：各种处理信息的系统，包括人体本身和各种人造系统。狭义：基于计算机的系统，是人、规程、数据库、硬件和软件等各种设备、工具的有机集合，突出的是计算机和通信等技术的应用。第三种理解：把负有信息采集、组织、加工、传递和服务职责的信息资源管理机构和各种基于计算机的处理信息的系统统称为信息系统。 信息资源布局如何理解、网络环境中信息资源布局和面临问题信息资源布局信息资源的布局指信息资源在时间、空间和数量三个方面的有效配置。 网络环境中的信息资源布局 在全球信息资源网络中定位要成为全球信息网络中的一份子，有自己独特的数据库，不但是网络信息资源的使用者，同时也是网络信息资源的提供者。 在全国信息资源网络中定位科学技术、社会科学、经济三大系统应突破封闭自守的现状，联合合作，建立相应的数据库，进而形成网络。 面临问题 信息安全问题 国家主权问题 知识产权问题 语言障碍问题 网络环境下信息资源的组织方式 文件方式 数据库方式 主题树方式 超媒体方式 搜索引擎分类 一般搜索引擎 元搜索引擎 专用引擎 网络环境中信息资源管理面临的挑战和注意的问题 网络信息资源具有大数量、多类型、多媒体、非规范、跨时间、跨地域、跨行业、多语种等特点，文本、数据、图形、图像、声频、视频等多种类型，信息资源管理对象的复杂性和多样性空前增加。 网络的增长和网上信息资源的动态快速增加很大程度上是用户驱动的，但缺乏有效的统一管理机制，信息安全和信息质量让人忧虑。 信息分布和构成缺乏结构和组织，信息源分散无序且更新和消亡无法预测，因此增大了信息资源管理的难度。 信息发布有很大的自由性和任意性，出现了种族歧视、不健康信息的扩散。 正式出版物和非正式信息交流交织在一起，打破了传统信息交流的格局，对学术交流环境产生了影响。 信息流动跨越了国境和疆界，极大促进了人类信息资源的共享，也带来一些问题，如文化冲突、信息威慑等，对信息资源管理中的人文层面提出了新的要求。 第七章信息市场、政策、法规的概念信息市场广义：指信息交换关系的总和，其中包括信息商品交易的场所和信息商品的交换、流通或信息贸易。狭义：仅视为信息商品交易的场所。 信息政策与信息的创造、存储、处理、传播和利用有关的所有公共法律、规章和计划，具有复杂性和动态性，会随着环境的变化不断改变和进行调整。 信息法规信息法规是指对信息活动中的重要问题进行调控的法律措施，这些措施涉及信息系统、处理信息的组织和对信息负有责任的个人等。 罗兰信息要素说，三个方面 基础政策应用于整个社会，直接或间接影响信息部门（如税法、劳动法、教育政策等） 水平信息政策应用于整个信息部门，直接或间接影响信息部门（如数据保护政策、信息自由政策、隐私政策等） 垂直信息政策应用于特定信息社会，适合特定应用领域（如地理信息政策、公共图书管服务政策等） 更新日志 2015年06月19日 首次更新完成 2015年06月23日 补充了网络安全第五点","categories":[{"name":"Learn","slug":"Learn","permalink":"https://xuanwo.org/categories/Learn/"}],"tags":[{"name":"复习","slug":"复习","permalink":"https://xuanwo.org/tags/复习/"},{"name":"Information","slug":"Information","permalink":"https://xuanwo.org/tags/Information/"}]},{"title":"数据库系统概论复习","slug":"database-review","date":"2015-06-12T14:33:29.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/06/12/database-review/","link":"","permalink":"https://xuanwo.org/2015/06/12/database-review/","excerpt":"绪论数据库系统概述数据（Data）： 描述事物的符号记录称为数据。记录： 计算机中表示和存储数据的一种格式或一种方法。数据库（DataBase，简称DB）： 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。特点： 数据按一定的数据模型组织、描述和存储 可为各种用户共享 冗余度较小 数据独立性较高 易扩展","text":"绪论数据库系统概述数据（Data）： 描述事物的符号记录称为数据。记录： 计算机中表示和存储数据的一种格式或一种方法。数据库（DataBase，简称DB）： 数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。特点： 数据按一定的数据模型组织、描述和存储 可为各种用户共享 冗余度较小 数据独立性较高 易扩展 数据库管理系统（DataBase Management System，DBMS）：位于用户与操作系统之间的一层数据管理软件，它为用户或应用程序提供访问DB的方法，包括DB的建立、查询、更新及各种数据控制。主要功能如下： 数据定义功能 数据组织、存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库的建立和维护功能 其他功能 数据库系统（DataBase System， DBS）：DBS是实现有组织地、动态地存储大量关联数据、方便多用户访问的计算机硬件、软件和数据资源组成的系统，即它是采用数据库技术的计算机系统。组成：计算机硬件、数据库、数据库管理系统、应用软件、数据库管理员 数据库技术：是研究数据库的结构、存储、设计、管理和使用的一门软件学科。 数据模型模型： 现实世界特征的模拟和抽象数据模型定义：能表示实体类型及实体间联系的模型要求： 能比较真实的模拟现实世界 容易为人所理解 便于在计算机上实现 概念数据模型按用户观点对数据建模，是对现实世界的第一层抽象，如ER图。主要用于数据库设计，是数据模型建立的基础。 实体：客观存在并可相互区别的事物。属性：实体所具有的某一特性称为属性。用属性来刻画实体。码：唯一标识实体的属性集，如学号。域：属性的取值范围称为该属性的域。实体型：具有相同性质的实体必然具有共同的特征和性质。实体集：同型实体的集合。联系：可分为一对一，一对多，多对多。 逻辑数据模型直接面向数据库的逻辑结构，是对现实世界的第二层抽象。可分为：网状、层次、关系、面对对象等；也可分为模糊、时态、空间、时空、概率、粗糙、分形等。组成包括：数据结构、数据操作、数据的约束条件。 层次数据模型：层次数据模型对应数据结构中的树形结构： 有且只有一个称为根的结点 当结点数大于1时，除根节点外的结点可以分为M个互相不相交的有限集，其中每一个集合又是一棵数。 数据操纵：查询、插入、删除和修改数据约束条件： 进行插入操作时，如果没有相应的双亲结点值，不能插入子女结点值。 进行删除操作时，如果删除双亲结点值，则相应的子女结点值也被删除。 进行修改操作时，应修改所有相应记录，以保证数据的一致性。 网状数据模型：针对数据结构中的图 面向对象的数据模型：最关键的两个概念：对象：现实世界中实体的模型化类：对象类型和对这个对象模型进行的操作方法 数据库系统结构数据库系统的三级模式结构 外模式/模式映像 内模式/模式映像 数据库系统的组成硬件平台及数据库软件人员 数据库管理员 系统分析员和数据库设计人员 应用程序员 用户 关系型数据库理论 关系模型概述 关系数据结构域：是一组具有相同数据类型的值的集合域的笛卡儿积：给定一组域D1，D2，…，Dn，其笛卡尔积为： 关系关系：D1×D2×…×Dn的子集叫做在域D1，D2，…，Dn上的关系，记做：R(D1，D2，…，Dn)。 关系是笛卡尔积的有一定意义、有限的子集。关系也是一个二维表，表的每一行对应一个元组，表的每一列对应一个域。对每列起一个唯一的名字，称为属性。n元关系有n个属性。当n=1时，称该关系为单元关系；当n=2时，称该关系为二元关系。若关系中的某一属性组的值能够唯一地标识一个元组，则称该属性组为候选码。若一个关系有多个候选码，则选定其中一个作为主码。候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。 关系的性质： 同质的列 不同属性应该有不同的名称 属性是无序的 元组不能重复 元组无序 分量是原子（即每一个分量都必须是不可分的数据项） 关系模式在数据库中要区分型和值，型是指关系模式，值是指关系。 关系：一张二维表格，其中每一行为一元组，每一列为一属性。 关系模式：关系的描述称为关系模式。它可以形式化的表示为：R(U, D, dom, F)其中：R：关系名U：组成该关系的属性集合D：属性来自的域dom：属性向域的映象集合F：属性间数据依赖关系集合 关系模式与关系的关系： 关系模式是静态的，稳定的 关系是动态地，随时间不断变化的 关系是关系模式在某一时刻的状态和内容 关系的完整性关系模型的完整性规则是对关系的某种约束条件。 关系的三类完整性约束 实体完整性 参照完整性 用户定义的完整性 实体完整性若属性A是基本关系R的主属性，则属性A不能取空值。 参照完整性 外码设F市基本关系R的一个或一组属性，但不是关系R的码。Ks是基本关系S的主码。如果F与Ks相对应，则称D是R的外码。并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。关系R和S不一定是不同的关系。 若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R中每个元组在F上的值必须为： 或者取空值（F的每个属性值均为空值） 或者等于S中某个元组的主码值 用户定义的完整性针对某一具体关系数据库的约束条件 关系代数关系代数是一种抽象的查询语言，它用作对关系的运算来表达查询。 传统的集合运算 并 差 交 笛卡儿积 专门的关系演算选择从关系R中选取使得逻辑表达式F为真的元组，这是从行的角度进行的运算。投影从关系R中选取若干属性列组成新的关系，这是从列的角度进行的运算。需要消除重复行，因此有可能导致某些元组被取消。连接从两个关系的笛卡尔积中选取属性间满足一定条件的元组 等值连接：要求选取的A，B属性组的值相等 自然连接：特殊的等值连接，要求把重复属性列去掉 如果把舍弃的元组也保存在结果关系中，而在其他的属性上填空值（NULL），那么这种连接叫做外连接。如果只保留左边关系中要舍弃的部分，叫做左外连接；如果只保留右边关系中要舍弃的部分，叫做右外连接。 除 SQL数据语言SQL概述产生与发展 1974年由Boyce和Chamberlin提出 1975-1979年，IBM的System R上实现 1986年，ANSI通过SQL标准 后来相继提出SQL-89与SQL-92标准 目前，大多数数据库均采用SQL作为共同的数据存取和标准接口 SQL的特点 综合统一 高度非过程化 面向集合的操作方式 一种语法结构两种方式 语言简洁，易学易用 SQL基本概念SQL支持关系数据库三级模式结构，其中： 外模式——视图和部分基本表（不能独立存在） 模式——基本表（独立存在，关系-基本表-存储文件一一对应） 内模式——存储文件（存储文件的逻辑结构组成了关系数据库的内模式） SQL对象SQL对象包括数据库、表、视图、属性名等，这些对象名符合一定规则： SQL SERVER 1-30字符ACCESS 64字符ORACLE 限制为8个字符 应以字母开头，其他字符可以使字母、数字、下划线 SQL语句 尖括号”&lt;&gt;”中的内容为实际意义 中括号”[]”中的内容为任选项 [,…]意思是等等 大括号”{}”与竖线”|”标明此处为选择项，在所列举的各项中仅需选择一项。 SQL中的数据项（包括列项、表和视图）分隔符为”,”；其字符串常数的定界符用单引号”‘“表示。 数据定义 数据库的创建与删除创建数据库 CREATE DATABASE &lt;数据库名&gt;;CREATE DATABASE Mydb; 删除数据库 DROP DATABASE &lt;数据库名&gt; [,&lt;数据库名&gt;] [,...];DROP DATABASE Mydb; 表的创建与删除创建基本表 CREATE TABLE &lt;表名&gt; (&lt;列名&gt; &lt;数据类型&gt; [&lt;列级完整性约束条件&gt;] [&lt;列名&gt; &lt;数据类型&gt; [ &lt;列级完整性约束条件&gt; ] [,...] ] [,&lt;表级完整性约束条件&gt;] [,..]); 约束条件： 列级完整性约束条件——只能用于列 表级完整性约束条件——只能够用于一张中的多列 SQL完整性约束条件 NOT NULL或NULL，列级，是否允许为空 UNIQUE，列级，唯一性约束 DEFAULT，列级，默认值约束 CHECK，列级，检验约束，为插入列中的数据指定约束条件 PRIMARY KEY，表级，主键约束，使得主键的数值在每一行中各不相同，不能为空 FOREIGN KEY，表级，外键约束，是参照完整性约束 举例创建学生表：Student(sno, sname, sdate, ssex, sdept) Create Table Student( sno char(5) not null unique, sdate date, ssex char(2) default &apos;男&apos;, sdept char(2) Constraint C1 Check (ssex In (&apos;男&apos;, &apos;女&apos;))); 删除基本表 DROP TABLE &lt;表名&gt;; 举例 DROP TABLE Student; 表结构的修改ALTER TABLE &lt;表名&gt; [ADD ( &lt;新列名&gt; &lt;数据类型&gt; [&lt;完整性约束条件&gt;][,...])] [DROP &lt;完整性约束名&gt;] [MODIFY ( &lt;列名&gt; &lt;数据类型&gt; [,...])]; 举例 在Student表中增加‘籍贯native_place’列，数据类型为字符型 Alter Table Student Add native_place Varchar(50); 删除Student表中学生姓名必须取唯一值的约束条件 Alter Table Student Drop unique(sname); 修改Student表中sname列的数据类型为定长字符型 Alter Table Student Modify sname char(8) unique; 建立和删除索引建立索引 CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;次序&gt;] [, &lt;列名&gt; [&lt;次序&gt;] ] [,…]); 举例 Create unique Index stusno_ind On Student (sno ASC); 删除索引 DROP INDEX &lt;索引名&gt;; 举例 DROP INDEX Stusno_Ind; 数据查询SELECT [ALL|DISTINCT] &lt;目标列表达式&gt; [,&lt;目标列表达式&gt;] [,…][INTO &lt;新表名&gt;]FROM &lt;表名/视图名&gt; [,&lt;表名/视图名&gt;] [,…][WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt;] [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]; 目标列表达式目标列表达式是一个逗号分隔的表达式列表 [&lt;表名&gt;.]&lt;属性列名表达式&gt; [, [&lt;表名&gt;.] &lt;属性列名表达式&gt;] [, …] 举例 //查询单表中全体学生的学号与姓名SELECT sno, sname FROM Student;//查询单表中的全体学生SELECT * FROM Student; 集函数 &lt;集函数&gt; ( [ DISTINCT | ALL ] * )//集函数：SUM、AVG、COUNT、MAX、MIN 举例 SELECT DISTINCT sname, Year(GetDate())-Year(sdate) AS age FROM Student; 条件表达式举例 //从Student表中，查询男同学SELECT * FROM Student WHERE ssex=&apos;男&apos;;//从Student表中，查询出生日期在1980年和1990年之间的学生SELECT * FROM Student WHERE sdate BETWEEN &apos;1980-01-01&apos; AND &apos;1990-12-31&apos;; 通配符 %：百分号，代表任意长度的字符串a%b:ab,acb,addb_：下划线，代表单个字符a_b: acb,adb, afb [ ]：表示中括号里面的任意一个字符A[BCDE]表示第一个字符为A，第二个字符为B,C,D,E中的任意一个[^ ]：表示不在中括号里面的任意一个字符A[^BCDE]表示第一个字符为A，第二个字符为不为B,C,D,E的任意一个字符 数据操纵数据插入——INSERT——向数据库中插入新纪录数据修改——UPDATE——修改数据库中的某记录数据删除——DELETE——删除数据库中的某记录 数据插入插入元组 INSERTINTO &lt;表名&gt; [( &lt;字段1&gt;[, &lt;字段2&gt;] [,…])]VALUES (&lt;常量1&gt; [, &lt;常量2&gt;] [,…]); 举例 //将一条新学生记录（所有字段都有值）插入到表中Insert Into SValues (‘95020’,‘陈东’,‘男’,‘IS’,’18’);将一条学生记录（部分字段有值）插入表中Insert Into S(Sno,Sname)Values (‘95020’,‘陈东’); 插入子查询子查询不仅可以嵌套在SELECT语句中，也可以嵌套在INSERT语句中，用于生成要插入的批量数据。 INSERTINTO &lt;表名&gt; [( &lt;字段1&gt;[, &lt;字段2&gt;] [,…])]子查询; 举例 Insert Into Deptage(Sdept, Avgage) Select Sdept, AVG(Sage) From S Group By Sdept; 数据修改一般格式 UPDATE &lt;表名&gt;SET &lt;字段名1&gt;＝&lt;表达式1&gt;[, &lt;字段2&gt;= &lt;表达式2&gt;] [,…]][WHERE &lt;条件表达式&gt;]; 举例 //修改某一元组的值：如将学生95001的年龄改为22岁Update SSet Sage=22Where Sno=&apos;95001&apos;;//修改多个元组的值：如将所有学生的年龄加一岁Update SSet Sage= Sage+1;//带子查询的修改语句：将信息管理系的所有学生成绩置零Update SCSet Grade=0Where &apos;IS&apos;= (Select Sdept From S Where S.Sno=SC.Sno); 删除数据一般格式 DELETEFROM &lt;表名&gt;[WHERE &lt;条件表达式&gt;]; 举例 //删除某一元组：如删除学号为95001的学生记录DeleteFrom SWhere Sno=&apos;95001&apos;;//将S表清空DeleteFrom S;//带查询的删除语句：如删除信息系所有学生的选课记录DeleteFrom SCWhere &apos;IS&apos;= (Select Sdept From S Where S.Sno=SC.Sno); 数据控制共享程度与安全性问题的冲突数据控制功能： 事务管理功能 数据保护功能 授予权限一般格式 GRANT &lt;权限&gt; [,&lt;权限&gt;][,…] [ON &lt;对象类型&gt; &lt;对象名称&gt;] TO &lt;用户&gt; [, &lt;用户&gt;] [,…] [WITH GRANT OPTION]; 举例 //把查询S表的权限授权给用户U1GRANT SELECTON TABLE STO U1;//把查询S表和C表的全部权限授权给用户U1和U2GRANT ALL PRIVILEGESON TABLE S, CTO U1, U2; 收回权限一般格式 REVOKE &lt;权限&gt; [,&lt;权限&gt;][,…] [ON &lt;对象类型&gt; &lt;对象名称&gt;] FROM &lt;用户&gt; [, &lt;用户&gt;] [,…] 举例 //把用户U1修改学号的权限收回REVOKE UPDATE(Sno)ON TABLE SFROM U1;//收回所有用户对表SC的查询权限REVOKE SELECTON TABLE SCFROM PUBLIC; 关系数据库设计关系数据库设计理论关系模式R(U , F)当且仅当U上的一个关系r满足F时，r称为关系模式R(U , F)的一个关系 函数依赖定义定义：设R（U）是属性集U上的关系模式。X，Y是U上的子集。若R（U）的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等而在Y上的属性值不等，则称：X函数依赖确定Y或Y函数依赖确定于X，记做X-&gt;Y。 术语： 第一范式（1NF）每一个分量必须是不可分的数据项。存在问题：数据冗余；插入异常；删除异常。 第二范式（2NF）在第一范式的基础上，每一个非主属性完全函数依赖于码。存在问题：插入异常；删除异常；修改复杂。 第三范式（3NF）若关系R（U）的每个非主属性都不部分依赖于也不于传递于码，则称R（U）满足第三范式。 BCNF 所有非主属性对每一个码都是完全函数依赖 所有的主属性对每一个不包含它的码，是完全函数依赖 没有任何属性完全依赖于非码的任何一组属性 多值依赖 第四范式（4NF）关系模式R符合第一范式，对于R的每一个非平凡多值依赖，X都含有码，则称关系模式R符合第四范式 总结 关系数据库设计的步骤 需求分析 概念结构设计 逻辑结构设计 数据库物理设计 数据库实施 数据库运行和维护 需求分析 业务流程分析 数据流程分析 画出ER图 概念结构设计特点： 能真实、充分地反映现实世界，包括事物与事物之间的联系 易于理解，从而可以用它和不熟悉计算机的用户交换意见 易于更改 易于向关系、网状、层次等数据模型转换 设计方法： 自顶向下 自底向上 逐步扩张：核心概念结构，向外扩张 混合策略：自顶向下和自底向上相结合 数据抽象： 分类 聚集 概括 任务：ER图变为数据库逻辑结构 转换原则：实体及其属性的转换：一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码。 1:1可以转换为一个独立模式，也可以与任意一段的对应的关系模式合并1:n可以转换为一个独立模式，可以与N端对应的关系模式合并m:n转换为一个独立模式 设计用户子模式——视图 数据库的物理设计 存取方法 存取结构 实施与维护阶段 定义数据库的结构 数据装载/编写程序 数据库软件试运行 数据库安全保护信息安全综述安全：免于危险的质量和状态信息安全：是对信息、系统以及使用、存储和传输信息的硬件的保护数据库安全：是指保护数据库以防止不合法的使用所造成的数据泄露、更改或破坏访问：一个主题或对象使用、操作、修改或者影响另一个主题或对象的能力资产：被保护的机构资源安全蓝本：对机构里新的安全措施的实施计划漏洞：系统内的弱点或错误，或者是使信息暴露给攻击或破坏的保护性机制 数据库安全性控制计算机系统的安全模型 用户标识和鉴别用户标识和鉴别是系统提供的最外层安全保护措施举例：校园网登录 存取控制数据库安全性主要是存取控制机制 定义用户权限 合法用户权限检查 审计把用户对数据库的所有操作自动记录下来放入审计日志 数据加密高度敏感性数据，需要采用数据加密技术 统计数据库安全性在统计数据库中存在着特殊的安全性问题，需要注意。 SQL SERVER系统安全性简要介绍，略过 版权信息大部分内容来自于中国地质大学（北京）安海忠老师的授课PPT以及王珊，萨师煊所著的《数据库系统概论》（第四版），可在非商用-署名前提下自由分发。 更新日志 2015年06月12日 完成初稿 2015年06月14日 修复了一些格式错误","categories":[{"name":"Learn","slug":"Learn","permalink":"https://xuanwo.org/categories/Learn/"}],"tags":[{"name":"Database","slug":"Database","permalink":"https://xuanwo.org/tags/Database/"},{"name":"复习","slug":"复习","permalink":"https://xuanwo.org/tags/复习/"}]},{"title":"史上最详细的Hexo博客搭建图文教程","slug":"hexo-intor","date":"2015-03-26T00:22:43.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/03/26/hexo-intor/","link":"","permalink":"https://xuanwo.org/2015/03/26/hexo-intor/","excerpt":"前言从2014年的八月份开始接触Hexo，一直用到现在，已经有半年的时间了。这期间，Hexo从2.X一路升级到了3.0，很多地方都发生了改变。不仅如此，很多原来使用Hexo的博主们写下了的教程并没有及时更新，导致后来人一头雾水，挫折感十足。因此，本文致力于提供一份足够简单，长期维护的基于Github Pages的Hexo博客搭建图文教程，希望能有所帮助。当然，我个人的力量是有限的，因此也希望使用Hexo的大家也能一起行动起来，通过提交PR，发布issues或者在下方评论区评论等形式参与到本文档的编辑中来。浏览时，使用Ctrl+F搜索关键词。（是不是会有似曾相识的感觉，= =）","text":"前言从2014年的八月份开始接触Hexo，一直用到现在，已经有半年的时间了。这期间，Hexo从2.X一路升级到了3.0，很多地方都发生了改变。不仅如此，很多原来使用Hexo的博主们写下了的教程并没有及时更新，导致后来人一头雾水，挫折感十足。因此，本文致力于提供一份足够简单，长期维护的基于Github Pages的Hexo博客搭建图文教程，希望能有所帮助。当然，我个人的力量是有限的，因此也希望使用Hexo的大家也能一起行动起来，通过提交PR，发布issues或者在下方评论区评论等形式参与到本文档的编辑中来。浏览时，使用Ctrl+F搜索关键词。（是不是会有似曾相识的感觉，= =） 准备你需要准备好以下软件： Node.js环境 Git Windows配置Node.js环境下载Node.js安装文件： Windows Installer 32-bit Windows Installer 64-bit根据自己的Windows版本选择相应的安装文件，要是不知道，就安装32-bit的吧- -。如图所示：保持默认设置即可，一路Next，安装很快就结束了。然后我们检查一下是不是要求的组件都安装好了，同时按下Win和R，打开运行窗口：在新打开的窗口中输入cmd，敲击回车，打开命令行界面。（下文将直接用打开命令行来表示以上操作，记住哦~）在打开的命令行界面中，输入 node -vnpm -v 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 配置Git环境下载Git安装文件： Git-2.6.3-64-bit.exe然后就进入了Git的安装界面，如图：和Node.js一样，大部分设置都只需要保持默认，但是出于我们操作方便考虑，建议PATH选项按照下图选择： 这是对上图的解释，不需要了解请直接跳过Git的默认设置下，出于安全考虑，只有在Git Bash中才能进行Git的相关操作。按照上图进行的选择，将会使得Git安装程序在系统PATH中加入Git的相关路径，使得你可以在CMD界面下调用Git，不用打开Git Bash了。 一样的，我们来检查一下Git是不是安装正确了，打开命令行，输入： git --version 如果结果如下图所示，则说明安装正确，可以进行下一步了，如果不正确，则需要回头检查自己的安装过程。 LinuxMac OS配置Github注册账号如果已经拥有账号，请跳过此步~打开https://github.com/，在下图的框中，分别输入自己的用户名，邮箱，密码。然后前往自己刚才填写的邮箱，点开Github发送给你的注册确认信，确认注册，结束注册流程。一定要确认注册，否则无法使用gh-pages！ 创建代码库登陆之后，点击页面右上角的加号，选择New repository：进入代码库创建页面：在Repository name下填写yourname.github.io，Description (optional)下填写一些简单的描述（不写也没有关系），如图所示：正确创建之后，你将会看到如下界面： 开启gh-pages功能点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages，如图：点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。如果你的配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了~如果yourname.github.io已经可以正常访问了，那么Github一侧的配置已经全部结束了。 配置Hexo安装Hexo在自己认为合适的地方创建一个文件夹，然后在文件夹空白处按住Shift+鼠标右键，然后点击在此处打开命令行窗口。（同样要记住啦，下文中会使用在当前目录打开命令行来代指上述的操作）在命令行中输入： npm install hexo-cli -g 然后你将会看到:可能你会看到一个WARN，但是不用担心，这不会影响你的正常使用。然后输入 npm install hexo --save 然后你会看到命令行窗口刷了一大堆白字，下面我们来看一看Hexo是不是已经安装好了。在命令行中输入： hexo -v 如果你看到了如图文字，则说明已经安装成功了。 初始化Hexo接着上面的操作，输入： hexo init 如图：然后输入：npm install 之后npm将会自动安装你需要的组件，只需要等待npm操作即可。 首次体验Hexo继续操作，同样是在命令行中，输入： hexo g 如图：然后输入： hexo s 然后会提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 在浏览器中打开http://localhost:4000/，你将会看到：到目前为止，Hexo在本地的配置已经全都结束了。 使用Hexo 在配置过程中请使用yamllint来保证自己的yaml语法正确 修改全局配置文件此段落引用自Hexo官方文档 您可以在 _config.yml 中修改大部份的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_default 永久链接中各部分的默认值 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 `downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 MMM D YYYY time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置 配置Deployment首先，你需要为自己配置身份信息，打开命令行，然后输入： git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 同样在_config.yml文件中，找到Deployment，然后按照如下修改： deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 如果使用git方式进行部署，执行npm install hexo-deployer-git --save来安装所需的插件 然后在当前目录打开命令行，输入： hexo d 随后按照提示，分别输入自己的Github账号用户名和密码，开始上传。然后通过http://yourname.github.io/来访问自己刚刚上传的网站。 添加新文章打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。新建的文章头需要添加一些yml信息，如下所示： ---title: hello-world //在此处添加你的标题。date: 2014-11-7 08:55:29 //在此处输入你编辑这篇文章的时间。categories: Exercise //在此处输入这篇文章的分类。toc: true //在此处设定是否开启目录，需要主题支持。--- 进阶如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。 更换主题可以在此处寻找自己喜欢的主题下载所有的主题文件，保存到Hexo目录下的themes文件夹下。然后在_config.yml文件中修改： # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: landscape //themes文件夹中对应文件夹的名称 然后先执行hexo clean，然后重新hexo g，并且hexo d，很快就能看到新主题的效果了~ 更换域名首先，需要注册一个域名。在中国的话，.cn全都需要进行备案，如果不想备案的话，请注册别的顶级域名，可以使用godaddy或新网或万网中的任意一家，自己权衡价格即可。然后，我们需要配置一下域名解析。推荐使用DNSPod的服务，比较稳定，解析速度比较快。在域名注册商出修改NS服务器地址为： f1g1ns1.dnspod.netf1g1ns2.dnspod.net 以新网为例，首先点击域名管理进入管理页面：然后点击域名后面的管理：进入域名管理的操作界面，点击域名管理，来到域名管理界面：点击修改域名DNS，然后选择填写具体信息，在下面的空框中填入DNSPod的NS服务器：然后我们进入DNSPod的界面，开始真正进入域名解析的配置= =。在DNSPod中，首先添加域名，然后分别添加如下条目：最后，我们对Github进行一下配置。在自己本地的hexo目录下的source文件夹中，新建一个CNAME文件（注意，没有后缀名。），内容为yourdomin.xxx。然后再执行一下hexo d -g，重新上传自己的博客。在github中打开你自己的库，进入库的setting界面，如果看到了如下提示，说明配置成功了。在这一系列的操作中，包括修改NS服务器，设置A解析等等，都需要一定的时间。短则10分钟，长则24小时，最长不会超过72小时。如果超过72小时，请检查自己的配置过程，或者修改自己本地的DNS服务器。 更新日志 2015年03月26日 完成了基础架构，慢慢添加进阶技巧= =。 2015年03月31日 添加了CNAME的相关内容。 2015年04月30日 修复了错误的git命令。 2015年06月11日 更新了.config_yml配置 2015年10月12日 完善了Deployment部分操作，添加了yaml语法检测网址 2015年12月09日 更新软件版本，为Hexo 3.2做准备","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"数论——快速幂","slug":"number-theory-quick-pow","date":"2015-03-18T17:43:59.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/03/18/number-theory-quick-pow/","link":"","permalink":"https://xuanwo.org/2015/03/18/number-theory-quick-pow/","excerpt":"原始代码int Pow(int A, int n)&#123; if (n == 0) return 1; int rslt = 1; for (int i = 0; i &lt; n; ++i) &#123; rslt *= A; &#125; return rslt;&#125;","text":"原始代码int Pow(int A, int n)&#123; if (n == 0) return 1; int rslt = 1; for (int i = 0; i &lt; n; ++i) &#123; rslt *= A; &#125; return rslt;&#125; 很简单的算法，复杂度为O(n)，但是当n特别大的时候，可能会出现以下两个问题： 爆int，我们无法使用int来存储我们最后的结果。 计算量上升极快，即使是O(n)的复杂度也无法满足我们的需要。 二分优化快速幂的思想非常简单，就是二分法： 对于一般的解法：A^8 = A * A * A * A * A * A * A * A总共需要7次乘法运算；将其平均分解：A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2这样我们就只需要4次乘法运算了；我们还可以将其再分解：A^6 = [(A * A) * (A * A)] ^ 2 = [(A * A) ^ 2] ^ 2这样就将乘法运算的次数减少为了3次。 当然，进行这样的分解需要满足一个前提：进行快速幂运算的数据类型必须是满足结合律的。然后，我们可以看出，这种二分解法将原本n次的运算降低为logn / log2次。在这样的思想指导下，我们可以得出一个O(logn)的优化算法： int qPow(int A, int n)&#123; if (n == 0) return 1; int rslt = 1; while (n) &#123; if (n &amp; 1) //如果n为奇数 &#123; rslt *= A; &#125; A *= A; n &gt;&gt;= 1; &#125; return rslt;&#125; 矩阵快速幂矩阵和整数的快速幂运算算法在代数上应该是等价的，矩阵也具备快速幂运算所必需的条件：结合律。因此，我们在前面得出的结论也能应用到矩阵当中。首先，我们需要实现一个矩阵类，重载一些运算符： class Matrix&#123;public: int N; // 矩阵维数 int** m; // 存储矩阵的二维数组 Matrix(int n = 2) &#123; m = new int*[n]; for (int i=0; i &lt; n; ++i) &#123; m[i] = new int[n]; &#125; N = n; clear(); &#125;// 将矩阵清空为零矩阵 void clear() &#123; for (int i=0; i &lt; N; ++i) &#123; memset(m[i], 0, sizeof(int) * N); &#125; &#125;// 将矩阵设定为单位矩阵 void unit() &#123; clear(); for (int i=0; i &lt; N; ++i) &#123; m[i][i] = 1; &#125; &#125;// 矩阵的赋值 Matrix operator= (Matrix &amp;othr) &#123; Matrix(othr.N); for (int i=0; i &lt; othr.N; ++i) &#123; for (int j=0; j &lt; othr.N; ++j) &#123; m[i][j] = othr.m[i][j]; &#125; &#125; return *this; &#125;// 矩阵的乘法//!假设所有因子均为同阶方阵 Matrix operator* (Matrix &amp;othr) &#123; Matrix rslt(othr.N); for (int i=0; i &lt; othr.N; ++i) &#123; for (int j=0; j &lt; othr.N; ++j) &#123; for (int k=0; k &lt; othr.N; ++k) &#123; rslt.m[i][j] += m[i][k] * othr.m[k][j]; &#125; &#125; &#125; return rslt; &#125;&#125;; 有了矩阵类，我们下面再依样画瓢地实现一遍快速幂运算： Matrix qMPow(Matrix &amp;A, int n)&#123; Matrix rslt(A.N); rslt.unit(); if (n == 0) return rslt; while (n) &#123; if (n &amp; 1) // 若幂为奇数 &#123; rslt = rslt * A; &#125; A = A * A; n &gt;&gt;= 1; // 右位移等价于除以2 &#125; return rslt;&#125; 引用 快速幂运算 更新日志 2015年3月19日 首次发布。 2015年3月19日 补充了矩阵快速幂的内容。","categories":[{"name":"Summary","slug":"Summary","permalink":"https://xuanwo.org/categories/Summary/"}],"tags":[]},{"title":"数论——筛法求素数","slug":"number-theory-sieve-method-to-find-primes","date":"2015-03-18T17:16:01.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/03/18/number-theory-sieve-method-to-find-primes/","link":"","permalink":"https://xuanwo.org/2015/03/18/number-theory-sieve-method-to-find-primes/","excerpt":"暴力瞎搞求素数首先，我们需要个判断是否为素数的算法： bool IsPrime(unsigned n) //此处n是一个大于2的整数&#123; for (unsigned i = 2; i &lt; n / 2 + 1; ++i) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125;","text":"暴力瞎搞求素数首先，我们需要个判断是否为素数的算法： bool IsPrime(unsigned n) //此处n是一个大于2的整数&#123; for (unsigned i = 2; i &lt; n / 2 + 1; ++i) &#123; if (n % i == 0) &#123; return false; &#125; &#125; return true;&#125; 然后，在for循环中逐个判断。。。。。。你写写看啊，- -，看看队友会不会打扁你。。。显然，这个方法太傻逼了= =，我们需要一个效率更高，更为机智算法。 一般的线性筛法下面进入正题，我们来介绍一下求素数的线性筛法。 代码void make_prime()&#123; memset(prime, 1, sizeof(prime)); prime[0] = false; prime[1] = false; int N = 31700; for (int i = 2; i &lt; N; i++) if (prime[i]) &#123; primes[++cnt ] = i; for (int k = i * i; k &lt; N; k += i) prime[k] = false; &#125; return;&#125; 这种方法比较好理解:初始时，假设全部都是素数，当找到一个素数时，显然这个素数乘上另外一个数之后都是合数(注意上面的 ii , 比 i2 要快点 )，把这些合数都筛掉，即算法名字的由来。但仔细分析能发现，这种方法会造成重复筛除合数，影响效率。比如10，在i=2的时候，k=215筛了一次；在i=5，k=56 的时候又筛了一次。所以，也就有了快速线性筛法。 快速线性筛法快速线性筛法没有冗余，不会重复筛除一个数，所以“几乎”是线性的，虽然从代码上分析，时间复杂度并不是O(n)。 代码const long N = 200000;long prime[N] = &#123;0&#125;, num_prime = 0;int isNotPrime[N] = &#123;1, 1&#125;;int main()&#123; for (long i = 2 ; i &lt; N ; i ++) &#123; if (! isNotPrime[i]) prime[num_prime ++] = i; //关键处1 for (long j = 0 ; j &lt; num_prime &amp;&amp; i * prime[j] &lt; N ; j ++) &#123; isNotPrime[i * prime[j]] = 1; if ( !(i % prime[j] ) ) //关键处2 break; &#125; &#125; return 0;&#125; 理解首先，先明确一个条件，任何合数都能表示成一系列素数的积。不管 i 是否是素数，都会执行到“关键处1”。 如果 i 都是是素数的话，那简单，一个大的素数 i 乘以不大于 i 的素数，这样筛除的数跟之前的是不会重复的。筛出的数都是 N=p1*p2的形式, p1，p2之间不相等 如果 i 是合数，此时 i 可以表示成递增素数相乘 i=p1p2…*pn, pi都是素数（2&lt;=i&lt;=n）， pi&lt;=pj ( i&lt;=j )p1是最小的系数。 根据“关键处2”的定义，当p1==prime[j] 的时候，筛除就终止了，也就是说，只能筛出不大于p1的质数*i。 我们可以直观地举个例子：i=2*3*5此时能筛除 2i ,不能筛除 3i，如果能筛除3i 的话，当 i’ 等于 i’=335 时，筛除2i’ 就和前面重复了。 引用 一般筛法求素数+快速线性筛法求素数 打印质数的各种算法 更新日子 2015年03月18日 首次完成。","categories":[{"name":"Summary","slug":"Summary","permalink":"https://xuanwo.org/categories/Summary/"}],"tags":[]},{"title":"数论——欧几里得算法","slug":"number-theory-gcd","date":"2015-03-11T10:32:31.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/03/11/number-theory-gcd/","link":"","permalink":"https://xuanwo.org/2015/03/11/number-theory-gcd/","excerpt":"欧几里得算法介绍欧几里得算法，又名辗转相除法，是求最大公约数的算法。两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（252 = 21 × 12；105 = 21 × 5）；因为252 − 105 = 147，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。参考辗转相除法的演示动画：两条线段分别表示252和105，其中每一段表示21。动画演示了循环从大数中减去小数，直到其中一段的长度为0，此时剩下的一条线段的长度就是252和105的最大公约数。","text":"欧几里得算法介绍欧几里得算法，又名辗转相除法，是求最大公约数的算法。两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（252 = 21 × 12；105 = 21 × 5）；因为252 − 105 = 147，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。参考辗转相除法的演示动画：两条线段分别表示252和105，其中每一段表示21。动画演示了循环从大数中减去小数，直到其中一段的长度为0，此时剩下的一条线段的长度就是252和105的最大公约数。 关于最大公约数 基础定义 欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g，意思是能够同时整除a和b的自然数中最大的一个。两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。参考最大公约数的演示动画：一个24×60的长方形正好被十个12×12的方格填满，其中12是24和60的最大公约数。一般地，当且仅当c是a和b的公约数时，a×b尺寸的长方形可被边长c的正方形正好填满。 环论定义 在数学中，尤其是高等数学的环论中，最大公约数有一个更加巧妙的定义：a和b的最大公约数g是a和b的线性和中（绝对值）最小的一个，即所有形如ua + vb（其中u和v是整数）的数中（绝对值）最小的数。所有ua + vb都是g的整数倍（ua + vb = mg，其中m是整数）。 举例例如，计算a = 1071和b = 462的最大公约数的过程如下：从1071中不断减去462直到小于462（可以减2次，即商q0 = 2），余数是147：1071 = 2 × 462 + 147.然后从462中不断减去147直到小于147（可以减3次，即q1 = 3），余数是21：462 = 3 × 147 + 21.再从147中不断减去21直到小于21（可以减7次，即q2 = 7），没有余数：147 = 7 × 21 + 0.此时，余数是0，所以1071和462的最大公约数是21。 算法递归int Gcd(int a, int b)&#123; if(b == 0) return a; return Gcd(b, a % b);&#125; 迭代int Gcd(int a, int b)&#123; while(b != 0) &#123; int r = b; b = a % b; a = r; &#125; return a;&#125; 扩展欧几里得算法介绍扩展欧几里德算法是用来在已知a, b求解一组p，q使得p*a+q*b=Gcd(a,b)(根据数论中的相关定理解一定存在，不展开叙述)。扩展欧几里德常用在求解模线性方程及方程组中。 算法int exGcd(int a, int b, int &amp;x, int &amp;y)&#123; if(b == 0) &#123; x = 1; y = 0; return a; &#125; int r = exGcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return r;&#125; 理解把这个实现和Gcd的递归实现相比，发现多了下面的x,y赋值过程，这就是扩展欧几里德算法的精髓。可以这样思考:对于a&#39; =b , b&#39; =a%b 而言，我们求得x, y使得a&#39; x+b&#39; y=Gcd(a&#39;, b&#39;)由于b&#39; = a % b = a - a / b * b那么可以得到: a&apos; x + b&apos; y = Gcd(a&apos; , b&apos;)===&gt;bx + (a - a/b *b)y = Gcd(a&apos; , b&apos;) = Gcd(a, b) //注意到这里的/是C语言中的出发===&gt;ay + b(x- a/b *y) = Gcd(a, b) 因此对于a和b而言，他们的相对应的p，q分别是 y和(x-a/b*y) Stein算法介绍Stein算法由J. Stein 1961年提出，这个方法也是计算两个数的最大公约数。和欧几里德算法 算法不同的是，Stein算法只有整数的移位和加减法，因此对于大素数Stein将更有优势。 描述注意到如下结论： 如果A=0，B是最大公约数，算法结束 如果B=0，A是最大公约数，算法结束 设置A1=A、B1=B和C1=1 如果An和Bn都是偶数，则An+1=An&gt;&gt;1，Bn+1=Bn&gt;&gt;1，Cn+1=Cn&lt;&lt;1 如果An是偶数，Bn不是偶数，则An+1=An&gt;&gt;1，Bn+1=Bn，Cn+1=Cn(很显然，2不是奇数的约数) 如果Bn是偶数，An不是偶数，则Bn+1=B&gt;&gt;1，An+1=An，Cn+1=Cn(很显然，2不是奇数的约数) 如果An和Bn都不是偶数，则An+1=|An-Bn|&gt;&gt;1，Bn+1=min(An,Bn)，Cn+1=Cn n加1，转1 算法int Gcd(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(a % 2 == 0 &amp;&amp; b % 2 == 0) return 2 * gcd(a &gt;&gt; 1, b &gt;&gt; 1); else if(a % 2 == 0) return gcd(a &gt;&gt; 1, b); else if(b % 2 == 0) return gcd(a, b &gt;&gt; 1); else return gcd(abs(a - b), Min(a, b));&#125; 应用 求解不定方程 对于不定整数方程pa+qb=c，若 c mod Gcd(p, q)=0,则该方程存在整数解，否则不存在整数解。上面已经列出找一个整数解的方法，在找到p a+q b = Gcd(p, q)的一组解p0,q0后，p a+q b = Gcd(p, q)的其他整数解满足： p = p0 + b/Gcd(p, q) * t q = q0 - a/Gcd(p, q) * t(其中t为任意整数) 至于pa+qb=c的整数解，只需将p a+q b = Gcd(p, q)的每个解乘上 c/Gcd(p, q) 即可。在找到p a+q b = Gcd(a, b)的一组解p0,q0后，应该是得到p a+q b = c的一组解p1 = p0(c/Gcd(a,b)),q1 = q0(c/Gcd(a,b))，p a+q b = c的其他整数解满足： p = p1 + b/Gcd(a, b) * t q = q1 - a/Gcd(a, b) * t(其中t为任意整数) 此处的p 、q就是p a+q b = c的所有整数解。 求解模线性方程（线性同余方程） 同余方程 ax≡b (mod n)对于未知数 x 有解，当且仅当 gcd(a,n) | b。且方程有解时，方程有 gcd(a,n) 个解。求解方程 ax≡b (mod n) 相当于求解方程 ax+ ny= b, (x, y为整数)。设 d= gcd(a,n)，假如整数 x 和 y，满足 d= ax+ ny(用扩展欧几里德得出)。如果 d| b，则方程a x0+ n y0= d， 方程两边乘以 b/ d，(因为 d|b，所以能够整除)，得到 a x0 b/ d+ n y0 b/ d= b。所以 x= x0 b/ d，y= y0 b/ d 为 ax+ ny= b 的一个解，所以 x= x0 b/ d 为 ax= b (mod n ) 的解。ax≡b (mod n)的一个解为 x0= x (b/ d ) mod n，且方程的 d 个解分别为 xi= (x0+ i (n/ d ))mod n {i= 0… d-1}。设ans=x(b/d),s=n/d;方程ax≡b (mod n)的最小整数解为：(ans%s+s)%s; 求解模的逆元 同余方程ax≡b (mod n)，如果 gcd(a,n)== 1，则方程只有唯一解。在这种情况下，如果 b== 1，同余方程就是 ax=1 (mod n ),gcd(a,n)= 1。这时称求出的 x 为 a 的对模 n 乘法的逆元。对于同余方程 ax= 1(mod n )， gcd(a,n)= 1 的求解就是求解方程ax+ ny= 1，x, y 为整数。这个可用扩展欧几里德算法求出，原同余方程的唯一解就是用扩展欧几里德算法得出的 x 。 引用 最大公约数(Gcd)两种算法(Euclid &amp;&amp; Stein) [整理] 辗转相除法 ACM 进阶学习第一课—-同余相关之欧几里得算法及其扩展（2） 更新日志 2015年03月18日 拖了这么久，总算写完了= =。 2015年03月19日 补充了扩展欧几里得算法的一些应用。","categories":[{"name":"Summary","slug":"Summary","permalink":"https://xuanwo.org/categories/Summary/"}],"tags":[]},{"title":"青云参观计划","slug":"Event-Qingcould-Plan","date":"2015-02-18T22:50:33.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2015/02/18/Event-Qingcould-Plan/","link":"","permalink":"https://xuanwo.org/2015/02/18/Event-Qingcould-Plan/","excerpt":"","text":"青云是啥？ 想做中国的AWS：IaaS提供商QingCloud按“秒”计费实现弹性特征，瞄准中国的DevOps开发市场 国内创业公司QingCloud的魄力：做一个世界级的IaaS服务 青云B轮获2000万美元VC的背后逻辑：用技术超越巨头 个人认为对其的了解有助与我们信息管理专业的发展，所以尝试着联系了一下青云的有关人士。后来发现青云那边的人非常nice，非常热心，非常爽快的同意了我们的请求，所以开学后不久我们就可以出发啦。 青云在哪？地址：北京市朝阳区北苑路甲13号北辰新纪元大厦2号楼1503公交路线：地铁13号线 → 地铁2号线 → 地铁5号线全程约1小时 五道口 3站乘坐 地铁13号线(西直门方向), 在 西直门站 下车420米站内换乘 地铁2号线(内环) 4站乘坐 地铁2号线(内环), 在 雍和宫站 下车160米站内换乘 地铁5号线(天通苑北方向) 6站乘坐 地铁5号线(天通苑北方向), 在 北苑路北站 下车(A2西北口出)350米步行至 北辰新纪元2 去看什么？ 公司参观 员工分享个人经历 CEO分享关于云计算的理解 啥时候去？2015年3月19日14点 有啥收获？这个根据看到了什么而定，不过涨姿势肯定是有的~我想看看真正的服务器长啥样= = 更新日志 2015年02月18日 发起活动，修正行文格式。 2015年03月18日 补充活动更新信息。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[{"name":"Event","slug":"Event","permalink":"https://xuanwo.org/tags/Event/"}]},{"title":"Codeforces Beta Round 65 A Way Too Long Words (Div. 2)","slug":"CF-71A","date":"2015-02-10T23:11:25.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2015/02/10/CF-71A/","link":"","permalink":"https://xuanwo.org/2015/02/10/CF-71A/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/71/A 理解刷水题，保持手指灵活性= =","text":"题目源地址： http://codeforces.com/problemset/problem/71/A 理解刷水题，保持手指灵活性= = 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 100+10int n;char a[MAXN];int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; memset(a, 0, sizeof(a)); scanf(&quot;%s&quot;, a); int len = strlen(a); if (len &lt;= 10) cout &lt;&lt; a &lt;&lt; endl; else cout &lt;&lt; a[0] &lt;&lt; len - 2 &lt;&lt; a[len - 1] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2015年2月10日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"VK Cup 2012 Qualification Round 1 A Next Round","slug":"CF-158A","date":"2015-02-10T22:07:24.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2015/02/10/CF-158A/","link":"","permalink":"https://xuanwo.org/2015/02/10/CF-158A/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/158/A 理解水题","text":"题目源地址： http://codeforces.com/problemset/problem/158/A 理解水题 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 50+10int n, k;int a[MAXN];int ans = 0;bool cmp(int x, int y)&#123; return x &gt; y;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, a + n, cmp); for(int i=0;i&lt;n;i++) &#123; if(a[i]&gt;=a[k-1]&amp;&amp;a[i]&gt;0) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 更新日志 2015年2月10日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"使用Github SSH Key以免去Hexo部署时输入密码","slug":"generate-a-ssh-key","date":"2015-02-07T14:40:16.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2015/02/07/generate-a-ssh-key/","link":"","permalink":"https://xuanwo.org/2015/02/07/generate-a-ssh-key/","excerpt":"前言原文本来放在Hexo常见问题解决方案之中，但是由于步骤较多，理解起来比较困难，因此将本文独立出来单独成篇，以便于进行操作。","text":"前言原文本来放在Hexo常见问题解决方案之中，但是由于步骤较多，理解起来比较困难，因此将本文独立出来单独成篇，以便于进行操作。 操作修改_config.yml将_config.yml的git信息修改为SSH形式。 列出已存在的SSH Key打开Git Bash，并且输入：ls -al ~/.ssh 这个命令会列出你.ssh账户中已经存在的SSH key，如果之前没有设置过，一般都是没有。 生成密钥然后输入：ssh-keygen -t rsa -C &quot;your_email@example.com&quot;这个命令将会生成一个以your_email@example.com为标签的ssh key，然后bash中会显示： Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，然后出现： Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 因为追求操作方便，我们不打算在deploy的时候输入这个passphrase，所以直接回车两次设为空。然后你会看到： Your identification has been saved in ~/.ssh/id_rsa.Your public key has been saved in ~/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 加入SSH Agent下一步输入：ssh-agent -s 如果出现类似Agent pid XXXX这样的字样，则跳过下一步，否则输入： eval `ssh-agent -s` 直到出现Agent pid XXXX这样的提示之后，输入： ssh-add ~/.ssh/id_rsa 这样，你成功的在本地生成了一个可用的SSH key。 将SSH Key添加到Github中下面将这个key添加到github网站。打开https://github.com/settings/ssh，点击Add SSH Key，复制id_rsa.pub中的所有内容到Key框中，在Title框中输入方便自己记忆的名字（建议输入能让自己明白是哪台电脑的名字，方便以后管理）。当网页显示添加成功后，就已经完成了全部的操作。下面进行一些测试，同样是打开Git Bash，输入：ssh -T git@github.com bash中会显示如下字样： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes之后，计算机会自动将github.com列入已知的host，然后会出现如下提示： Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 如果成功看见，说明你已经配置好了，快去享受爽快的hexo一键部署吧；如果出现任何错误提示，请仔细检查自己的操作，或者将错误信息发给我。 更新日志 2015年02月07日 独立成篇 2015年02月16日 补充_config.yml的修改 2015年03月22日 修复了一处代码显示BUG 2016年04月07日 修复了部分代码格式问题","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"}]},{"title":"使用Travis CI自动部署Hexo","slug":"Travis-CI-Hexo-Autodeploy","date":"2015-02-07T14:00:51.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/02/07/Travis-CI-Hexo-Autodeploy/","link":"","permalink":"https://xuanwo.org/2015/02/07/Travis-CI-Hexo-Autodeploy/","excerpt":"前言前两天了解到了一个有趣的概念叫持续集成： 持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次，也可以多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。这篇文章简要介绍了持续集成的技巧和它最新的应用。然后想到我的博客也恰好满足这样的需求，因为我的博客一旦有了修改，就必须要重新build并且部署，那么能不能用持续集成的思想来改造我部署博客的流程呢？ 在这样的指导思想下，我完成了上一篇文章：VPS搭配Github Webhook实现Hexo自动发布，而今天我要介绍一下，在没有VPS的情况下，如何更方便的配置自己的持续集成的博客。 好处 方便：只需要一次配置，便省去了每一次编辑文档后，都需要进行hexo d -g的麻烦，更不必说文章增多之后渲染时间还会增长。 稳定：这个是最近才发现的，Github被搞了之后，很多人反映不能更新博客了，使用Travis CI，你只要想办法提交一个小md文档，就能进行构建。如果自己手动构建，只要一个文件上传失败，前面的工作都白费了。 快捷：即使是出差在外，只要能编辑Markdown，就可以撰写博客，使得Hexo拥有类似于WP一致的体验~ 协作：博客的构建完全交由Travis CI进行，所以完全可以通过Hexo+git构建一个多人协作的博客平台。实际上，Hexo的官网正是这样构建的。","text":"前言前两天了解到了一个有趣的概念叫持续集成： 持续集成是一种软件开发实践。在持续集成中，团队成员频繁集成他们的工作成果，一般每人每天至少集成一次，也可以多次。每次集成会经过自动构建（包括自动测试）的检验，以尽快发现集成错误。许多团队发现这种方法可以显著减少集成引起的问题，并可以加快团队合作软件开发的速度。这篇文章简要介绍了持续集成的技巧和它最新的应用。然后想到我的博客也恰好满足这样的需求，因为我的博客一旦有了修改，就必须要重新build并且部署，那么能不能用持续集成的思想来改造我部署博客的流程呢？ 在这样的指导思想下，我完成了上一篇文章：VPS搭配Github Webhook实现Hexo自动发布，而今天我要介绍一下，在没有VPS的情况下，如何更方便的配置自己的持续集成的博客。 好处 方便：只需要一次配置，便省去了每一次编辑文档后，都需要进行hexo d -g的麻烦，更不必说文章增多之后渲染时间还会增长。 稳定：这个是最近才发现的，Github被搞了之后，很多人反映不能更新博客了，使用Travis CI，你只要想办法提交一个小md文档，就能进行构建。如果自己手动构建，只要一个文件上传失败，前面的工作都白费了。 快捷：即使是出差在外，只要能编辑Markdown，就可以撰写博客，使得Hexo拥有类似于WP一致的体验~ 协作：博客的构建完全交由Travis CI进行，所以完全可以通过Hexo+git构建一个多人协作的博客平台。实际上，Hexo的官网正是这样构建的。 Travis CI介绍 Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。它提供了多种编程语言的支持，包括Ruby，JavaScript，Java，Scala，PHP，Haskell和Erlang在内的多种语言。许多知名的开源项目使用它来在每次提交的时候进行构建测试，比如Ruby on Rails，Ruby和Node.js。2012年，Travis CI 决定进行募资以支持后续的开发，在这次募资活动中，许多重量级的科技公司给予了资助。 需要注意的是几个特性： 只支持Github 支持JavaScript 开源，免费 然后介绍一下它的原理：Travis CI会在你每一次提交之后生成一个虚拟机来执行你事先安排好的build任务，你可以调整这个虚拟机的软件环境，甚至能执行sudo来进行apt-get install。 Travis CI配置我们知道，Hexo的命令非常简单，一个hexo d -g就可以搞定。困难之处在于，Travis CI并没有对你的库进行push操作的权限。如果直接将私钥放在自己的开源库之中，这无异于将自己的代码库提交权限开放给了所有的Github使用者。所以，为了保护自己，我们需要采取一些配置操作。 感谢Hexo作者tommy351提供的操作流程，原文可见于用 Travis CI 自動部署網站到 GitHub 生成SSH Key参见使用Github SSH Key以免去Hexo部署时输入密码需要注意的是，这个SSH key不应成为你账号的全局SSH key（因为这样Travis CI就获得了你所有代码库的提交权限，这是不正确的），而应该添加至https://github.com/username/ropename/settings/keys ，这样，你就控制了Travis CI的权限。 加密私钥下面的操作需要事先配置好gem环境，如果没有可以尝试使用强大且配置项丰富的在线IDE应用——Cloud9。 安装Travis CI的命令行工具gem install travis 登陆Travis CI需要输入Github账号和密码 travis login --auto 加密私钥并上传至Travis正确生成后你会得到两个文件，一个叫ssh_key，一个叫ssh_key.pub。刚才我们将ssh_key.pub添加到了github，下面我们要加密ssh_key这个私钥并且上传到Travis。 travis encrypt-file ssh_key --add 然后Travis的客户端会自动检测当前目录中的git信息，并且添加到.travis.yml中去。在进行此步操作前，目录下要先存在.travis.yml文件，否则会报错。 指定SSH设置在当前目录下新建文件ssh_config，内容为 Host github.com User git StrictHostKeyChecking no IdentityFile ~/.ssh/id_rsa IdentitiesOnly yes 然后指定openssl解密后的生成位置，修改Travis自动插入的解密指令(不要照抄，注意修改密钥) - openssl aes-256-cbc -K $encrypted_xxxxxxxxxx_key -iv $encrypted_xxxxxxxxxx_iv -in travis.enc -out ~/.ssh/id_rsa -d 修改目录权限紧跟那条解密指令，换行输入： - chmod 600 ~/.ssh/id_rsa 注意yml格式，短杠后面的空格不能省略。 将密钥加入系统紧跟上一步操作，换行输入： - eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa 修改git信息将之前创建的ssh_config复制到Travis的虚拟机中去，输入： - cp ssh_config ~/.ssh/config 然后指定git使用者信息： - git config --global user.name &quot;username&quot;- git config --global user.email username@example.com Build配置之前的所有操作都只是为了让Travis CI拥有push权限，下面我们开始进入到真正的Build配置当中。之前我们用到了一个名为.travis.yml的文件，跟build有关的所有设置都在这个文件里面，下面的操作都在这个文件当中进行。 指定环境在文件中添加如下代码： language: node_jsnode_js:- &apos;0.10&apos; //指定使用node.js最新的稳定版0.10 指定分支在文件中添加如下代码： branches: only: - blog //这个分支应当使用自己的源文件分支 差点忘了讲- -，本方案只适用于用github来托管自己自己的hexo目录的用户。这里的分支应该使用包含有.md文档的那个分支。 Hexo配置首先在虚拟机中安装Hexo： install:- npm install hexo-cli -g- npm install hexo --save- npm install 然后执行Hexo的渲染操作 script:- hexo clean //分开写，方便调试可能出现的错误- hexo d- hexo g 到这里，你的Travis CI的持续集成已经配置完毕了，最后的.travis.yml文件内容可以参考如下： branches: only: - bloglanguage: node_jssudo: falsenode_js:- &apos;0.12&apos;before_install:- openssl aes-256-cbc -K $encrypted_xxxxxxxxx_key -iv $encrypted_xxxxxxx_iv -in doc/travis.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- eval $(ssh-agent)- ssh-add ~/.ssh/id_rsa- cp doc/ssh_config ~/.ssh/config- git config --global user.name &quot;yourname&quot;- git config --global user.email youremail- git clone -b master git@github.com:yourname/yourrepo.git .deploy_gitinstall:- npm install hexo-cli -g- npm install- npm install hexo-generator-feed --save- npm install hexo-generator-sitemap --save- npm install hexo-deployer-git --savescript:- hexo clean- hexo g- hexo d 更新日志 2015年02月07日 首次发布，感谢Tommy351 2015年02月16日 跟随Hexo版本更新，修改了相关代码。 2015年03月22日 Hexo3.0稳定版发布，修改相关代码，并修复部分显示问题。 2015年04月01日 因为自己的.travis.yml有大幅度修改，所以重新添加了相关代码，避免产生困扰。 2015年10月23日 修复部分错字，更新了.travis.yml","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"}]},{"title":"VPS搭配Github Webhook实现Hexo自动发布","slug":"VPS-Hexo-Autodeploy","date":"2015-02-05T23:22:30.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/02/05/VPS-Hexo-Autodeploy/","link":"","permalink":"https://xuanwo.org/2015/02/05/VPS-Hexo-Autodeploy/","excerpt":"前言自从买了VPS之后，我的人生就多了一个需要思考的问题——我的VPS还能用来干嘛？然后想到Github有一个Webhook的功能，可以在每一次提交之后发送一个POST到指定的URL。那么，只要找一个办法获取这个POST，再执行指定的命令，可以实现Hexo的自动发布功能了。从此以后，不管在哪里，我只要修改我的md文件，push之后我的服务器就能自动进行编译并且部署了。","text":"前言自从买了VPS之后，我的人生就多了一个需要思考的问题——我的VPS还能用来干嘛？然后想到Github有一个Webhook的功能，可以在每一次提交之后发送一个POST到指定的URL。那么，只要找一个办法获取这个POST，再执行指定的命令，可以实现Hexo的自动发布功能了。从此以后，不管在哪里，我只要修改我的md文件，push之后我的服务器就能自动进行编译并且部署了。 配置Nginx安装Nginx使用apt-get程序来安装nginx apt-get updateapt-get install nginx 在浏览器中访问http://your-ip-address or domain/， 如果看到Welcome to nginx!字样，说明Nginx已经安装成功了。 配置Nginx修改/etc/nginx/sites-available/default文件，在serve的框里面的空行中输入： location /update &#123;proxy_pass http://127.0.0.1:1111;&#125; 这样设置之后http://your-ip-address or domain/update访问就会被重定向到1111端口。 重启Nginx输入：/etc/init.d/nginx restart 配置Git安装Git输入：apt-get install git 下载自己的代码库输入：git clone yourgit yourdir 配置Python安装Python环境输入：apt-get install python-pip然后系统会自动完成相关的配置。 编辑Python文件输入： cd ~/yourdirvi hook.py 在打开的vim界面中，点击一下i，进入insert模式，然后粘贴以下代码： #!/usr/bin/env python3#-*- coding:utf-8 -*-# start a python service and watch the nginx request dogfrom http.server import HTTPServer,CGIHTTPRequestHandlerfrom threading import Thread,RLockimport subprocessimport loggingimport sysimport os.path_PWD=os.path.abspath(os.path.dirname(__file__))def execute_cmd(args,cwd=None,timeout=30): if isinstance(args,str): args = [args] try: with subprocess.Popen(args,stdout=subprocess.PIPE,cwd=cwd) as proc: try: output,unused_err = proc.communicate(timeout=timeout) except: proc.kill() raise retcode = proc.poll() if retcode: raise subprocess.CalledProcessError(retcode, proc.args, output=output) return output.decode(&apos;utf-8&apos;,&apos;ignore&apos;) if output else &apos;&apos; except Exception as ex: logging.error(&apos;EXECUTE_CMD_ERROR: %s&apos;,&apos; &apos;.join(str(x) for x in args)) raise exclass HttpHandler(CGIHTTPRequestHandler): _lock = RLock() _counter = 0 _building = False def build(self): with HttpHandler._lock: if HttpHandler._counter == 0 or HttpHandler._building: return HttpHandler._counter = 0 HttpHandler._building = True logging.info(&quot;BUILDING NOW...&quot;) try: resp = execute_cmd(os.path.join(_PWD,&apos;build.sh&apos;),cwd=_PWD,timeout=600) logging.info(resp) finally: HttpHandler._building = False self.build() def do_GET(self): self.do_POST() def do_POST(self): self.send_response(200,&apos;OK&apos;) self.end_headers() self.wfile.write(b&apos;OK&apos;) self.wfile.flush() with HttpHandler._lock: HttpHandler._counter += 1 Thread(target=self.build).start()if __name__ == &apos;__main__&apos;: logging.basicConfig(format=&apos;%(asctime)s %(levelname)s: %(message)s&apos;,level=logging.INFO) port = int(sys.argv[1]) if len(sys.argv) &gt; 1 else 1111 logging.info(&apos;starting the server at 127.0.0.1:%s&apos;,port) httpd = HTTPServer((&apos;127.0.0.1&apos;,port),HttpHandler) httpd.serve_forever() 编辑完成后，输入:wq退出vi。 编辑sh文件切换到yourdir，然后输入：vi build.sh在打开的vi界面中，点击i进入编辑模式，然后输入： #!/bin/bashecho &quot;build at `date`&quot;. ~/.nvm/nvm.shnvm use 0.10.36cd ~/xuanwogit pullhexo cleanhexo d -gecho &quot;built successfully&quot; 编辑完成后，输入:wq退出vi。 后台运行Python脚本进行监视运行：nohup python3 ~/xuanwo/hook.py &gt;&gt; /tmp/hook.log 2&gt;&amp;1 &amp;每次重启VPS后，貌似都需要运行一次 更新日志 2015年2月6日 首次发布","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"VPS","slug":"VPS","permalink":"https://xuanwo.org/tags/VPS/"}]},{"title":"超星学术视频下载处理一条龙","slug":"chaoxing-download","date":"2015-01-07T01:12:07.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2015/01/07/chaoxing-download/","link":"","permalink":"https://xuanwo.org/2015/01/07/chaoxing-download/","excerpt":"前言我妹纸最近开始通过看超星学术视频来复习预习课程了，所以我必须搞到对应课程的所有视频（不管是收费还是免费），而且我妹纸还是一个有强迫症的萌妹纸，所有的视频都必须按照顺序拍的好好的，要不然她就会不舒服。根据以上描述，我需要解决以下需求： 破解超星学术视频的加密链接，找到真实的下载链接。 重命名下载下来的视频文件。 还是跟以往一样，直接把最终的解决方案放出来，要是对具体的实现感兴趣的可以接着往下面看。","text":"前言我妹纸最近开始通过看超星学术视频来复习预习课程了，所以我必须搞到对应课程的所有视频（不管是收费还是免费），而且我妹纸还是一个有强迫症的萌妹纸，所有的视频都必须按照顺序拍的好好的，要不然她就会不舒服。根据以上描述，我需要解决以下需求： 破解超星学术视频的加密链接，找到真实的下载链接。 重命名下载下来的视频文件。 还是跟以往一样，直接把最终的解决方案放出来，要是对具体的实现感兴趣的可以接着往下面看。 解决方案超星学术视频下载处理一条龙 破解加密链接用到了在某宝上面购买的超星学术视频解析下载工具。双击打开，粘贴上视频页的地址，然后点一下解析，就会这样：然后右击选择保存视频列表，就会自动在当前目录下生成一个用课程名字命名的txt文件，一般内容如下： 视频名称：透过性别看爱情作者：沈奕斐出处：复旦大学透过性别看爱情（一） http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a888dc9b2f5485762f7透过性别看爱情（二） http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a88c47ff350721a07be透过性别看爱情（三） http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a8845f30d4554db33f3透过性别看爱情（四） http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a88a53d9d0554a78ace 下载地址处理软件自身的下载速度太慢，而且不支持断点续传，所以自然就想到使用旋风这样的下载工具来下载。那么问题来了，我怎么样才能把我前面得到的列表处理成可以直接创建任务的格式呢？想到了C++的freopen命令，加上字符串处理，妥妥的有木有。思路比较简单，就不详细说明具体的实现了，直接上代码： #define MAXN 10000+10char a[MAXN][MAXN];int i = 0;int main(int argc, char const *argv[])&#123; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); while (~scanf(&quot;%s&quot;, a[i++])) &#123; ; &#125; for (int j = 1; j &lt; i; j += 2) //一定要考虑视频列表的空格分隔 &#123; cout &lt;&lt; a[j] &lt;&lt; endl; &#125; return 0;&#125; 使用这个处理之后的结果就是这样 http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a888dc9b2f5485762f7http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a88c47ff350721a07behttp://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a8845f30d4554db33f3http://video.superlib.com/a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a88a53d9d0554a78ace 根据代码很容易就能看出来，你得自己把视频名称神马的玩意儿删掉，要不然是不能得到正确结果的= =。有空的时候再来优化一下，现在先将就着用。 视频重命名新的问题来了，下载到的视频全都是a8076e683f89741b4f3b266630697ce98d21d700d106a701d45b535e52f87a88a53d9d0554a78ace这样的格式，根本就不能区别到底是什么内容。我一开始的办法是自己手动定位，手动重命名。重复了几次之后，感觉不能忍，效率太低了，我得想想办法。在windows的cmd中，ren a b命令可以把当前目录下a文件重命名为b。然后我又知道，在cpp文件中，可以通过system()函数调用cmd中的命令。于是解决方案出来了，我只要构造出一个命令的字符串就能解决这样的问题。 #define MAXN 500char before[MAXN], after[MAXN];int main(int argc, char const *argv[])&#123; freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); while (~scanf(&quot;%s%s&quot;, after, before)) &#123; char order[MAXN] = &quot;ren &quot;; int lensub = strlen(before + 26); //用来清除http://video.superlib.com/这个前缀 for (int i = 0; i &lt; lensub; i++) &#123; before[i] = before[i + 26]; //得到正确的文件名 &#125; before[lensub] = &apos;\\0&apos;; strcat(order, before); //strcat(a,b)，将字符串b接在a的后面 int len = strlen(order); order[len] = &apos; &apos;; order[len + 1] = &apos;\\0&apos;; strcat(order, after); system(order);//system(&quot;abc&quot;)，在cmd中执行abc命令 memset(after, 0, sizeof(after)); memset(before, 0, sizeof(before)); &#125; return 0;&#125; 就这样，轻松搞定了~。有一个缺陷是，这样重命名出来的文件是没有后缀名的，还需要自己再处理一下。嗯哼，还是一样的，先将就着用吧，回头再来优化一下。 尾言除了下载工具，所有代码（虽然垃圾，但还是劳动成果啊= =）都是我个人的作品，转载请注明来源。 更新日志 2015年01月07日 首次更新，首个版本发布啦。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"C","slug":"C","permalink":"https://xuanwo.org/tags/C/"}]},{"title":"CF拉练第七场","slug":"Contest-CUGB-CF7","date":"2014-11-26T16:40:28.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/11/26/Contest-CUGB-CF7/","link":"","permalink":"https://xuanwo.org/2014/11/26/Contest-CUGB-CF7/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=63852#overview 比赛总结这场比赛做的很渣，第一题卡了很久，还WA了两发。第二题一个裸的最短路模板题还折腾了半天。第三题是一个比较简单的数论题，用到了GCD。然后D和E都没有敲出来，其实D是一个要用到一点技巧的裸Nim。而E题。。。正面解法思绪繁杂，没有捋出来，而从结果入手开开脑洞倒是可以有点思路= =。 分题讲解A题（暴力）从前后分别入手求出和，然后对应进行判断即可。http://xuanwo.org/2014/11/26/CF-18C/ B题（最短路）模板题，注意路径的输出。http://xuanwo.org/2014/11/26/CF-20C/ C题（数论）用到了GCD，只要找出原来的最简比例就可以了。http://xuanwo.org/2014/11/26/CF-16C/ D题（Nim博弈）用到了很多异或的性质，位运算果然是一门大学问。http://xuanwo.org/2014/11/26/CF-15C/ E题（DP，构造）这个题= =，还没有办法证明。http://xuanwo.org/2014/11/23/CF-15E/ 更新日志 2014年11月26日 完成题解。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 15 C Industrial Nim","slug":"CF-15C","date":"2014-11-26T14:25:00.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/26/CF-15C/","link":"","permalink":"https://xuanwo.org/2014/11/26/CF-15C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/15/C 理解有n个矿场，第i个矿场有mi辆矿车，第一辆矿车有xi颗石头，第二辆xi+1颗，如此递推，直到第mi辆有mi+xi-1颗。然后有两个人轮流取石头（金矿？），他们可以选择任意一个矿场任意一辆矿车取走任意非0数量的石头，直到第一个不能再取的人认输。实际上，这就是一个裸的Nim博弈问题，只要直接运用结论就能完成解答。但是问题在于，数据太多，导致每一个全都异或起来的话耗时太长。所以需要采用一些手段处理一下。我们需要用到两个结论：第一，从1异或到n的答案存在着这样一个特性：n%4==1时，答案为1；n%4==2时，答案为x+1；n%4==3时，答案为0；n%4==4时，答案为x。第二，从x异或到y的值等于nim(x-1)^nim(y)。经过上述的处理，最后的结果就出来了~","text":"题目源地址： http://codeforces.com/problemset/problem/15/C 理解有n个矿场，第i个矿场有mi辆矿车，第一辆矿车有xi颗石头，第二辆xi+1颗，如此递推，直到第mi辆有mi+xi-1颗。然后有两个人轮流取石头（金矿？），他们可以选择任意一个矿场任意一辆矿车取走任意非0数量的石头，直到第一个不能再取的人认输。实际上，这就是一个裸的Nim博弈问题，只要直接运用结论就能完成解答。但是问题在于，数据太多，导致每一个全都异或起来的话耗时太长。所以需要采用一些手段处理一下。我们需要用到两个结论：第一，从1异或到n的答案存在着这样一个特性：n%4==1时，答案为1；n%4==2时，答案为x+1；n%4==3时，答案为0；n%4==4时，答案为x。第二，从x异或到y的值等于nim(x-1)^nim(y)。经过上述的处理，最后的结果就出来了~ 代码#define MAXN 100000+10ll n,x,m,ans=0;ll nim(ll x)&#123; ll tmp=x%4; if(tmp==1) return 1; else if(tmp==2) return x+1; else if(tmp==3) return 0; else return x;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%I64d&quot;, &amp;n); while(n--) &#123; scanf(&quot;%I64d %I64d&quot;, &amp;x, &amp;m); m=nim(m+x-1); x=nim(x-1); ans^=x^m; &#125; ans?puts(&quot;tolik&quot;):puts(&quot;bolik&quot;); return 0;&#125; 更新日志 2014年11月26日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 16 C Monitor (Div. 2 Only)","slug":"CF-16C","date":"2014-11-26T14:04:11.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/26/CF-16C/","link":"","permalink":"https://xuanwo.org/2014/11/26/CF-16C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/16/C 理解一道关于分辨率转化的问题。要求将一个大分辨率按照指定的宽高比进行转化，如果宽高比不符，则进行切割。首先，我们来求一个x和y的最大公约数d，然后分别令x=x/d，y=y/d，这样就得到了x和y之间最简的比例形式。然后a和b分别去除以x和y，得到的两个背书中去掉小数部分较小的那个，就是切割之后的倍数比。最后得到的结果就是符合要求的结果。","text":"题目源地址： http://codeforces.com/problemset/problem/16/C 理解一道关于分辨率转化的问题。要求将一个大分辨率按照指定的宽高比进行转化，如果宽高比不符，则进行切割。首先，我们来求一个x和y的最大公约数d，然后分别令x=x/d，y=y/d，这样就得到了x和y之间最简的比例形式。然后a和b分别去除以x和y，得到的两个背书中去掉小数部分较小的那个，就是切割之后的倍数比。最后得到的结果就是符合要求的结果。 代码ll a,b,x,y;ll d,t1,t2;void init()&#123; scanf(&quot;%I64d%I64d%I64d%I64d&quot;, &amp;a, &amp;b, &amp;x, &amp;y);&#125;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a%b) : a;&#125;int main(int argc, char const *argv[])&#123; init(); d = gcd(x, y); x = x / d, y = y / d; t1 = a / x; t2 = b / y; t1 = min(t1, t2); cout&lt;&lt;x*t1&lt;&lt;&quot; &quot;&lt;&lt;y*t1&lt;&lt;endl; return 0;&#125; 更新日志 2014年11月26日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Alpha Round 20 C Dijkstra? (Codeforces format)","slug":"CF-20C","date":"2014-11-26T13:59:18.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/26/CF-20C/","link":"","permalink":"https://xuanwo.org/2014/11/26/CF-20C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/20/C 理解实际上题目不难，但是我们都捣鼓了很久。原因是我们根本就没有掌握这种算法，导致连一个输出路径都搞得这么蛋疼。使用邻接表来存储每一个节点，每一个节点都自带一个指针指向下一个节点（可以自己使用数组模拟），最后的结果倒过来输出即可。","text":"题目源地址： http://codeforces.com/problemset/problem/20/C 理解实际上题目不难，但是我们都捣鼓了很久。原因是我们根本就没有掌握这种算法，导致连一个输出路径都搞得这么蛋疼。使用邻接表来存储每一个节点，每一个节点都自带一个指针指向下一个节点（可以自己使用数组模拟），最后的结果倒过来输出即可。 代码#define MAXN 100000*4+10const ll maxd = 1E13;int v[MAXN],w[MAXN],next[MAXN],pre[MAXN],res[MAXN];int first[MAXN],inq[MAXN],e;ll d[MAXN];int m,n;int x,y,z;void addeage(int x,int y,int z)&#123; v[e]=y; w[e]=z; next[e]=first[x]; first[x]=e; e++;&#125;void spfa(int s)&#123; queue&lt;int&gt; q; for(int i =0; i&lt;MAXN; i++) d[i]=maxd; d[s]=0; inq[s]=1; q.push(s); while(q.empty()==false) &#123; int u = q.front(); q.pop(); inq[u]=0; for(int i =first[u]; i!=-1; i=next[i]) &#123; if(d[v[i]]&gt;d[u]+w[i]) &#123; d[v[i]]=(d[u]+w[i]); pre[v[i]]=u; if(inq[v[i]]==0) &#123; q.push(v[i]); inq[v[i]]=1; &#125; &#125; &#125; &#125;&#125;void init()&#123; for(int i=0; i&lt;MAXN; i++) &#123; first[i]=-1; &#125; e=0; scanf(&quot;%d%d&quot;,&amp;m,&amp;n); while(n--) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); addeage(x,y,z); addeage(y,x,z); &#125;&#125;int main(int argc, char const *argv[])&#123; init(); spfa(1); if(d[m]==maxd) printf(&quot;-1&quot;); else &#123; int now=m; int cnt=0; while(now!=1) &#123; res[cnt++] = now; now = pre[now]; &#125; res[cnt++] = 1; for(int i = cnt-1; i &gt;= 0; i--) printf(&quot;%d &quot;,res[i]); &#125; return 0;&#125; 更新日志 2014年11月26日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 18 C Stripe (Div.2 Only)","slug":"CF-18C","date":"2014-11-26T13:16:29.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/26/CF-18C/","link":"","permalink":"https://xuanwo.org/2014/11/26/CF-18C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/18/C 理解题意很简单，把一个给定的数列分成两份，要求两份数字之和相等。直接暴力乱搞，预处理的时候用两个数组分别保存前后缀的数字之和，然后只要遍历一遍，就能得到最后的结果。","text":"题目源地址： http://codeforces.com/problemset/problem/18/C 理解题意很简单，把一个给定的数列分成两份，要求两份数字之和相等。直接暴力乱搞，预处理的时候用两个数组分别保存前后缀的数字之和，然后只要遍历一遍，就能得到最后的结果。 代码#define MAXN 100000+10int a[MAXN];int b[MAXN];int c[MAXN];int n,ans;void init()&#123; scanf(&quot;%d&quot;,&amp;n); b[0]=0; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); b[i]=b[i-1]+a[i]; &#125; for(int j=n; j&gt;=1; j--) &#123; c[j]=c[j+1]+a[j]; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); for(int i=1; i&lt;n; i++) &#123; if(b[i]==c[i+1]) ans++; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 更新日志 2014年11月26日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 272 TEX Quotes","slug":"UVa-272-TEX-Quotes","date":"2014-11-25T10:40:48.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/25/UVa-272-TEX-Quotes/","link":"","permalink":"https://xuanwo.org/2014/11/25/UVa-272-TEX-Quotes/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=208 理解同样的，题目很简单。只需要考虑当前处理的是前面的还是后面的那个引号。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=208 理解同样的，题目很简单。只需要考虑当前处理的是前面的还是后面的那个引号。 代码char a;int flag=0;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%c&quot;, &amp;a)) &#123; if(a==&apos;&quot;&apos;) &#123; flag++; if(flag%2==1) &#123; printf(&quot;%s&quot;, &quot;``&quot;); &#125; else &#123; printf(&quot;%s&quot;, &quot;&apos;&apos;&quot;); &#125; &#125; else &#123; printf(&quot;%c&quot;, a); &#125; &#125; return 0;&#125; 更新日志 2014年11月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10082 WERTYU","slug":"UVa-10082-WERTYU","date":"2014-11-25T10:34:01.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/25/UVa-10082-WERTYU/","link":"","permalink":"https://xuanwo.org/2014/11/25/UVa-10082-WERTYU/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=1023 理解很简单的一道题，不过想了很久。我觉得需要注意的地方大概有三处： 不用自己手写所有情况的判断，使用一个字符串数组可以高效地解决问题。 可以采用一边读入一边处理的方法，不需要开一个数组来保存所有的数，更何况那样做还要处理空格和回车的问题。 读题的时候忽略了两处地方，多行以及没有QAZ这些字符，导致最后处理的时候出现了问题。注意到这些，这道题就可以轻松A了。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=829&amp;page=show_problem&amp;problem=1023 理解很简单的一道题，不过想了很久。我觉得需要注意的地方大概有三处： 不用自己手写所有情况的判断，使用一个字符串数组可以高效地解决问题。 可以采用一边读入一边处理的方法，不需要开一个数组来保存所有的数，更何况那样做还要处理空格和回车的问题。 读题的时候忽略了两处地方，多行以及没有QAZ这些字符，导致最后处理的时候出现了问题。注意到这些，这道题就可以轻松A了。 代码#define MAXN 50char a[MAXN]=&quot;`1234567890-=QWERTYUIOP[]\\\\ASDFGHJKL;&apos;ZXCVBNM,./&quot;;char b;int len=strlen(a);int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%c&quot;, &amp;b)) &#123; if(b==&apos; &apos;) printf(&quot; &quot;); else if(b==&apos;\\n&apos;) printf(&quot;\\n&quot;); else &#123; for(int i=0;i&lt;len;i++) &#123; if(b==a[i]) printf(&quot;%c&quot;, a[i-1]); &#125; &#125; &#125; return 0;&#125; 更新日志 2014年11月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 15 E Triangles","slug":"CF-15E","date":"2014-11-23T13:50:17.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/23/CF-15E/","link":"","permalink":"https://xuanwo.org/2014/11/23/CF-15E/","excerpt":"题目源地址： http://codeforces.com/contest/15/problem/E 理解数学渣，这道题无从下手= =。为了方便能自己看出一些东西来，我打了前两项的表去CF提交，幸运地得到了n=6的解，结果是1354。这个结果印证了昨晚比赛时候我的一些想法，因为10=(2^2+1)*2，74=(6^2+1)*2，1354=(26^2+1)*2。也就是说，最后的结果一定是某一个数的平方加上一再乘二的结果。这样，这个问题就转化成了，如何找到那个数。我们可以看到，这个数组成的数列是2 6 26。考虑到最后的取模，这个数一定是指数级别的，要不然增长速度太慢了，作为一个未来的码农，想到的第一个数列就是2 4 8。乍一看感觉跟2 6 26扯不上关系，不过再观察一下，2 6 26向前递减之后可以得到另外一个衍生数列，也就是2 4 20。第一个反应就是20=4*5，但是对不上啊，4怎么处理？小脑一动，对啊，4=4*1。1和5跟原数列有什么关系呢？可以看到，1=4-3，5=8-3。写到这里，脑子里面已经是一团浆糊了，我来列成表格梳理一下。 a c b2 4 24 4 68 20 26 这样可以看出，a=pow(2,i)，c就等于c*(a-3)，明显，b=b+c。于是我就得到了最后的公式。以上，是通过偷鸡往后再推了一项得到的题解，在实际的比赛中，一方面题目不会再给你下一项（CF倒是可以用这种方法骗答案），另一方面，真的比赛中思路也不会这么清晰。所以还是要学习正规的组合数学+DP的做法，在我学会之前，还是先挖一个坑吧= =。","text":"题目源地址： http://codeforces.com/contest/15/problem/E 理解数学渣，这道题无从下手= =。为了方便能自己看出一些东西来，我打了前两项的表去CF提交，幸运地得到了n=6的解，结果是1354。这个结果印证了昨晚比赛时候我的一些想法，因为10=(2^2+1)*2，74=(6^2+1)*2，1354=(26^2+1)*2。也就是说，最后的结果一定是某一个数的平方加上一再乘二的结果。这样，这个问题就转化成了，如何找到那个数。我们可以看到，这个数组成的数列是2 6 26。考虑到最后的取模，这个数一定是指数级别的，要不然增长速度太慢了，作为一个未来的码农，想到的第一个数列就是2 4 8。乍一看感觉跟2 6 26扯不上关系，不过再观察一下，2 6 26向前递减之后可以得到另外一个衍生数列，也就是2 4 20。第一个反应就是20=4*5，但是对不上啊，4怎么处理？小脑一动，对啊，4=4*1。1和5跟原数列有什么关系呢？可以看到，1=4-3，5=8-3。写到这里，脑子里面已经是一团浆糊了，我来列成表格梳理一下。 a c b2 4 24 4 68 20 26 这样可以看出，a=pow(2,i)，c就等于c*(a-3)，明显，b=b+c。于是我就得到了最后的公式。以上，是通过偷鸡往后再推了一项得到的题解，在实际的比赛中，一方面题目不会再给你下一项（CF倒是可以用这种方法骗答案），另一方面，真的比赛中思路也不会这么清晰。所以还是要学习正规的组合数学+DP的做法，在我学会之前，还是先挖一个坑吧= =。 新技能get代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf 0x3f3f3f3f#define ll long long int#define mod 1000000009using namespace std;ll a=2,b=2,c=4,n;int main(int argc, char const *argv[])&#123; scanf(&quot;%I64d&quot;,&amp;n); a=2,b=2,c=4; while(n-=2) &#123; a=a*2%mod,c=c*(a-3)%mod,b=(b+c)%mod; &#125; printf(&quot;%I64d\\n&quot;,(b*b+1)*2%mod); return 0;&#125; 更新日志 2014年11月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 6 B President's Office (Div.2 Only)","slug":"CF-6B","date":"2014-11-22T17:59:29.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/22/CF-6B/","link":"","permalink":"https://xuanwo.org/2014/11/22/CF-6B/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/6/B 理解总统的办公室里面坐着他的副手，然后每个人都会有一张办公桌（长短不一，但每个人都有自己的颜色）。然后告诉你每个人的办公桌都是长方形，给定一个描述办公室布局的图，要你求出这个办公室里面总统的副手有几个。一开始我想得太多，觉得应该用DFS来暴力搜索，只要判断总统办公桌的四周即可。后来发现这种方法是不可行，决定采用STL里面的pair+set来做。思路很简单，既然已经告诉我办公桌都是长方形的，那么，我只要找到总统办公桌所占的区域，然后直接遍历这块区域外围的一圈即可。","text":"题目源地址： http://codeforces.com/problemset/problem/6/B 理解总统的办公室里面坐着他的副手，然后每个人都会有一张办公桌（长短不一，但每个人都有自己的颜色）。然后告诉你每个人的办公桌都是长方形，给定一个描述办公室布局的图，要你求出这个办公室里面总统的副手有几个。一开始我想得太多，觉得应该用DFS来暴力搜索，只要判断总统办公桌的四周即可。后来发现这种方法是不可行，决定采用STL里面的pair+set来做。思路很简单，既然已经告诉我办公桌都是长方形的，那么，我只要找到总统办公桌所占的区域，然后直接遍历这块区域外围的一圈即可。 代码#define MAXN 100+10char c,road[MAXN][MAXN];int n,m;pair&lt;int,int&gt; lt(-1,-1); pair&lt;int,int&gt; rb(-1,-1); set&lt;char&gt; ans; void init() &#123; scanf(&quot;%d %d %c&quot;, &amp;n,&amp;m,&amp;c); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%s&quot;, road[i]); &#125; &#125;int main(int argc, char const *argv[])&#123; init(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(road[i][j]==c) &#123; rb=pair&lt;int,int&gt;(i,j); if(lt.first&lt;0) lt=pair&lt;int,int&gt;(i,j); &#125; &#125; &#125; for(int i=lt.first;i&lt;=rb.first;i++) &#123; for(int j=lt.second;j&lt;=rb.second;j++) &#123; if(i&gt;0&amp;&amp;road[i-1][j]!=c&amp;&amp;road[i-1][j]!=&apos;.&apos;) ans.insert(road[i-1][j]); if(i&lt;n-1&amp;&amp;road[i+1][j]!=c&amp;&amp;road[i+1][j]!=&apos;.&apos;) ans.insert(road[i+1][j]); if(j&gt;0&amp;&amp;road[i][j-1]!=c&amp;&amp;road[i][j-1]!=&apos;.&apos;) ans.insert(road[i][j-1]); if(j&lt;m-1&amp;&amp;road[i][j+1]!=c&amp;&amp;road[i][j+1]!=&apos;.&apos;) ans.insert(road[i][j+1]); &#125; &#125; printf(&quot;%d&quot;, ans.size()); return 0;&#125; 更新日志 2014年11月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CF拉练第六场","slug":"Contest-CUGB-CF6","date":"2014-11-21T22:56:15.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/11/21/Contest-CUGB-CF6/","link":"","permalink":"https://xuanwo.org/2014/11/21/Contest-CUGB-CF6/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=63720#overview 比赛总结做的好渣= =，跟SB一样卡B题的字符串卡半天。以后出问题了一定要仔细检查循环的初始值的问题。然后D题的脑洞大开也是神奇，后来学长提到了左偏树，有空一定要补一补。。 分题讲解A题（暴力）没啥好说的，暴力乱搞。http://xuanwo.org/2014/11/21/CF-12A/ B题（暴力，排序）写得很挫- -，暴力乱搞过了，应该是数据弱。。http://xuanwo.org/2014/11/21/CF-12C/ C题（贪心）想清楚区间与区间之间的关系，并不是很难。http://xuanwo.org/2014/11/21/CF-14B/ D题（脑洞DP）这个DP也是神了，其实并没有怎么用到DP的思想，关键在于结论是怎样得出的。http://xuanwo.org/2014/11/21/CF-13C/ E题（树状数组）一碰到数据结构就A不了，只会暴力乱搞和开脑洞，太弱了。http://xuanwo.org/2014/11/21/CF-12D/ 更新日志 2014年11月21日 完成题解。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 12 D Ball (Div.2 Only)","slug":"CF-12D","date":"2014-11-21T22:35:22.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/21/CF-12D/","link":"","permalink":"https://xuanwo.org/2014/11/21/CF-12D/","excerpt":"题目源地址： http://codeforces.com/contest/12/problem/D 理解一个很神奇的题目= =。给你N个女人的Beauty，Intelect，Richness值。在i女人和j女人之间如果有Bi&lt;Bj&amp;&amp;Ii&lt;Ij&amp;&amp;Ri&lt;Rj,那么i女人就会去自杀！。！问总共有多少个女人会自杀= =。（这心理是有多阴暗。。。。）实际上感觉就是一个三维的排序，不过有些细节需要处理。首先开一个结构体来保存b，i，r以及id号。然后对每一个女人的beauty值排序，然后将b值离散化，作为这个树状数组的下标。然后再对i值进行排序，这样，每次只要getmax(lady[j].id+1)，就能得到当前最大的女的r值。","text":"题目源地址： http://codeforces.com/contest/12/problem/D 理解一个很神奇的题目= =。给你N个女人的Beauty，Intelect，Richness值。在i女人和j女人之间如果有Bi&lt;Bj&amp;&amp;Ii&lt;Ij&amp;&amp;Ri&lt;Rj,那么i女人就会去自杀！。！问总共有多少个女人会自杀= =。（这心理是有多阴暗。。。。）实际上感觉就是一个三维的排序，不过有些细节需要处理。首先开一个结构体来保存b，i，r以及id号。然后对每一个女人的beauty值排序，然后将b值离散化，作为这个树状数组的下标。然后再对i值进行排序，这样，每次只要getmax(lady[j].id+1)，就能得到当前最大的女的r值。 代码#define MAXN 500000+10int c[MAXN],n,cnt;int i,j,ans;struct node&#123; int b,i,r; int id;&#125; lady[MAXN];inline int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int d)&#123; while(x&gt;0) &#123; if(c[x]&lt;d) c[x]=d; x-=lowbit(x); &#125;&#125;int getmax(int x)&#123; int s=-1; for(int i=x; i&lt;=cnt; i+=lowbit(i)) &#123; if(s&lt;c[i]) s=c[i]; &#125; return s;&#125;bool cmp(node a,node b)&#123; return a.b&lt;b.b;&#125;bool cmp1(node a,node b)&#123; return a.i&gt;b.i;&#125;void init()&#123; ans=0; for(i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;lady[i].b); for(i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;lady[i].i); for(i=0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;lady[i].r); sort(lady,lady+n,cmp); cnt=1; lady[0].id=1;&#125;int main(int argc, char const *argv[])&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; init(); for(i=1; i&lt;n; i++) &#123; if(lady[i].b==lady[i-1].b) lady[i].id=cnt; else lady[i].id=++cnt; &#125;; sort(lady,lady+n,cmp1); for(i=1; i&lt;=cnt; i++) c[i]=-1; for(i=0; i&lt;n;) &#123; for(j=i; j&lt;n&amp;&amp;lady[i].i==lady[j].i; j++) &#123; if(getmax(lady[j].id+1)&gt;lady[j].r) &#123; ans++; &#125; &#125; for(j=i; j&lt;n&amp;&amp;lady[i].i==lady[j].i; j++) &#123; add(lady[j].id,lady[j].r); &#125; i=j; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年11月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 13 C Sequence","slug":"CF-13C","date":"2014-11-21T22:06:59.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/21/CF-13C/","link":"","permalink":"https://xuanwo.org/2014/11/21/CF-13C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/13/C 理解给定一个序列，然后对于每一个数，你都可以进行自增或者自减操作。要求求出使得这个序列变为非减序列的最少操作次数。我一开始的想法比较朴素，我想，只要找到一个比较的标准，比这个标准大我就–，比这个标准小我就++，这样就能得到这个非减序列的最少次操作。然后我就开始寻找这样的标准，后来发现，这是一个不可能的任务。因为给定的序列什么可能都有，我没有办法来衡量每一个数对于整体值的重要程度，然后也没有办法来计算操作的次数。没有思路之后就开始开脑洞了。很显然，我可以得到这样一个结论，对于一个序列中的某一个数而言，步数最少的，肯定是变成左边或者右边的那个数。如果再考虑到对于整体数列的影响（因为这是一个循环的过程，整个数列都有整体上移或者下移的趋势），这个数可能的取值，肯定是这个数列中已经存在的数。不难猜想，如果这个数变成的最后结果不是这个数列中的数，说明这个解一定不是最优解。（因为要么就多操作了，要么就少操作了。这么说好像有点难懂，我来举一个栗子吧，就是数列4 1 9。很显然，我们一眼就能看出，最优解的状态应该是4 4 9，也就是这个1恰好变成了4。试想，如果1变成了3，状态变为4 3 9，不合题意；如果1变成了5，状态变为4 5 9，符合题意，但是操作数多了1。那么问题来了，我变成3 3 9，难道不好吗？确实是这样，符合题意，而且结果最优。但是我们可以继续想，3 3 9可以，2 2 9可以吗？再继续，1 1 9可以吗？0 0 9可以吗？然后我们就能看出，位于4 4 9到1 1 9之间的数列都是可以的，超过了就不行了。这里的4和1，都是原来数列里面的数。我想，这或许并不是能不能问题，而是算法设计方便的问题。如果取原来数列的数，我们直接进行判断即可；如果不是，我们依然是要取原来数列里的数，判断是否在区间内。根据上面的讨论，我们不妨得出这样的结论：对任何数进行的操作，最后的结果都是把它们变成原数列中的某个数。解决了理论上的问题之后，下面进入实际的编码过程。直接开二维数组暴力搞的话，这个问题的时间复杂度过高，不可行。所以我们需要对原数组来一次sort，保证b数组是递增的。然后我们可以看到，dp的过程中，只会用到前后两个数，因此我们可以使用滚动数组来降低空间复杂度。这样，这个问题就得到解了。","text":"题目源地址： http://codeforces.com/problemset/problem/13/C 理解给定一个序列，然后对于每一个数，你都可以进行自增或者自减操作。要求求出使得这个序列变为非减序列的最少操作次数。我一开始的想法比较朴素，我想，只要找到一个比较的标准，比这个标准大我就–，比这个标准小我就++，这样就能得到这个非减序列的最少次操作。然后我就开始寻找这样的标准，后来发现，这是一个不可能的任务。因为给定的序列什么可能都有，我没有办法来衡量每一个数对于整体值的重要程度，然后也没有办法来计算操作的次数。没有思路之后就开始开脑洞了。很显然，我可以得到这样一个结论，对于一个序列中的某一个数而言，步数最少的，肯定是变成左边或者右边的那个数。如果再考虑到对于整体数列的影响（因为这是一个循环的过程，整个数列都有整体上移或者下移的趋势），这个数可能的取值，肯定是这个数列中已经存在的数。不难猜想，如果这个数变成的最后结果不是这个数列中的数，说明这个解一定不是最优解。（因为要么就多操作了，要么就少操作了。这么说好像有点难懂，我来举一个栗子吧，就是数列4 1 9。很显然，我们一眼就能看出，最优解的状态应该是4 4 9，也就是这个1恰好变成了4。试想，如果1变成了3，状态变为4 3 9，不合题意；如果1变成了5，状态变为4 5 9，符合题意，但是操作数多了1。那么问题来了，我变成3 3 9，难道不好吗？确实是这样，符合题意，而且结果最优。但是我们可以继续想，3 3 9可以，2 2 9可以吗？再继续，1 1 9可以吗？0 0 9可以吗？然后我们就能看出，位于4 4 9到1 1 9之间的数列都是可以的，超过了就不行了。这里的4和1，都是原来数列里面的数。我想，这或许并不是能不能问题，而是算法设计方便的问题。如果取原来数列的数，我们直接进行判断即可；如果不是，我们依然是要取原来数列里的数，判断是否在区间内。根据上面的讨论，我们不妨得出这样的结论：对任何数进行的操作，最后的结果都是把它们变成原数列中的某个数。解决了理论上的问题之后，下面进入实际的编码过程。直接开二维数组暴力搞的话，这个问题的时间复杂度过高，不可行。所以我们需要对原数组来一次sort，保证b数组是递增的。然后我们可以看到，dp的过程中，只会用到前后两个数，因此我们可以使用滚动数组来降低空间复杂度。这样，这个问题就得到解了。 代码#define MAXN 5000+10ll n;ll a[MAXN];ll b[MAXN];ll dp[MAXN];ll small,ans,flag;void init()&#123; memset(dp, 0, sizeof(dp)); scanf(&quot;%I64d&quot;, &amp;n); for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%I64d&quot;, &amp;a[i]); b[i]=a[i]; &#125; sort(b,b+n);&#125;int main(int argc, char const *argv[])&#123; init(); for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; dp[j]+=abs(a[i]-b[j]); if(j&gt;1) &#123; dp[j]=min(dp[j-1],dp[j]); &#125; &#125; &#125; printf(&quot;%I64d\\n&quot;, dp[n-1]); return 0;&#125; 更新日志 2014年11月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 14 B Young Photographer (Div. 2)","slug":"CF-14B","date":"2014-11-21T21:56:23.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/21/CF-14B/","link":"","permalink":"https://xuanwo.org/2014/11/21/CF-14B/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/14/B 理解一个摄影师要拍摄运动员比赛的照片，然后给定摄影师的坐标，以及每一位运动员的活动范围。要求计算出摄影是需要活动的最小步数。首先我们需要对输入的数据进行一次处理，也就是必须保证左端比右段小。处理完毕之后，两端分别进行sort，这样就得到了运动员活动范围的起点和终点的有序列。显然，只有当最大的起点比最小的终点还小的时候，摄影师才有可能同时看到。然后，如果当前摄影师的坐标比最大的起点小，他只要移动到最大起点即可；如果当前摄影师的坐标比最小的终点大，他就需要移动到最小终点。这样，我们就得到了摄影师需要移动的距离。","text":"题目源地址： http://codeforces.com/problemset/problem/14/B 理解一个摄影师要拍摄运动员比赛的照片，然后给定摄影师的坐标，以及每一位运动员的活动范围。要求计算出摄影是需要活动的最小步数。首先我们需要对输入的数据进行一次处理，也就是必须保证左端比右段小。处理完毕之后，两端分别进行sort，这样就得到了运动员活动范围的起点和终点的有序列。显然，只有当最大的起点比最小的终点还小的时候，摄影师才有可能同时看到。然后，如果当前摄影师的坐标比最大的起点小，他只要移动到最大起点即可；如果当前摄影师的坐标比最小的终点大，他就需要移动到最小终点。这样，我们就得到了摄影师需要移动的距离。 代码#define MAXN 1000+10int a[MAXN],b[MAXN];int n,i,j,x;void init()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); for(i=0; i&lt;n; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]); if(a[i]&gt;b[i]) &#123; j=a[i]; a[i]=b[i]; b[i]=j; &#125; &#125; sort(a,a+n); sort(b,b+n);&#125;int main(int argc, char const *argv[])&#123; init(); if(a[n-1]&lt;=b[0]) &#123; if(x&lt;a[n-1]) printf(&quot;%d\\n&quot;,a[n-1]-x); else if(x&gt;b[0]) printf(&quot;%d\\n&quot;,x-b[0]); else puts(&quot;0&quot;); &#125; else puts(&quot;-1&quot;); return 0;&#125; 更新日志 2014年11月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 12 C Fruits (Div.2 Only)","slug":"CF-12C","date":"2014-11-21T21:54:07.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/21/CF-12C/","link":"","permalink":"https://xuanwo.org/2014/11/21/CF-12C/","excerpt":"题目源地址： http://codeforces.com/contest/12/problem/C 理解题意并不复杂：给定一些标价牌，然后再给定一些水果的名字，每种水果对应一个标价牌。要求输出水果总价的最大值和最小值。第一眼感觉很简单，贪心乱搞。标价牌排序之后，如果求最小值就从前往后选；如果求最大值，就从后往前选。这个思路没有太大的问题，然后问题来了，我怎么样才能够得到一个去除重复项，并且能计算出每种水果数量的数据结构呢？然后我就开始SB了，因为循环的时候字符串写得搓，debug半天，都不符合我的预期。等到队友们基本都过了，我才勉强A题。","text":"题目源地址： http://codeforces.com/contest/12/problem/C 理解题意并不复杂：给定一些标价牌，然后再给定一些水果的名字，每种水果对应一个标价牌。要求输出水果总价的最大值和最小值。第一眼感觉很简单，贪心乱搞。标价牌排序之后，如果求最小值就从前往后选；如果求最大值，就从后往前选。这个思路没有太大的问题，然后问题来了，我怎么样才能够得到一个去除重复项，并且能计算出每种水果数量的数据结构呢？然后我就开始SB了，因为循环的时候字符串写得搓，debug半天，都不符合我的预期。等到队友们基本都过了，我才勉强A题。 代码#define MAXN 100+10int n,m;int price[MAXN];string x[MAXN];string y[MAXN];int flag[MAXN];int tmp;int ansMin,ansMax;struct node&#123; string s; int flag;&#125;str[MAXN];bool cmp(node a, node b)&#123; return a.flag&gt;b.flag;&#125;void init()&#123; tmp=0; memset(flag,0,sizeof(flag)); scanf(&quot;%d%d&quot;, &amp;n,&amp;m); for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;price[i]); &#125; sort(price, price+n); for(int i=0; i&lt;m; i++) &#123; cin&gt;&gt;x[i]; &#125; sort(x,x+m); y[tmp]=x[0]; flag[0]=1; for(int i=1;i&lt;m;i++) &#123; if(x[i].compare(y[tmp])==0) &#123; flag[tmp]++; &#125; else &#123; tmp++; y[tmp]=x[i]; flag[tmp]=1; &#125; &#125; tmp++; for(int i=0;i&lt;tmp;i++) &#123; str[i].s=y[i]; str[i].flag=flag[i]; &#125; sort(str,str+tmp,cmp);&#125;int main(int argc, char const *argv[])&#123; init(); for(int i=0;i&lt;tmp;i++) &#123; ansMin+=str[i].flag*price[i]; ansMax+=str[i].flag*price[n-i-1]; &#125; printf(&quot;%d %d\\n&quot;, ansMin, ansMax); return 0;&#125; 更新日志 2014年11月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 12 A Super Agent (Div.2 Only)","slug":"CF-12A","date":"2014-11-21T21:44:24.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/21/CF-12A/","link":"","permalink":"https://xuanwo.org/2014/11/21/CF-12A/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/12/A 理解问题很简单，要求判断是不是一个中心对称的图形。直接暴力搞，判断了六次。","text":"题目源地址： http://codeforces.com/problemset/problem/12/A 理解问题很简单，要求判断是不是一个中心对称的图形。直接暴力搞，判断了六次。 代码char a[3][3];void init()&#123; scanf(&quot;%s&quot;, a[0]); scanf(&quot;%s&quot;, a[1]); scanf(&quot;%s&quot;, a[2]);&#125;int main(int argc, char const *argv[])&#123; init(); if(a[0][0]==a[2][2]&amp;&amp;a[0][1]==a[2][1]&amp;&amp;a[0][2]==a[2][0]&amp;&amp;a[1][0]==a[1][2]) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); return 0;&#125; 更新日志 2014年11月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CF拉练第四场","slug":"Contest-CUGB-CF4","date":"2014-11-19T15:59:18.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/19/Contest-CUGB-CF4/","link":"","permalink":"https://xuanwo.org/2014/11/19/Contest-CUGB-CF4/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=62931#overview 比赛总结这场比赛开的时候，我还在南京= =，并没有好好做，过了水题之后就没有继续往下做了。剩下的都是赛后补的题，不过自己的DP确实弱，很多都是自己想不明白，一看题解就懂。 分题讲解A题（阅读题）题意理解题，只要读懂题目就能A，并不是很难。http://xuanwo.org/2014/11/13/CF-9A/ B题（字符串）C题（模拟）感觉也是题意理解题，没有什么算法，只要模拟出翻面的操作就可以。http://xuanwo.org/2014/11/13/CF-7A/ D题（扩展欧几里得）用到了扩展欧几里得，模板题。http://xuanwo.org/2014/11/19/CF-7C/ E题（状态压缩DP）一开始不是特别明白，折腾了很久才看懂这个递推的公式。http://xuanwo.org/2014/11/19/CF-8C/ 更新日志 2014年11月19日 初稿。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 8 C Looking for Order","slug":"CF-8C","date":"2014-11-19T13:11:43.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/19/CF-8C/","link":"","permalink":"https://xuanwo.org/2014/11/19/CF-8C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/8/C 理解群里面讨论时，萌神说是一个状态压缩DP，然后我就主动放弃了这道题= =。实际上，如果用枚举的方法来更新DP，肯定会超时的，有一个小小的技巧在于，小女孩拿东西是没有顺序的。然后在每一次拿东西的时候，都需要更新出两个状态，一种是只拿一个，另一种是拿两个。","text":"题目源地址： http://codeforces.com/problemset/problem/8/C 理解群里面讨论时，萌神说是一个状态压缩DP，然后我就主动放弃了这道题= =。实际上，如果用枚举的方法来更新DP，肯定会超时的，有一个小小的技巧在于，小女孩拿东西是没有顺序的。然后在每一次拿东西的时候，都需要更新出两个状态，一种是只拿一个，另一种是拿两个。 代码#define MAXN 1&lt;&lt;24int dp[MAXN],pre[MAXN],gra[26][26],x[26],y[26],ans[60];int n;int dis(int i, int j)&#123; return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);&#125;void init()&#123; int x0,y0; scanf(&quot;%d%d%d&quot;, &amp;x0,&amp;y0,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d%d&quot;, &amp;x[i],&amp;y[i]); x[n]=x0,y[n]=y0; for(int i=0;i&lt;=n;i++) &#123; for(int j=i+1;j&lt;=n;j++) &#123; gra[i][j]=gra[j][i]=dis(i,j); &#125; &#125; memset(dp, -1, sizeof(dp)); dp[0]=0;&#125;int main(int argc, char const *argv[])&#123; init(); for(int i=0;i&lt;1&lt;&lt;n;i++) &#123; if(dp[i]!=-1) &#123; for(int j=0;j&lt;n;j++) &#123; if(!((1&lt;&lt;j)&amp;i)) &#123; int t=i|(1&lt;&lt;j),tem=dp[i]+2*gra[j][n]; if(dp[t]==-1||dp[t]&gt;tem) &#123; dp[t]=tem; pre[t]=i; &#125; for(int k=0;k&lt;n;k++) &#123; if(!(t&amp;(1&lt;&lt;k))) &#123; int t2=t|(1&lt;&lt;k),tem=dp[i]+gra[n][j]+gra[j][k]+gra[k][n]; if(dp[t2]==-1||dp[t2]&gt;tem) &#123; dp[t2]=tem; pre[t2]=i; &#125; &#125; &#125; break; &#125; &#125; &#125; &#125; int x=(1&lt;&lt;n)-1,pr,tem,a,b,cnt=0; printf(&quot;%d\\n&quot;, dp[x]); while(x) &#123; pr=pre[x]; tem=pr^x; a=b=0; for(int i=0;i&lt;n;i++) &#123; if((1&lt;&lt;i)&amp;tem) &#123; b=a; a=i+1; &#125; &#125; ans[cnt++]=0; ans[cnt++]=a; if(b) &#123; ans[cnt++]=b; &#125; x=pr; &#125; ans[cnt++]=0; for(int i=cnt-1;i&gt;=0;i--) &#123; printf(&quot;%d &quot;,ans[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 更新日志 2014年11月19日 看题解AC，但是还没有理解。 2014年11月19日 在妹纸的督促下，完成了。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 7 C Line","slug":"CF-7C","date":"2014-11-19T10:40:15.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/19/CF-7C/","link":"","permalink":"https://xuanwo.org/2014/11/19/CF-7C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/7/C 理解扩展欧几里得算法的模板题。题意很简单，给定方程Ax + By + C = 0。要求满足该方程的两个整数解x，y。通过简单的变形之后就可以得到x = x(-C/gcd(A,B)) , y = y(-C/gcd(A,B))。","text":"题目源地址： http://codeforces.com/problemset/problem/7/C 理解扩展欧几里得算法的模板题。题意很简单，给定方程Ax + By + C = 0。要求满足该方程的两个整数解x，y。通过简单的变形之后就可以得到x = x(-C/gcd(A,B)) , y = y(-C/gcd(A,B))。 代码ll a,b,c,d,x,y;void ex_gcd(ll a, ll b, ll&amp; d,ll&amp; x, ll&amp; y)&#123; if(!b) &#123; d=a; x=1; y=0; &#125; else &#123; ex_gcd(b,a%b,d,y,x); y -= x*(a/b); &#125;&#125;int main(int argc, char const *argv[])&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; ex_gcd(a,b,d,x,y); if(c%d != 0) puts(&quot;-1&quot;); else cout &lt;&lt; -x*(c/d) &lt;&lt; &quot; &quot; &lt;&lt; -y*(c/d) &lt;&lt; endl; return 0;&#125; 更新日志 2014年11月19日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10003 Cutting Sticks","slug":"UVa-10003-Cutting-Sticks","date":"2014-11-16T17:12:15.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/16/UVa-10003-Cutting-Sticks/","link":"","permalink":"https://xuanwo.org/2014/11/16/UVa-10003-Cutting-Sticks/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=944 理解之前在COJ上好像做过类似的题目。同样是木材切割，不过这次每次切割都会消耗跟木棒长度相同的代价，要求的是最小代价的切割。小脑一动就可以知道，存在递推公式：dp[x][y]=min(dp[x][y],dp[x][a[k]]+dp[a[k]][y]+y-x)","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=944 理解之前在COJ上好像做过类似的题目。同样是木材切割，不过这次每次切割都会消耗跟木棒长度相同的代价，要求的是最小代价的切割。小脑一动就可以知道，存在递推公式：dp[x][y]=min(dp[x][y],dp[x][a[k]]+dp[a[k]][y]+y-x) 代码#define MAXN 1000+10#define MAXM 50+10int a[MAXM],dp[MAXN][MAXN];int n,m;void init()&#123; memset(a,0,sizeof(a)); scanf(&quot;%d&quot;, &amp;m); a[0]=0,a[m+1]=n; for(int i=1; i&lt;=m; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; for(int i=0; i&lt;=m; i++) &#123; dp[a[i]][a[i+1]]=0; &#125;&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; init(); for(int l=2; l&lt;=m+1; l++) &#123; for(int i=0; i&lt;=m-l+1; i++) &#123; int j=i+l,x=a[i],y=a[j]; dp[x][y]=inf; for(int k=i+1; k&lt;j; k++) &#123; dp[x][y]=min(dp[x][y],dp[x][a[k]]+dp[a[k]][y]+y-x); &#125; &#125; &#125; printf(&quot;The minimum cutting is %d.\\n&quot;,dp[0][n]); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11400 Lighting System Design","slug":"UVa-11400-Lighting-System-Design","date":"2014-11-16T16:33:57.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/16/UVa-11400-Lighting-System-Design/","link":"","permalink":"https://xuanwo.org/2014/11/16/UVa-11400-Lighting-System-Design/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2395 理解变量多的题目确实头疼，我来稍微捋一下。题目中给出n中灯泡，不同的灯泡要用不同的电源，相同的灯泡可以使用相同的电源。然后每种灯泡有着四种参数，电压v，电源费用k，每个灯泡的费用c，所需要的该种灯泡的数量l。小脑一动就能明白，每次更换只会采用同一种灯泡，因为不同中灯泡的话要买两种电源，一定不是最优解。这样的话，按照电压进行排序之后，可以得到递推公式：dp[i]=min(dp[i], dp[j]+(sum[i]-sum[j])*s[i].c+s[i].k)其中sum[i]=sum[i-1]+s[i].l;","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2395 理解变量多的题目确实头疼，我来稍微捋一下。题目中给出n中灯泡，不同的灯泡要用不同的电源，相同的灯泡可以使用相同的电源。然后每种灯泡有着四种参数，电压v，电源费用k，每个灯泡的费用c，所需要的该种灯泡的数量l。小脑一动就能明白，每次更换只会采用同一种灯泡，因为不同中灯泡的话要买两种电源，一定不是最优解。这样的话，按照电压进行排序之后，可以得到递推公式：dp[i]=min(dp[i], dp[j]+(sum[i]-sum[j])*s[i].c+s[i].k)其中sum[i]=sum[i-1]+s[i].l; 代码#define MAXN 1000+10struct node&#123; int v,k,c,l;&#125;s[MAXN];int n,sum[MAXN],dp[MAXN];bool cmp(node a, node b)&#123; return a.v&lt;b.v;&#125;void init()&#123; memset(sum,0,sizeof(sum)); memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d%d%d%d&quot;, &amp;s[i].v,&amp;s[i].k,&amp;s[i].c,&amp;s[i].l); &#125; sort(s+1,s+n+1,cmp);&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;, &amp;n)&amp;&amp;n) &#123; init(); for(int i=1;i&lt;=n;i++) &#123; sum[i]+=sum[i-1]+s[i].l; &#125; dp[1]=s[1].k+s[1].c*s[1].l; for(int i=2;i&lt;=n;i++) &#123; dp[i]=inf; for(int j=0;j&lt;i;j++) &#123; dp[i]=min(dp[i], dp[j]+(sum[i]-sum[j])*s[i].c+s[i].k); &#125; &#125; printf(&quot;%d\\n&quot;, dp[n]); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 12563 Jin Ge Jin Qu hao","slug":"UVa-12563-Jin-Ge-Jin-Qu-hao","date":"2014-11-16T16:16:48.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/16/UVa-12563-Jin-Ge-Jin-Qu-hao/","link":"","permalink":"https://xuanwo.org/2014/11/16/UVa-12563-Jin-Ge-Jin-Qu-hao/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4008 理解~看完题目的名字就情不自禁的笑了= =。~这就是一个变形的背包问题：在t-1的时间内，最多可以选择多少歌曲使得歌曲数最多并且播放时间最长，差不多可以类比于ACM竞赛中的AC数和罚时。先比较播放歌曲数，取歌曲数较多者；如果歌曲数相同，比较播放时长，取播放时间较长的。处理之后，就成了一个背包+一些判断的问题。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4008 理解~看完题目的名字就情不自禁的笑了= =。~这就是一个变形的背包问题：在t-1的时间内，最多可以选择多少歌曲使得歌曲数最多并且播放时间最长，差不多可以类比于ACM竞赛中的AC数和罚时。先比较播放歌曲数，取歌曲数较多者；如果歌曲数相同，比较播放时长，取播放时间较长的。处理之后，就成了一个背包+一些判断的问题。 代码#define MAXN 10000+10#define MAXS 50+10int n,t,T;int v[MAXS];int dp[MAXS][MAXN];int path[MAXS][MAXN];int Max;void init()&#123; memset(path,0,sizeof(path)); memset(dp,0,sizeof(dp)); memset(v,0,sizeof(v)); scanf(&quot;%d%d&quot;, &amp;n,&amp;t); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;, &amp;v[i]); &#125;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;T); for(int flag=1; flag&lt;=T; flag++) &#123; init(); for(int i=n; i&gt;=1; i--) &#123; for(int j=0; j&lt;=t; j++) &#123; dp[i][j]=(i==n)?0:dp[i+1][j]; path[i][j]=path[i+1][j]; if(j&gt;=v[i]) &#123; if(dp[i][j]&lt;dp[i+1][j-v[i]]+1) &#123; path[i][j]=v[i]+path[i+1][j-v[i]]; dp[i][j]=dp[i+1][j-v[i]]+1; &#125; else if(dp[i][j]==dp[i+1][j-v[i]]+1) &#123; path[i][j]=max(path[i+1][j-v[i]]+v[i],path[i+1][j]); &#125; &#125; &#125; &#125; Max=-inf; for(int i=t-1; i&gt;=0; i--) &#123; if(dp[1][i]==dp[1][t-1]&amp;&amp;Max&lt;path[1][i]) &#123; Max=path[1][i]; &#125; &#125; printf(&quot;Case %d: %d %d\\n&quot;, flag, dp[1][t-1]+1, Max+678); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 116 Unidirectional TSP","slug":"UVa-116-Unidirectional-TSP","date":"2014-11-16T15:39:47.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/16/UVa-116-Unidirectional-TSP/","link":"","permalink":"https://xuanwo.org/2014/11/16/UVa-116-Unidirectional-TSP/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=52 理解这道题和之前做过的一道求最大四位数和有点像。那道题我是用暴力+乱搞过得，这道题则是用了刚学的DP。不用看题，光是看图和样例就能明白大概的题意：给定一个m*n的矩阵，要求从左往右依次选择n个数，使得这n个数的和最小。不过存在这样的限制条件：首先，每次都只能选择当前数的相邻数，也就是右上，右方，右下；其次，要求字典序最小。找到这样的一个序列并不难，不过要求输出字典序最小的就有点麻烦。通过从右向左来扫描，就能解决这样的问题。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=52 理解这道题和之前做过的一道求最大四位数和有点像。那道题我是用暴力+乱搞过得，这道题则是用了刚学的DP。不用看题，光是看图和样例就能明白大概的题意：给定一个m*n的矩阵，要求从左往右依次选择n个数，使得这n个数的和最小。不过存在这样的限制条件：首先，每次都只能选择当前数的相邻数，也就是右上，右方，右下；其次，要求字典序最小。找到这样的一个序列并不难，不过要求输出字典序最小的就有点麻烦。通过从右向左来扫描，就能解决这样的问题。 代码#define MAXN 10+10#define MAXM 100+10int m,n;int road[MAXN][MAXM],dp[MAXN][MAXM],path[MAXN][MAXM];int a,b,c,Min;int ans,id;void init()&#123; memset(road,0,sizeof(road)); memset(dp,0,sizeof(dp)); memset(path,0,sizeof(path)); for(int i=0; i&lt;n; ++i) &#123; for(int j=0; j&lt;m; ++j) &#123; scanf(&quot;%d&quot;, &amp;road[i][j]); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d%d&quot;, &amp;n,&amp;m)) &#123; init(); for(int j=m-1; j&gt;=0; --j) &#123; for(int i=0; i&lt;n; ++i) &#123; a=dp[(i-1+n)%n][j+1]; b=dp[i][j+1]; c=dp[(i+1)%n][j+1]; Min=min(a,min(b,c)); dp[i][j]=road[i][j]+Min; path[i][j]=inf; if(Min==a) &#123; path[i][j]=(i-1+n)%n; &#125; if(Min==b) &#123; path[i][j]=min(path[i][j],i); &#125; if(Min==c) &#123; path[i][j]=min(path[i][j],(i+1)%n); &#125; &#125; &#125; ans=inf; for(int i=0; i&lt;n; ++i) &#123; if(ans&gt;dp[i][0]) &#123; ans=dp[i][0],id=i; &#125; &#125; printf(&quot;%d&quot;, id+1); id=path[id][0]; for(int j=1; j&lt;m; ++j) &#123; printf(&quot; %d&quot;, id+1); id=path[id][j]; &#125; printf(&quot;\\n%d\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1347 Tour","slug":"UVa-1347-Tour","date":"2014-11-16T14:35:27.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/16/UVa-1347-Tour/","link":"","permalink":"https://xuanwo.org/2014/11/16/UVa-1347-Tour/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4093 理解给出n个定点，要求计算出连接这些点的最短闭合路径。使用dp[i][j]来保存从i到1再从1到j的最短距离。然后可以得到这样两条递推公式： dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+dis(i,j));dp[i][j]=dp[i-1][j]+dis(i,i-1); 最后的结果就是遍历一遍dp[n][i]+dis(n,i)，找到最小值。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4093 理解给出n个定点，要求计算出连接这些点的最短闭合路径。使用dp[i][j]来保存从i到1再从1到j的最短距离。然后可以得到这样两条递推公式： dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+dis(i,j));dp[i][j]=dp[i-1][j]+dis(i,i-1); 最后的结果就是遍历一遍dp[n][i]+dis(n,i)，找到最小值。 代码#define MAXN 100+10int n;double x[MAXN],y[MAXN],dp[MAXN][MAXN];double ans;double dis(int a,int b)&#123; return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));&#125;void init()&#123; memset(dp,0,sizeof(dp)); dp[2][1]=dis(1,2); for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%lf%lf&quot;, &amp;x[i], &amp;y[i]); &#125;&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;, &amp;n)) &#123; init(); for(int i=3; i&lt;=n; i++) &#123; dp[i][i-1]=inf; for(int j=1; j&lt;i-1; j++) &#123; dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+dis(i,j)); dp[i][j]=dp[i-1][j]+dis(i,i-1); &#125; &#125; ans=inf; for(int i=1; i&lt;n; i++) &#123; ans=min(ans,dp[n][i]+dis(n,i)); &#125; printf(&quot;%.2lf\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CF拉练第五场","slug":"Contest-CUGB-CF5","date":"2014-11-16T13:06:10.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/Contest-CUGB-CF5/","link":"","permalink":"https://xuanwo.org/2014/11/16/Contest-CUGB-CF5/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=62933#overview 比赛总结前面被BC艹了一顿爆零之后，这场手感还不错。好多都是暴力+乱搞的题目，打得还行。不过自己的DP还是太弱，那场DP还得好好补，要不然像E这种题目只能看人品。 分题讲解A题（字符串）贪心+乱搞，水过的题目。为了抢时间都没有测数据，幸运1A。http://xuanwo.org/2014/11/16/CF-11A/ B题（进制转换）机智+乱搞。这个题正好跟前面那场BC有点像，能过也有点运气成分。不过思路出来之后敲得有点慢，这个是弱点。水题要出的快，出的稳，这样才能保住铜牌，233333。http://xuanwo.org/2014/11/16/CF-9C/ C题（暴力）暴力+乱搞。这道题只要能正确的找出导致BUG的两类情况就能A，我少考虑了一种，WA了一发，2A。http://xuanwo.org/2014/11/16/CF-8B/ D题（字符串Hash，DP）字符串Hash+乱搞。开了一个好几个50万的数组乱搞，感谢CF不限制内存占用= =。http://xuanwo.org/2014/11/16/CF-7D/ E题（神DP）有一个神奇的递推公式，猜一猜，看RP，赛后出证明。http://xuanwo.org/2014/11/16/CF-9D/ 更新日志 2014年11月16日 完成题解。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 9 D How many trees? (Div.2 Only)","slug":"CF-9D","date":"2014-11-16T11:41:12.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/CF-9D/","link":"","permalink":"https://xuanwo.org/2014/11/16/CF-9D/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/9/D 理解神DP，给战斗民族的数学功底跪了。一个二叉搜索树，要求左子树的和小于右子树，问存在多少个这样的数。由题意可以推出这样一个结论：左子树的和小于右子树，只要左子树的最大值小于右子树的最大值即可，因为2^0+2^1+2^p-1&lt;2^p。所以在求dp[i][j]~（dp[i][j]表示i个点组成高度小于等于j的树的总数）~的时候，有两种情况： 子树的中n-1个点权在左子树，要么全在右子树，这样的话就没有条件限制了。 如果左右子树都有，那么最大的肯定要放在右子树上，所以除了当前根和最大的点，其他点（总共i-2个）随便取 ,枚举左子树最多放几个,右子树最多放几个就可以推出来。转移转移方程为：dp[i][j]+=dp[k][j-1]*dp[i-k-1][j-1]","text":"题目源地址： http://codeforces.com/problemset/problem/9/D 理解神DP，给战斗民族的数学功底跪了。一个二叉搜索树，要求左子树的和小于右子树，问存在多少个这样的数。由题意可以推出这样一个结论：左子树的和小于右子树，只要左子树的最大值小于右子树的最大值即可，因为2^0+2^1+2^p-1&lt;2^p。所以在求dp[i][j]~（dp[i][j]表示i个点组成高度小于等于j的树的总数）~的时候，有两种情况： 子树的中n-1个点权在左子树，要么全在右子树，这样的话就没有条件限制了。 如果左右子树都有，那么最大的肯定要放在右子树上，所以除了当前根和最大的点，其他点（总共i-2个）随便取 ,枚举左子树最多放几个,右子树最多放几个就可以推出来。转移转移方程为：dp[i][j]+=dp[k][j-1]*dp[i-k-1][j-1] 代码int n,h;ll dp[36][36];void init()&#123; for(int i=0; i&lt;=35; i++) dp[0][i]=1; for(int i=1; i&lt;=35; i++) &#123; for(int j=1; j&lt;=35; j++) &#123; for(int k=0; k&lt;i; k++) &#123; dp[i][j]+=dp[k][j-1]*dp[i-k-1][j-1]; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); scanf(&quot;%d%d&quot;,&amp;n,&amp;h); printf(&quot;%I64d\\n&quot;,dp[n][35]-dp[n][h-1]); return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 7 D Palindrome Degree","slug":"CF-7D","date":"2014-11-16T11:29:22.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/CF-7D/","link":"","permalink":"https://xuanwo.org/2014/11/16/CF-7D/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/7/D 理解被引入的新概念吓到了= =，其实这道题就是一个求最大回文串的问题。不过按照这个数据量，每一次都进行strcmp肯定不现实，所以我们需要一个好的字符串hash（的板子）。预处理之后，分别计算前缀和后缀的hash值。如果hash值相等，说明前缀和后缀相同，它们的度数就是长度/2再加上一。然后结果就是度数的和。 &gt;字符串hash的时候那个素数开大一点比较好，不用去处理hash冲突，23333。","text":"题目源地址： http://codeforces.com/problemset/problem/7/D 理解被引入的新概念吓到了= =，其实这道题就是一个求最大回文串的问题。不过按照这个数据量，每一次都进行strcmp肯定不现实，所以我们需要一个好的字符串hash（的板子）。预处理之后，分别计算前缀和后缀的hash值。如果hash值相等，说明前缀和后缀相同，它们的度数就是长度/2再加上一。然后结果就是度数的和。 &gt;字符串hash的时候那个素数开大一点比较好，不用去处理hash冲突，23333。 代码#define MAXN 5000000+10#define MOD 1000000007#define BIG 10000009char a[MAXN];ll n,l[MAXN],r[MAXN],dp[MAXN];ll i,j,len;ll ans = 0;void init()&#123; scanf(&quot;%s&quot;, a); dp[0]=0; for(i=0; a[i]; i++) &#123; if(&apos;0&apos;&lt;=a[i]&amp;&amp;a[i]&lt;=&apos;9&apos;) a[i] = a[i]-&apos;0&apos;; else if(&apos;a&apos;&lt;=a[i]&amp;&amp;a[i]&lt;=&apos;z&apos;) a[i] = a[i]-&apos;a&apos;+10; else a[i] = a[i]-&apos;A&apos;+36; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); len = i; l[0] = 0; ll tmp = 1; for(i=1; i&lt;=len; i++) &#123; l[i] = (l[i-1]+a[i-1]*tmp)%MOD; tmp = (tmp*BIG)%MOD; &#125; r[len+1] = 0; for(i=1; i&lt;=len; i++) &#123; r[i] = (r[i-1]*BIG+a[i-1])%MOD; &#125; ans=0; for(i=1; i&lt;=len; i++) &#123; if(l[i]==r[i]) &#123; dp[i] = dp[i&gt;&gt;1]+1; ans += dp[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 8 B Obsession with Robots","slug":"CF-8B","date":"2014-11-16T11:16:13.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/CF-8B/","link":"","permalink":"https://xuanwo.org/2014/11/16/CF-8B/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/8/B 理解在那遥远的地方有位好姑娘 ，人们走过她的帐篷都要留恋的张望23333，不逗比了，真正的题解开始。在一个无穷大的平面上，有一个机器人可以自由地上下左右移动。然后在它移动的路径上，你可以给它设置任意个障碍。如果存在一种障碍的设计，使得机器人的移动路径是最短路径，则OK；如果不存在，则存在BUG。这道题写得很逗= =。一开始作死用switch来写，不过在字符的判断上好像写搓了，怎么写都是BUG。后来想到可以用一个vis来标记机器人走过的路径，如果存在一个点被访问过两次，那么这个路径一定不是最短路径。不过这份代码挂了，原因是还存在另外一种可能，比如：URD。也就是说，只要形成一个类似于U的结构，也一定不是最短路径。一时半会儿没想出来什么高效的方案，干脆暴力敲了一个。设一个flag出来，然后每走一个点，就四个方向判断一下是否访问过，如果flag&gt;=2，说明一定是BUG。多亏了CF机子好，居然过了，也是RP好。","text":"题目源地址： http://codeforces.com/problemset/problem/8/B 理解在那遥远的地方有位好姑娘 ，人们走过她的帐篷都要留恋的张望23333，不逗比了，真正的题解开始。在一个无穷大的平面上，有一个机器人可以自由地上下左右移动。然后在它移动的路径上，你可以给它设置任意个障碍。如果存在一种障碍的设计，使得机器人的移动路径是最短路径，则OK；如果不存在，则存在BUG。这道题写得很逗= =。一开始作死用switch来写，不过在字符的判断上好像写搓了，怎么写都是BUG。后来想到可以用一个vis来标记机器人走过的路径，如果存在一个点被访问过两次，那么这个路径一定不是最短路径。不过这份代码挂了，原因是还存在另外一种可能，比如：URD。也就是说，只要形成一个类似于U的结构，也一定不是最短路径。一时半会儿没想出来什么高效的方案，干脆暴力敲了一个。设一个flag出来，然后每走一个点，就四个方向判断一下是否访问过，如果flag&gt;=2，说明一定是BUG。多亏了CF机子好，居然过了，也是RP好。 代码#define MAXN 100+10char road[MAXN];int vis[2*MAXN][2*MAXN];int x=105,y=105,len;bool solve()&#123; for(int i=0; i&lt;len; i++) &#123; if(road[i]==&apos;L&apos;) &#123; x-=1; if(vis[x][y]==1) return false; int flag=0; if(vis[x-1][y]) flag++; if(vis[x+1][y]) flag++; if(vis[x][y+1]) flag++; if(vis[x][y-1]) flag++; if(flag&gt;=2) return false; vis[x][y]=1; &#125; else if(road[i]==&apos;U&apos;) &#123; y+=1; if(vis[x][y]==1) return false; int flag=0; if(vis[x-1][y]) flag++; if(vis[x+1][y]) flag++; if(vis[x][y+1]) flag++; if(vis[x][y-1]) flag++; if(flag&gt;=2) return false; vis[x][y]=1; &#125; else if(road[i]==&apos;R&apos;) &#123; x+=1; if(vis[x][y]==1) return false; int flag=0; if(vis[x-1][y]) flag++; if(vis[x+1][y]) flag++; if(vis[x][y+1]) flag++; if(vis[x][y-1]) flag++; if(flag&gt;=2) return false; vis[x][y]=1; &#125; else &#123; y-=1; if(vis[x][y]==1) return false; int flag=0; if(vis[x-1][y]) flag++; if(vis[x+1][y]) flag++; if(vis[x][y+1]) flag++; if(vis[x][y-1]) flag++; if(flag&gt;=2) return false; vis[x][y]=1; &#125; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; memset(vis,0,sizeof(vis)); scanf(&quot;%s&quot;, road); len=strlen(road); vis[x][y]=1; if(solve()) printf(&quot;OK\\n&quot;); else printf(&quot;BUG\\n&quot;); return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 9 C Hexadecimal's Numbers (Div.2 Only)","slug":"CF-9C","date":"2014-11-16T11:05:48.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/CF-9C/","link":"","permalink":"https://xuanwo.org/2014/11/16/CF-9C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/9/C 理解题意不难理解。给定一个n，要你求出从0到n有多少个仅用0和1能表示出来的数。想法很简单，我们先来处理最为简化的情况，如果给定一个二进制数，我们要求出比这个小的二进制数的个数有多少。小脑一动，我们就能知道，这个个数就是这个二进制数转化为十进制数的大小。那么问题来了，给定一个十进制数，我们怎样才能求出这个最大的二进制数呢？其实我们可以这样来处理：每一位都有三种情况，0或者1或者大于1。0和1不需要进行任何操作，如果大于1，我们则把从这一位起的每一位都变成1。这样处理之后，我们就得到了最大的二进制数。然后就是一个简单的进制转换问题。 &gt;其实当天晚上的BestCoder 18的1003题跟这个有点像，不过做BC的时候，我没有捋清楚思路，最后还是没有敲出来。不过多亏被虐了一发，这道题才顺利地推出了结论。","text":"题目源地址： http://codeforces.com/problemset/problem/9/C 理解题意不难理解。给定一个n，要你求出从0到n有多少个仅用0和1能表示出来的数。想法很简单，我们先来处理最为简化的情况，如果给定一个二进制数，我们要求出比这个小的二进制数的个数有多少。小脑一动，我们就能知道，这个个数就是这个二进制数转化为十进制数的大小。那么问题来了，给定一个十进制数，我们怎样才能求出这个最大的二进制数呢？其实我们可以这样来处理：每一位都有三种情况，0或者1或者大于1。0和1不需要进行任何操作，如果大于1，我们则把从这一位起的每一位都变成1。这样处理之后，我们就得到了最大的二进制数。然后就是一个简单的进制转换问题。 &gt;其实当天晚上的BestCoder 18的1003题跟这个有点像，不过做BC的时候，我没有捋清楚思路，最后还是没有敲出来。不过多亏被虐了一发，这道题才顺利地推出了结论。 代码char n[10];ll a[10],len;ll ans=0;int main(int argc, char const *argv[])&#123; scanf(&quot;%s&quot;, n); len=strlen(n); for(int i=0;i&lt;len;i++) &#123; a[i]=n[i]-&apos;0&apos;; &#125; for(int i=0;i&lt;len;i++) &#123; if(a[i]&gt;1) &#123; for(int j=i;j&lt;len;j++) &#123; a[j]=1; &#125; &#125; &#125; for(int i=0;i&lt;len;i++) &#123; ans+=a[len-i-1]*(ll)pow(2,i); &#125; printf(&quot;%I64d\\n&quot;, ans); return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 11 A Increasing Sequence","slug":"CF-11A","date":"2014-11-16T10:45:44.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/16/CF-11A/","link":"","permalink":"https://xuanwo.org/2014/11/16/CF-11A/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/11/A 理解给定一个序列，给定一个递增值。要求计算出最少需要多少步，能将这个序列变为递增数列。第一个想法就是贪心，甚至都不需要读完数列，直接在输入时处理就可以了。","text":"题目源地址： http://codeforces.com/problemset/problem/11/A 理解给定一个序列，给定一个递增值。要求计算出最少需要多少步，能将这个序列变为递增数列。第一个想法就是贪心，甚至都不需要读完数列，直接在输入时处理就可以了。 代码int n,d;int t=0,one,two,temp;int main(int argc, char const *argv[])&#123; while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;d)) &#123; t=0; scanf(&quot;%d&quot;,&amp;one); for (int i=2; i&lt;=n; i++) &#123; scanf(&quot;%d&quot;,&amp;two); if (one&gt;two) &#123; temp=(one-two)/d+1; t+=temp; two+=temp*d; &#125; else if (one == two) t++,two+=d; one=two; &#125; printf(&quot;%d\\n&quot;,t); &#125; return 0;&#125; 更新日志 2014年11月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11584 Partitioning by Palindromes","slug":"UVa-11584-Partitioning-by-Palindromes","date":"2014-11-15T11:33:53.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/15/UVa-11584-Partitioning-by-Palindromes/","link":"","permalink":"https://xuanwo.org/2014/11/15/UVa-11584-Partitioning-by-Palindromes/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=465&amp;page=show_problem&amp;problem=2631 理解原谅我是一个乐盲，看到乐谱就吓出翔，不敢看了= =。实际上，题意很简单，就是将一个字符串分割为尽量少的串，使得每一个串都是回文串。一个简单的DP递推。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=465&amp;page=show_problem&amp;problem=2631 理解原谅我是一个乐盲，看到乐谱就吓出翔，不敢看了= =。实际上，题意很简单，就是将一个字符串分割为尽量少的串，使得每一个串都是回文串。一个简单的DP递推。 代码#define MAXN 1000+10char str[MAXN];int dp[MAXN];int t;bool isPalind(int l, int r)&#123; while(l&lt;r) &#123; if(str[l] != str[r]) return false; ++l; --r; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%s&quot;, str+1); int len = strlen(str+1); memset(dp, 0, sizeof(int)*len); for(int i=1; i&lt;=len; ++i) &#123; dp[i] = i+1; for(int j=1; j&lt;=i; ++j) &#123; if(isPalind(j, i)) &#123; dp[i] = min(dp[i], dp[j-1]+1); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, dp[len]); &#125; return 0;&#125; 更新日志 2014年11月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1025 A Spy in the Metro","slug":"UVa-1025-A-Spy-in-the-Metro","date":"2014-11-15T11:04:23.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/15/UVa-1025-A-Spy-in-the-Metro/","link":"","permalink":"https://xuanwo.org/2014/11/15/UVa-1025-A-Spy-in-the-Metro/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3466 理解其实题目还是蛮吓人的= =，因为上来就是Line1~7的输入。其实题意不难，有从左到右编号为1~n的车站，有m1辆车从第1站往右开，有m2辆车从第2站往左开。主角在t=0的时候从第1站出发，要在t时刻遇见车站n的一个间谍。要求求出最短的等待时间，没有的话就输出impossible。小脑一动，可以知道，每一次有三个选择：等待，向左，向右。我们可以用dp[t][i]来表示第t时刻在第i个车站，然后用vis[t][i][sta]来表示三种选择。全部预处理一遍之后，dp求解最短时间即可。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3466 理解其实题目还是蛮吓人的= =，因为上来就是Line1~7的输入。其实题意不难，有从左到右编号为1~n的车站，有m1辆车从第1站往右开，有m2辆车从第2站往左开。主角在t=0的时候从第1站出发，要在t时刻遇见车站n的一个间谍。要求求出最短的等待时间，没有的话就输出impossible。小脑一动，可以知道，每一次有三个选择：等待，向左，向右。我们可以用dp[t][i]来表示第t时刻在第i个车站，然后用vis[t][i][sta]来表示三种选择。全部预处理一遍之后，dp求解最短时间即可。 代码#define MAXN 250+10#define MAXM 70+10int vis[MAXN][MAXM][3];int dp[MAXN][MAXM];int t[MAXN];int d1[MAXM],d2[MAXM];int n,t,m1,m2;int ca=1;void init()&#123; scanf(&quot;%d&quot;,&amp;t); for(int i=1; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;t[i]); scanf(&quot;%d&quot;,&amp;m1); for(int i=1; i&lt;=m1; i++) scanf(&quot;%d&quot;,&amp;d1[i]); scanf(&quot;%d&quot;,&amp;m2); for(int i=1; i&lt;=m2; i++) scanf(&quot;%d&quot;,&amp;d2[i]); memset(vis,0,sizeof vis);&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;,&amp;n),n) &#123; init(); for(int i=1; i&lt;=m1; i++) &#123; vis[d1[i]][1][0]=1; int temp=d1[i]; for(int j=1; j&lt;n; j++) &#123; temp+=t[j]; if(temp&lt;=t) vis[temp][j+1][0]=1; else break; &#125; &#125; for(int i=1; i&lt;=m2; i++) &#123; vis[d2[i]][n][1]=1; int temp=d2[i]; for(int j=n-1; j&gt;=1; j--) &#123; temp+=t[j]; if(temp&lt;=t) vis[temp][j][1]=1; else break; &#125; &#125; for(int i=1; i&lt;n; i++) dp[t][i]=inf; dp[t][n]=0; for(int i=t-1; i&gt;=0; i--) &#123; for(int j=1; j&lt;=n; j++) &#123; dp[i][j]=dp[i+1][j]+1; if(j&lt;n&amp;&amp;vis[i][j][0]&amp;&amp;i+t[j]&lt;=t) dp[i][j]=min(dp[i][j],dp[i+t[j]][j+1]); if(j&gt;1&amp;&amp;vis[i][j][1]&amp;&amp;i+t[j-1]&lt;=t) dp[i][j]=min(dp[i][j],dp[i+t[j-1]][j-1]); &#125; &#125; printf(&quot;Case Number %d: &quot;,ca++); if(dp[0][1]&gt;=inf) printf(&quot;impossible\\n&quot;); else printf(&quot;%d\\n&quot;,dp[0][1]); &#125; return 0;&#125; 更新日志 2014年11月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 7 A Kalevitch and Chess","slug":"CF-7A","date":"2014-11-13T19:34:59.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/13/CF-7A/","link":"","permalink":"https://xuanwo.org/2014/11/13/CF-7A/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/7/A 理解同样是理解题- -。给定一个被黑白棋子占满的棋盘，能进行的操作为将一行或者一列由黑色变白色，问最少需要多少步，能将棋盘全都变为白色。一开始感觉应该用DFS来做，但是想了想，其实用模拟就能搞定。思路很简单，只要用两层循环，由上到下，由左到右，判断是否为B。如果是B，则有tmp++；如果不是，则继续。再然后，判断tmp是不是等于8，如果是，则进行一次行的翻转，如果不是，则列的翻转数为tmp。","text":"题目源地址： http://codeforces.com/problemset/problem/7/A 理解同样是理解题- -。给定一个被黑白棋子占满的棋盘，能进行的操作为将一行或者一列由黑色变白色，问最少需要多少步，能将棋盘全都变为白色。一开始感觉应该用DFS来做，但是想了想，其实用模拟就能搞定。思路很简单，只要用两层循环，由上到下，由左到右，判断是否为B。如果是B，则有tmp++；如果不是，则继续。再然后，判断tmp是不是等于8，如果是，则进行一次行的翻转，如果不是，则列的翻转数为tmp。 代码#define MAXN 8char chess[MAXN][MAXN];int i,j;int c=0,r=0;int tmp=0;int ans;void init()&#123; for(int i=0; i&lt;=7; i++) scanf(&quot;%s&quot;, &amp;chess[i]);&#125;int main(int argc, char const *argv[])&#123; init(); for(int i=0; i&lt;=7; i++) &#123; tmp=0; for(j=0; j&lt;=7; j++) &#123; if(chess[i][j]==&apos;B&apos;) tmp++; &#125; if(tmp==MAXN) &#123; c++; &#125; else r=tmp; &#125; ans=c+r; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 更新日志 2014年11月13日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 9 A Die Roll (Div.2 Only)","slug":"CF-9A","date":"2014-11-13T15:29:45.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/13/CF-9A/","link":"","permalink":"https://xuanwo.org/2014/11/13/CF-9A/","excerpt":"题目源地址： http://codeforces.com/contest/9/problem/A 理解阅读题= =，实际上，只要Dot的点数比其他两个人中大的那个人大就行。直接用switch搞定。","text":"题目源地址： http://codeforces.com/contest/9/problem/A 理解阅读题= =，实际上，只要Dot的点数比其他两个人中大的那个人大就行。直接用switch搞定。 代码int m,n;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; if(n&lt;m) swap(n,m); int x=6-n+1; switch(x) &#123; case 0: printf(&quot;0/1\\n&quot;); break; case 1: printf(&quot;1/6\\n&quot;); break; case 2: printf(&quot;1/3\\n&quot;); break; case 3: printf(&quot;1/2\\n&quot;); break; case 4: printf(&quot;2/3\\n&quot;); break; case 5: printf(&quot;5/6\\n&quot;); break; default: printf(&quot;1/1\\n&quot;); &#125; return 0; &#125;&#125; 更新日志 2014年11月13日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CF拉练第二场","slug":"Contest-CUGB-CF2","date":"2014-11-07T10:19:52.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/07/Contest-CUGB-CF2/","link":"","permalink":"https://xuanwo.org/2014/11/07/Contest-CUGB-CF2/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=62027#overview 比赛总结水掉A和B之后，就卡在了C和D上。C只是一个变形的最长上升子序列，却没有敲出来；D题是卡了半天，输出各种理解错，一直到还有20分钟结束的时候才过，这时候已经没有时间看E了。不过赛后了看，反正我也过不了E，23333。 分题讲解A题（模拟）没啥好说的，其实根本就不用判断人名是否相同。http://xuanwo.org/2014/11/05/CF-5A/ B题（模拟，字符串）注意理解题意，是左右摆动以保持平衡。http://xuanwo.org/2014/11/05/CF-5B/ C题（LIS）稍微变形一下的最长上升子序列就写不出来，说明做题太死板，不懂变通，要加强。http://xuanwo.org/2014/11/07/CF-4D/ D题（贪心）小心输出上的trick= =。http://xuanwo.org/2014/11/07/CF-3B/ E题（几何）论开脑洞的重要性，没有完善的证明。http://xuanwo.org/2014/11/06/CF-2C/ 更新日志 2014年11月7日 完成题解。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 3 B Lorry","slug":"CF-3B","date":"2014-11-07T10:18:47.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/07/CF-3B/","link":"","permalink":"https://xuanwo.org/2014/11/07/CF-3B/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/3/B 理解读懂题略微花了一点时间，主要是生词多，有点吓人= =。有一辆卡车，要装载一些船只，有1和2两种。然后给出n个船的类型和容积，要求给定卡车体积v的情况下，装载的船的最大容积。一开始的想法是理解成一个背包问题，但是给的v太大，用DP处理可能会超时。后来就用简单一点的思路，直接暴力贪心。把两种船分开，分别进行排序。小脑一动就能明白，最优解肯定是选取价值高的，然后枚举选择i只1船，则选择2船只的个数就是min((v - i) / 2, tc)其中tc为2船总个数。输出上有一个trick，就是每个编号之间都有一个空格= =，因此WA一发。。","text":"题目源地址： http://codeforces.com/problemset/problem/3/B 理解读懂题略微花了一点时间，主要是生词多，有点吓人= =。有一辆卡车，要装载一些船只，有1和2两种。然后给出n个船的类型和容积，要求给定卡车体积v的情况下，装载的船的最大容积。一开始的想法是理解成一个背包问题，但是给的v太大，用DP处理可能会超时。后来就用简单一点的思路，直接暴力贪心。把两种船分开，分别进行排序。小脑一动就能明白，最优解肯定是选取价值高的，然后枚举选择i只1船，则选择2船只的个数就是min((v - i) / 2, tc)其中tc为2船总个数。输出上有一个trick，就是每个编号之间都有一个空格= =，因此WA一发。。 代码#define MAXN 100000+10int sum1[MAXN], sum2[MAXN], oc, tc, ans[MAXN];int n, v, a, b, maxv, c1, c2;struct node&#123; int id,val;&#125; one[MAXN], two[MAXN];bool cmp(node x, node y)&#123; return x.val &gt; y.val;&#125;void init()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;v); oc = tc = 0; for(int i=1; i&lt;=n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if(a == 1) one[++oc].val = b, one[oc].id = i; else two[++tc].val = b, two[tc].id = i; &#125; sort(one+1, one + oc + 1, cmp); sort(two+1, two + tc + 1, cmp);&#125;int main(int argc, char const *argv[])&#123; init(); sum2[0] = sum1[0] = 0; for(int i=1; i&lt;=tc; i++) sum2[i] = sum2[i - 1] + two[i].val; for(int i=1; i&lt;=oc; i++) sum1[i] = sum1[i - 1] + one[i].val; c1 = -1, c2 = -1, maxv = -1; for(int i=0; i&lt;=oc; i++) &#123; if(i &gt; v) break; int d = sum1[i] + sum2[min((v - i) / 2, tc)]; if(d &gt; maxv) &#123; maxv = d; c1 = i; c2 = min((v - i) / 2, tc); &#125; &#125; if(maxv == -1) &#123; printf(&quot;0\\n&quot;); return 0; &#125; int cnt = 0; printf(&quot;%d\\n&quot;, maxv); for(int i=1; i&lt;=c1; i++) ans[++cnt] = one[i].id; for(int i=1; i&lt;=c2; i++) ans[++cnt] = two[i].id; for(int i=1; i&lt;=cnt; i++) printf(&quot;%d%c&quot;, ans[i], i == cnt? &apos;\\n&apos; : &apos; &apos;); return 0;&#125;/*5 31 92 91 92 101 6243 1 5**/ 更新日志 2014年11月7日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 4 D Mysterious Present","slug":"CF-4D","date":"2014-11-07T10:05:24.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/07/CF-4D/","link":"","permalink":"https://xuanwo.org/2014/11/07/CF-4D/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/4/D 理解题目好像是俄罗斯套娃的二维版，就是求一个二维的最长上升子序列问题。只要按照其中一个变量排序，然后求第二个变量的最长上升子序列即可。","text":"题目源地址： http://codeforces.com/problemset/problem/4/D 理解题目好像是俄罗斯套娃的二维版，就是求一个二维的最长上升子序列问题。只要按照其中一个变量排序，然后求第二个变量的最长上升子序列即可。 代码#define MAXN 5000+10struct node&#123; int no; int w; int h; int prev; int l; node(int no, int w, int h, int prev, int l) &#123; this-&gt;no = no; this-&gt;w = w; this-&gt;h = h; this-&gt;prev = prev; this-&gt;l = l; &#125; bool operator &lt; (const node&amp; e) const &#123; return (w &lt; e.w); &#125;&#125;;int n, w, h;int tmpw, tmph;int cmp(node e1, node e2)&#123; if (e1.w &lt; e2.w &amp;&amp; e1.h &lt; e2.h) return 1; return -1;&#125;int main(int argc, char const *argv[])&#123; vector&lt;node&gt; envs; scanf(&quot;%d %d %d&quot;, &amp;n, &amp;w, &amp;h); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d %d&quot;, &amp;tmpw, &amp;tmph); if (tmpw &lt;= w || tmph &lt;= h) continue; envs.push_back(node(i+1, tmpw, tmph, -1, 1)); &#125; sort(envs.begin(), envs.end()); for (int i = 0; i &lt; envs.size(); i++) &#123; for (int j = 0; j &lt; i; j++) &#123; if (cmp(envs[j], envs[i]) &lt;= 0) continue; if (envs[i].l &gt;= envs[j].l + 1) continue; envs[i].l = envs[j].l + 1; envs[i].prev = j; &#125; &#125; int maxl = 0, pos = -1; for (int i = 0; i &lt; envs.size(); i++) &#123; if (envs[i].l &lt;= maxl) continue; maxl = envs[i].l; pos = i; &#125; if (maxl == 0) &#123; printf(&quot;0\\n&quot;); &#125; else &#123; stack&lt;int&gt; s; while (pos != -1) &#123; s.push(envs[pos].no); pos = envs[pos].prev; &#125; printf(&quot;%d\\n%d&quot;, s.size(), s.top()); s.pop(); while (!s.empty()) &#123; printf(&quot; %d&quot;, s.top()); s.pop(); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月7日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 2 C Commentator problem","slug":"CF-2C","date":"2014-11-06T23:40:26.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/06/CF-2C/","link":"","permalink":"https://xuanwo.org/2014/11/06/CF-2C/","excerpt":"题目源地址： http://codeforces.com/contest/2/problem/C 理解题意很清楚，就是给定三个点，要求出一个点到这三个点的视角相同。要是存在多个这样的点，则选择那个视角最大的点。 &gt;小科普——视角定圆O和不在O上的定点A，从A向O引两条切线，这两条切线所形成的角可以看做视角。又因为已知O的半径r和OA的长，显然，视角的大小为2*asin(r/OA)，也能够利用sin(r/OA)的值来衡量。 做法很神= =，首先找出这个三个点构成的三角形的圆心，然后计算出sin(r/OA)的值，然后分别在上下左右探测，看看哪个值更小。如此循环，直到step的值小于eps就能输出了。","text":"题目源地址： http://codeforces.com/contest/2/problem/C 理解题意很清楚，就是给定三个点，要求出一个点到这三个点的视角相同。要是存在多个这样的点，则选择那个视角最大的点。 &gt;小科普——视角定圆O和不在O上的定点A，从A向O引两条切线，这两条切线所形成的角可以看做视角。又因为已知O的半径r和OA的长，显然，视角的大小为2*asin(r/OA)，也能够利用sin(r/OA)的值来衡量。 做法很神= =，首先找出这个三个点构成的三角形的圆心，然后计算出sin(r/OA)的值，然后分别在上下左右探测，看看哪个值更小。如此循环，直到step的值小于eps就能输出了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-6)#define inf 0x3f3f3f3f#define ll long long intusing namespace std;int dir[4][2]= &#123; &#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125; &#125;;double x=0,y=0;struct node&#123; double x,y,r;&#125; c[3];double p2(double x)&#123; return x*x;&#125;double dis(double x, double y, double xx, double yy)&#123; return sqrt(p2(x-xx)+p2(y-yy));&#125;double f(double x, double y)&#123; double tmp[3],ans=0; for(int i=0; i&lt;3; i++) tmp[i]=dis(x,y,c[i].x,c[i].y)/c[i].r; for(int i=0; i&lt;3; i++) ans+=p2(tmp[i]-tmp[(i+1)%3]); return ans;&#125;void init()&#123; for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%lf%lf%lf&quot;, &amp;c[i].x,&amp;c[i].y,&amp;c[i].r); x+=c[i].x/3; y+=c[i].y/3; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); double step=1; while(step&gt;eps) &#123; double tmp=f(x,y); int tag=-1; for(int i=0; i&lt;4; i++) &#123; double cnt=f(x+dir[i][0]*step, y+dir[i][1]*step); if(cnt&lt;tmp) &#123; tmp=cnt; tag=i; &#125; &#125; if(tag==-1) &#123; step/=2; &#125; else &#123; x=x+dir[tag][0]*step; y=y+dir[tag][1]*step; &#125; &#125; if(f(x,y)&lt;eps) printf(&quot;%.5lf %.5lf\\n&quot;, x,y); return 0;&#125; 更新日志 2014年11月6日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11093 Just Finish it up","slug":"UVa-11093-Just-Finish-it-up","date":"2014-11-06T14:18:10.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/06/UVa-11093-Just-Finish-it-up/","link":"","permalink":"https://xuanwo.org/2014/11/06/UVa-11093-Just-Finish-it-up/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2034 理解比赛的时候没有敲出来。当时看范神拿了一血，默默地去看题。然后觉得应该跟小白书上那个加油站的优先队列是一样的题目，敲了一会儿之后感觉不对，然后就放弃了这道题。后来想想，这两道题的区别在于，一个是环形的路线，一个是单向的路径，处理的方法应该是不一致的。比赛过后想到，其实就算是环形，也是可以处理成单向问题的。只要开一个两倍MAXN的数组，然后从起点开始截取n个数，就能将一个环从起点处截成一条直线。然后就能用类似的办法进行处理了。具体的实现过程是这样：只要用一个数组保存可以添加的油量，然后不断减去消耗的油量，然后再不断进行求和。很显然，当a[i]&gt;=start时，这个站点时可以通过的；当a[i]&lt;start时，这个站点是不可通过的。然后再遍历寻找字典序最小的起点。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2034 理解比赛的时候没有敲出来。当时看范神拿了一血，默默地去看题。然后觉得应该跟小白书上那个加油站的优先队列是一样的题目，敲了一会儿之后感觉不对，然后就放弃了这道题。后来想想，这两道题的区别在于，一个是环形的路线，一个是单向的路径，处理的方法应该是不一致的。比赛过后想到，其实就算是环形，也是可以处理成单向问题的。只要开一个两倍MAXN的数组，然后从起点开始截取n个数，就能将一个环从起点处截成一条直线。然后就能用类似的办法进行处理了。具体的实现过程是这样：只要用一个数组保存可以添加的油量，然后不断减去消耗的油量，然后再不断进行求和。很显然，当a[i]&gt;=start时，这个站点时可以通过的；当a[i]&lt;start时，这个站点是不可通过的。然后再遍历寻找字典序最小的起点。 代码#define MAXN 100000+10int a[2*MAXN],x;int n,t,flag=0;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; flag++; scanf(&quot;%d&quot;, &amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); a[n+i]=a[i]; &#125; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;, &amp;x); a[i]-=x; a[n+i]-=x; &#125; a[0]=0; for(int i=1;i&lt;=2*n;i++) &#123; a[i]+=a[i-1]; &#125; int s=0,mi=1,cn=0; for(int i=0;i&lt;=2*n;i++) &#123; if(a[i]&gt;=mi) &#123; if(++cn&gt;n) break; &#125; else &#123; mi=a[i]; s=i; cn=1; if(i&gt;=n) break; &#125; &#125; printf(&quot;Case %d: &quot;, flag); if(cn&gt;n) printf(&quot;Possible from station %d\\n&quot;, s+1); else printf(&quot;Not possible\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月6日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 12627 Erratic Expansion","slug":"UVa-12627-Erratic-Expansion","date":"2014-11-05T20:11:48.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-12627-Erratic-Expansion/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-12627-Erratic-Expansion/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4352 理解因为有图，所以题意还是蛮清楚的。求给定时间，给定范围中气球的个数= =。也是我心比天高太年轻，试图直接把红球个数和n关系直接撸出来，后来发现着实有点困难。不过发现每当过去一小时，这一行的红球数都会变为原来的两倍。这样问题就变得简单了起来，我只要使用一次递归分治就可以了~","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4352 理解因为有图，所以题意还是蛮清楚的。求给定时间，给定范围中气球的个数= =。也是我心比天高太年轻，试图直接把红球个数和n关系直接撸出来，后来发现着实有点困难。不过发现每当过去一小时，这一行的红球数都会变为原来的两倍。这样问题就变得简单了起来，我只要使用一次递归分治就可以了~ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 30+10ll dp[MAXN];int K,A,B;int t,tcase=0;ll f(int n,int k)&#123; if(n==0) return k&gt;=1; if(dp[n]!=-1&amp;&amp;(1&lt;&lt;n)==k) return dp[n]; n--; if(k&lt;=(1&lt;&lt;n)) return f(n,k)*2; dp[n]=f(n,1&lt;&lt;n); return dp[n]*2+f(n,k-(1&lt;&lt;n));&#125;int main(int argc, char const *argv[])&#123; memset(dp,-1,sizeof(dp)); scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d%d%d&quot;,&amp;K,&amp;A,&amp;B); ll ans=f(K,B)-f(K,A-1); printf(&quot;Case %d: %lld\\n&quot;,++tcase,ans); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10954 Add All","slug":"UVa-10954-Add-All","date":"2014-11-05T20:06:21.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-10954-Add-All/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-10954-Add-All/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1895 理解很明显的一道水题，不过我WA了一发。我一开始觉得，我可以把每个数重复计算的次数加进去，然后很快写完了一个程序，但是报了WA。稍微查了一会儿之后，感觉没有什么问题，又因为很多人过了，于是推倒用优先队列重新写了一发。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1895 理解很明显的一道水题，不过我WA了一发。我一开始觉得，我可以把每个数重复计算的次数加进去，然后很快写完了一个程序，但是报了WA。稍微查了一会儿之后，感觉没有什么问题，又因为很多人过了，于是推倒用优先队列重新写了一发。 代码WA代码（求测试数据）#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 5000+10int n,a[MAXN];ll ans;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;, &amp;n),n) &#123; ans=0; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a,a+n); for(int i=0;i&lt;n;i++) &#123; ans+=(n-i)*a[i]; &#125; printf(&quot;%lld\\n&quot;, ans-a[0]); &#125; return 0;&#125; AC代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int n;int total, cost ;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d&quot;, &amp;n), n) &#123; total = 0, cost = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; while (n--) &#123; int x; scanf(&quot;%d&quot;, &amp;x); q.push(x); &#125; while (q.size() &gt; 1) &#123; total = q.top(); q.pop(); total += q.top(); q.pop(); cost += total; q.push(total); &#125; printf(&quot;%d\\n&quot;, cost); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1471 Defense Lines","slug":"UVa-1471-Defense-Lines","date":"2014-11-05T19:51:46.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-1471-Defense-Lines/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-1471-Defense-Lines/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4217 理解不理会逗比的国王们= =，题意很清楚，给定一个序列，要求删除一段连续的序列之后，剩下的连续递增序列最长，要求输出满足题意的序列的长度。在初始化的时候，就可以设数组l[MAXN]，r[MAXN]来分别保存从左起和从右起的最长递增序列的长度。然后用STL内置的二分来寻找链接的地方，lower_bound(Min + 1, Min + 1 + n, a[i])，返回在数组Min[1~n+1]中比a[i]大的第一个数的位置。在for循环中不断更新ans的值，使得最后的结果一定最长的序列。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4217 理解不理会逗比的国王们= =，题意很清楚，给定一个序列，要求删除一段连续的序列之后，剩下的连续递增序列最长，要求输出满足题意的序列的长度。在初始化的时候，就可以设数组l[MAXN]，r[MAXN]来分别保存从左起和从右起的最长递增序列的长度。然后用STL内置的二分来寻找链接的地方，lower_bound(Min + 1, Min + 1 + n, a[i])，返回在数组Min[1~n+1]中比a[i]大的第一个数的位置。在for循环中不断更新ans的值，使得最后的结果一定最长的序列。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 200000+10int t, n, a[MAXN], l[MAXN], r[MAXN], Min[MAXN];int ans;void init()&#123; ans=0; scanf(&quot;%d&quot;, &amp;n); l[0] = 1; r[n - 1] = 1; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); if (i) &#123; l[i] = 1; if (a[i] &gt; a[i - 1]) l[i] += l[i - 1]; &#125; &#125; for (int i = n - 2; i &gt;= 0; i--) &#123; r[i] = 1; if (a[i] &lt; a[i + 1]) r[i] += r[i + 1]; &#125;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; init(); memset(Min, 0x3f, sizeof(Min)); for (int i = 0; i &lt; n; i++) &#123; int len = lower_bound(Min + 1, Min + 1 + n, a[i]) - Min; ans = max(ans, r[i] + len - 1); Min[l[i]] = min(Min[l[i]], a[i]); &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11572 Unique Snowflakes","slug":"UVa-11572-Unique-Snowflakes","date":"2014-11-05T19:38:51.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-11572-Unique-Snowflakes/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-11572-Unique-Snowflakes/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2619 理解题意是酱紫的：给定一组数，叫你求出不含有重复数字的最长子序列的长度。使用数组pos[x]记录数字x第一次出现的位置，初始化为-1。枚举这个数列，依次记录每一个数的位置。然后用start标记当前这个子序列的起点。显然的，当枚举到i的时候，如果有pos[arr[i]]&lt;start，说明这个数肯定在[start, i-1]之间出现过。此时就停止本次枚举，要是pos[arr[i]]&gt;start，则长度+1，并且进行下一次枚举。直到结束，最后的长度一定是最长的子序列。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2619 理解题意是酱紫的：给定一组数，叫你求出不含有重复数字的最长子序列的长度。使用数组pos[x]记录数字x第一次出现的位置，初始化为-1。枚举这个数列，依次记录每一个数的位置。然后用start标记当前这个子序列的起点。显然的，当枚举到i的时候，如果有pos[arr[i]]&lt;start，说明这个数肯定在[start, i-1]之间出现过。此时就停止本次枚举，要是pos[arr[i]]&gt;start，则长度+1，并且进行下一次枚举。直到结束，最后的长度一定是最长的子序列。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1000010int t,n,a;int arr[MAXN];int pos[MAXN];int cnt,start,maxx;void init()&#123; memset(pos, -1, sizeof(pos)); scanf(&quot;%d&quot;, &amp;n); cnt=0,start=0,maxx=0; for(int i=0; i&lt;n; ++i) scanf(&quot;%d&quot;, &amp;arr[i]); arr[n] = arr[n-1];&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; init(); for(int i=0; i&lt;=n; ++i) &#123; if(pos[arr[i]] &gt;= start) &#123; int tmp = i - start; maxx = max(tmp, maxx); start = pos[arr[i]]+1; pos[arr[i]] = i; &#125; else &#123; pos[arr[i]] = i; &#125; &#125; printf(&quot;%d\\n&quot;, maxx); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11054 Wine trading in Gergovia","slug":"UVa-11054-Wine-trading-in-Gergovia","date":"2014-11-05T19:34:31.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-11054-Wine-trading-in-Gergovia/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-11054-Wine-trading-in-Gergovia/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1995 理解我又逗了= =，想得太复杂。其实不管两个村庄距离有多远或者是他们的需求量有多大，每个村庄实际上都只能跟最近的两个村庄交易，因为运输的时候会经过每一个村庄。因此直接搞就可以了。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1995 理解我又逗了= =，想得太复杂。其实不管两个村庄距离有多远或者是他们的需求量有多大，每个村庄实际上都只能跟最近的两个村庄交易，因为运输的时候会经过每一个村庄。因此直接搞就可以了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 100000+10int n;int bott[MAXN];ll ans;int i;int main(int argc, char const *argv[])&#123; while(scanf(&quot;%d&quot; , &amp;n) &amp;&amp; n) &#123; for(i = 0 ; i &lt; n ; i++) scanf(&quot;%d&quot; , &amp;bott[i]); ans = 0; for(i = 1 ; i &lt; n ; i++) &#123; bott[i] += bott[i-1]; ans += abs(bott[i-1]); &#125; printf(&quot;%lld\\n&quot; , ans); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1152 4 Values whose Sum is 0","slug":"UVa-1152-4-Values-whose-Sum-is-0","date":"2014-11-05T19:31:30.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-1152-4-Values-whose-Sum-is-0/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-1152-4-Values-whose-Sum-is-0/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3593 理解题意非常清楚，就是在一个矩阵里面找出四个数，使得他们的和为零。一开始的想法是DFS，把这个看成一个四层的图，不停搜索就行了。但是DFS写得太搓了，各种姿势挂，后来决定二分暴力乱搞。思路是这样，把这个矩阵分成左右两份，然后只要一个两层的for循环，就能用两个数组保存下所有可能出现的数字组合的和。有一个小小的技巧是，第二份在保存的时候保存为他们的负数，这样在后面的二分中，只要判断是不是相等就可以了，减少了计算量。最后感慨一下，一千六百万的数组也能开的出来= =。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3593 理解题意非常清楚，就是在一个矩阵里面找出四个数，使得他们的和为零。一开始的想法是DFS，把这个看成一个四层的图，不停搜索就行了。但是DFS写得太搓了，各种姿势挂，后来决定二分暴力乱搞。思路是这样，把这个矩阵分成左右两份，然后只要一个两层的for循环，就能用两个数组保存下所有可能出现的数字组合的和。有一个小小的技巧是，第二份在保存的时候保存为他们的负数，这样在后面的二分中，只要判断是不是相等就可以了，减少了计算量。最后感慨一下，一千六百万的数组也能开的出来= =。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 16100000int a[4][4444],n,t;int num1[MAXN],num2[MAXN],c;int i,j,ans,casen=0;int bin(int left,int right,int k)&#123; while(left&lt;=right) &#123; int mid=(left+right)/2; int num=0; if(num2[mid]==k) &#123; num=1; for(i=mid-1; i&gt;=0&amp;&amp;num2[i]==k; i--) num++; for(i=mid+1; i&lt;n*n&amp;&amp;num2[i]==k; i++) num++; return num; &#125; else if(num2[mid]&gt;k) right=mid-1; else left=mid+1; &#125; return 0;&#125;void init()&#123; scanf(&quot;%d&quot;,&amp;n); ans=0; c=0; for(i=0; i&lt;n; i++) &#123; scanf(&quot;%d %d %d %d&quot;,&amp;a[0][i],&amp;a[1][i],&amp;a[2][i],&amp;a[3][i]); &#125; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;n; j++) &#123; num1[c]=a[2][i]+a[3][j]; num2[c++]=-(a[0][i]+a[1][j]); &#125; &#125; sort(num2,num2+c);&#125;int main(int argc, char const *argv[])&#123; int i,j; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; casen++; if(casen&gt;1) printf(&quot;\\n&quot;); init(); for(i=0; i&lt;c; i++) &#123; ans+=bin(0,n*n-1,num1[i]); &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1605 Building for UN","slug":"UVa-1605-Building-for-UN","date":"2014-11-05T19:10:54.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/05/UVa-1605-Building-for-UN/","link":"","permalink":"https://xuanwo.org/2014/11/05/UVa-1605-Building-for-UN/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4480 理解题意要求安排出一个设计方案，使得每一个国家都相邻。乍一看很复杂，但其实只要构造两层，第一层中第i行都是i国家，第二层中第i列都是i国家，就能满足题意。额，算是机智题？","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4480 理解题意要求安排出一个设计方案，使得每一个国家都相邻。乍一看很复杂，但其实只要构造两层，第一层中第i行都是i国家，第二层中第i列都是i国家，就能满足题意。额，算是机智题？ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int n, i, j, k;char c;char intTochar(int x)&#123; if(x&gt;26) return x-27+&apos;A&apos;; return x-1+&apos;a&apos;;&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; printf(&quot;2 %d %d\\n&quot;,n,n); for(i=1; i&lt;=n; i++) &#123; c=intTochar(i); for(j=1; j&lt;=n; j++) &#123; printf(&quot;%c&quot;,c); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); for(i=1; i&lt;=n; i++) &#123; for(j=1; j&lt;=n; j++) &#123; c=intTochar(j); printf(&quot;%c&quot;,c); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 5 B Center Alignment","slug":"CF-5B","date":"2014-11-05T15:43:15.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/05/CF-5B/","link":"","permalink":"https://xuanwo.org/2014/11/05/CF-5B/","excerpt":"题目源地址： http://codeforces.com/contest/5/problem/B 理解题目不难，不过输出上有点问题，因为题目要求左右均匀分布，上一次偏左则下一次需要偏右。当总长度为偶数的时候，没有太大的问题；但是当总长度为奇数时，则需要考虑到底应该偏左还是偏右的问题。那么就需要两次判断，首先判断总长度，也就是最大长度是不是偶数，当总长度不是偶数时，则判断这个字符串是不是偶数。使用一个计数变量num来保存是否是否应该偏左，每一次判断完毕之后都自增一次，这样就能实现保持左右均衡。","text":"题目源地址： http://codeforces.com/contest/5/problem/B 理解题目不难，不过输出上有点问题，因为题目要求左右均匀分布，上一次偏左则下一次需要偏右。当总长度为偶数的时候，没有太大的问题；但是当总长度为奇数时，则需要考虑到底应该偏左还是偏右的问题。那么就需要两次判断，首先判断总长度，也就是最大长度是不是偶数，当总长度不是偶数时，则判断这个字符串是不是偶数。使用一个计数变量num来保存是否是否应该偏左，每一次判断完毕之后都自增一次，这样就能实现保持左右均衡。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;string tmp,a;queue&lt;string&gt; word;int Max,n=0;int len,num=0;;int main()&#123; while(getline(cin,tmp)) &#123; n++; if(Max&lt;tmp.size()) Max=tmp.size(); word.push(tmp); &#125; for(int i=0; i&lt;Max+2; i++) printf(&quot;*&quot;); printf(&quot;\\n&quot;); for(int i=0; i&lt;n; i++) &#123; printf(&quot;*&quot;); a=word.front(); word.pop(); int l=Max-a.size(); int s=l/2; if(l%2!=0) &#123; num++; if(num%2!=0) &#123; for(int j=0; j&lt;s; j++) printf(&quot; &quot;); cout&lt;&lt;a; for(int j=0; j&lt;l-s; j++) printf(&quot; &quot;); printf(&quot;*\\n&quot;); &#125; else &#123; for(int j=0; j&lt;l-s; j++) printf(&quot; &quot;); cout&lt;&lt;a; for(int j=0; j&lt;s; j++) printf(&quot; &quot;); printf(&quot;*\\n&quot;); &#125; &#125; else &#123; for(int j=0; j&lt;s; j++) printf(&quot; &quot;); cout&lt;&lt;a; for(int j=0; j&lt;l-s; j++) printf(&quot; &quot;); printf(&quot;*\\n&quot;); &#125; &#125; for(int i=0; i&lt;Max+2; i++) printf(&quot;*&quot;); return 0;&#125; 更新日志 2014年11月5日日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 5 A Chat Server's Outgoing Traffic","slug":"CF-5A","date":"2014-11-05T14:41:32.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/05/CF-5A/","link":"","permalink":"https://xuanwo.org/2014/11/05/CF-5A/","excerpt":"题目源地址： http://codeforces.com/contest/5/problem/A 理解很简单的一道水题，实际上就是输出字符串个数和乘上当前聊天室里面的人数的和。在具体写的时候有几个需要注意的问题： 输入，老生常谈了= =。空格的处理通常可以用cin.getline(tmp,MAXN)（对char数组）或者是getline(cin,tmp);（对string类）。 每次循环的时候，用于保存聊天内容的字符串都必须清空，否则答案会比正确结果大很多。","text":"题目源地址： http://codeforces.com/contest/5/problem/A 理解很简单的一道水题，实际上就是输出字符串个数和乘上当前聊天室里面的人数的和。在具体写的时候有几个需要注意的问题： 输入，老生常谈了= =。空格的处理通常可以用cin.getline(tmp,MAXN)（对char数组）或者是getline(cin,tmp);（对string类）。 每次循环的时候，用于保存聊天内容的字符串都必须清空，否则答案会比正确结果大很多。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 100+10char tmp[MAXN],word[MAXN];int n=0,ans=0;int main()&#123; while(cin.getline(tmp,MAXN)) &#123; if(tmp[0]==&apos;+&apos;) n++; else if(tmp[0]==&apos;-&apos;) n--; else &#123; for(int i=0;i&lt;strlen(tmp);i++) &#123; if(tmp[i]==&apos;:&apos;) &#123; for(int j=i+1;j&lt;strlen(tmp);j++) &#123; word[j-i-1]=tmp[j]; &#125; &#125; &#125; &#125; ans+=strlen(word)*n; memset(word,0,sizeof(word)); //cout&lt;&lt;debug&lt;&lt;word&lt;&lt;endl; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 更新日志 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 12174 Shuffle","slug":"UVa-12174-Shuffle","date":"2014-11-04T22:19:47.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-12174-Shuffle/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-12174-Shuffle/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=513&amp;page=show_problem&amp;problem=3326 理解题意真心有点看不懂，原谅我这个没有用过音乐播放器的男人= =。 &gt;使用一个音乐播放器，采用随机播放。随机播放的原理时先随机产生一个1~n的排列，然后就按这个排列顺序播放歌曲。播放完这序列的所有歌曲以后，再次随机生成一个1～n的排列，再继续播放。然后，现在给你一个播放历史记录，但是这个记录是不完整的，因为当它开始记录的时候，有些歌可能已经播放过了但是没有记录到。现在给你一段历史记录和播放器中歌的个数，问历史记录中的第一首歌是某个随机列表的第几首，总共有多少可能？ 整个算法可以分成两段，首先处理min(s,n)中的部分，这部分出现的歌曲都放入一个sames容器，以bool数组ok[i]来记录从标号i开始的歌曲是不是都不相同。然后依次枚举第一首歌是第x首，先检查前s-x是不是都不相同，然后从x开始，依次判断x，x+s，x+2s等等是不是符合条件。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=513&amp;page=show_problem&amp;problem=3326 理解题意真心有点看不懂，原谅我这个没有用过音乐播放器的男人= =。 &gt;使用一个音乐播放器，采用随机播放。随机播放的原理时先随机产生一个1~n的排列，然后就按这个排列顺序播放歌曲。播放完这序列的所有歌曲以后，再次随机生成一个1～n的排列，再继续播放。然后，现在给你一个播放历史记录，但是这个记录是不完整的，因为当它开始记录的时候，有些歌可能已经播放过了但是没有记录到。现在给你一段历史记录和播放器中歌的个数，问历史记录中的第一首歌是某个随机列表的第几首，总共有多少可能？ 整个算法可以分成两段，首先处理min(s,n)中的部分，这部分出现的歌曲都放入一个sames容器，以bool数组ok[i]来记录从标号i开始的歌曲是不是都不相同。然后依次枚举第一首歌是第x首，先检查前s-x是不是都不相同，然后从x开始，依次判断x，x+s，x+2s等等是不是符合条件。 代码#define MAXN 100000+10map&lt;int,int&gt; cnt;set&lt;int&gt; sames;bool no[MAXN];int t,s,n;int a[MAXN];int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; memset(no,0,sizeof(no)); cnt.clear(),sames.clear(); scanf(&quot;%d%d&quot;, &amp;s,&amp;n); for(int i=0; i&lt;n; ++i) scanf(&quot;%d&quot;, a+i); int idx=-1; for(int i=0; i&lt;min(s,n); ++i) &#123; if(cnt[a[i]]&gt;0) &#123; idx=i; break; &#125; cnt[a[i]]++; &#125; if(idx==-1) &#123; printf(&quot;%d\\n&quot;, s); continue; &#125; for(int i=idx; i&lt;min(s,n); ++i) &#123; if(cnt[a[i]]&gt;0) sames.insert(a[i]); cnt[a[i]]++; &#125; for(int i=0; i&lt;n; ++i) &#123; if(sames.size()) no[i]=1; if(i+s&lt;n) &#123; if(cnt[a[i+s]]&gt;0) sames.insert(a[i+s]); cnt[a[i+s]]++; &#125; if(cnt[a[i]]==2) sames.erase(a[i]); cnt[a[i]]--; &#125; int ans=0; for(int i=0; i&lt;idx; ++i) &#123; bool can=1; for(int j=i+1; j&lt;n; j+=s) can&amp;=!no[j]; ans+=can; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年11月4日 UVa挂了= =。 2014年11月5日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1451 Average","slug":"UVa-1451-Average","date":"2014-11-04T19:58:06.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-1451-Average/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-1451-Average/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=4197 理解这道题被康逗逗怒拿了FB，默默地去看题，结果完全看不出什么头绪。题意扯到了DNA神马的，其实完全不重要。实际上就是给你一个由0和1组成的串，叫你求出一段长度至少为L的连续子序列，使得这个子序列的平均数最小。如果出现多解，则要求取长度小而且起点小的那个序列。感觉像是一个DP的题目，但是对如何高效地求出这个最优解没有什么思路。后来在题解中看到了一篇论文《浅谈数形结合思想在信息学竞赛中的应用》。首先，我们可以将目标图形化，取每一个数的序号为X上的变量，取0和1为高度，则可以得出任意两点之间的斜率为(sum[j]-sum[i])*1.0/(j-i)。然后开始维护一个曲线，保证这个斜率上的每一段曲线都是斜率最大的。在一个for循环中，设最后的节点是i，i~(L,n)。然后开始寻找这个曲线中满足&gt;L要求的最大斜率。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=4197 理解这道题被康逗逗怒拿了FB，默默地去看题，结果完全看不出什么头绪。题意扯到了DNA神马的，其实完全不重要。实际上就是给你一个由0和1组成的串，叫你求出一段长度至少为L的连续子序列，使得这个子序列的平均数最小。如果出现多解，则要求取长度小而且起点小的那个序列。感觉像是一个DP的题目，但是对如何高效地求出这个最优解没有什么思路。后来在题解中看到了一篇论文《浅谈数形结合思想在信息学竞赛中的应用》。首先，我们可以将目标图形化，取每一个数的序号为X上的变量，取0和1为高度，则可以得出任意两点之间的斜率为(sum[j]-sum[i])*1.0/(j-i)。然后开始维护一个曲线，保证这个斜率上的每一段曲线都是斜率最大的。在一个for循环中，设最后的节点是i，i~(L,n)。然后开始寻找这个曲线中满足&gt;L要求的最大斜率。 代码#define MAXN 100000+10int t,n,L;char str[MAXN];int sum[MAXN], qu[MAXN];double ans;int i;double getK(int i, int j)&#123; return (sum[j]-sum[i])*1.0/(j-i);&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; scanf(&quot;%d %d%s&quot;, &amp;n, &amp;L, str+1); memset(sum,0,sizeof(int)*(n+5)); memset(qu,0,sizeof(int)*(n+5)); for(i=1; i&lt;=n; ++i) sum[i]=sum[i-1]+str[i]-&apos;0&apos;; int len=L; ans=getK(0,L); int st=0,ed=L; int front=0,rear=-1; for(i=L; i&lt;=n; ++i) &#123; int temp=i-L; while(front&lt;rear&amp;&amp;getK(qu[rear],temp)&lt;=getK(qu[rear-1], qu[rear])) rear--; qu[++rear]=temp; while(front&lt;rear&amp;&amp;getK(qu[front],i)&lt;=getK(qu[front+1],i)) front++; double t=getK(qu[front],i); if(t==ans&amp;&amp;len&gt;i-qu[front]) &#123; len=i-qu[front]; st=qu[front]; ed=i; &#125; else if(t&gt;ans) &#123; ans=t; len=i-qu[front]; st=qu[front]; ed=i; &#125; cout&lt;&lt;debug&lt;&lt;getK(qu[front], i)&lt;&lt;endl; &#125; printf(&quot;%d %d\\n&quot;, st+1,ed); &#125; return 0;&#125; 更新日志 2014年11月4日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1606 Amphiphilic Carbon Molecules","slug":"UVa-1606-Amphiphilic-Carbon-Molecules","date":"2014-11-04T16:47:35.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-1606-Amphiphilic-Carbon-Molecules/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-1606-Amphiphilic-Carbon-Molecules/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481 理解比赛的时候太紧张，题目都没敢读全= =。实际上题意还是比较清楚的，给定一个平面，上面有两类点，分别用黑白来表示。现在要求要用一根直线将这个平面分成两半，在直线上面的点全都取走，问，最多能取走多少个点。具体的方法曾经讲到过，就是扫描线算法：任取一个点为原点，建立极坐标系，其他的点使用极角排序，然后扫描来寻找最大值。在实现的时候有两个注意点： atan2的计算误差不可忽略，极角排序的时候要用叉积的方法进行排序，规避精度问题。 叉积方法排序之前，需要做一个投射，将这个平面上的点处理到两个象限中去。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=4481 理解比赛的时候太紧张，题目都没敢读全= =。实际上题意还是比较清楚的，给定一个平面，上面有两类点，分别用黑白来表示。现在要求要用一根直线将这个平面分成两半，在直线上面的点全都取走，问，最多能取走多少个点。具体的方法曾经讲到过，就是扫描线算法：任取一个点为原点，建立极坐标系，其他的点使用极角排序，然后扫描来寻找最大值。在实现的时候有两个注意点： atan2的计算误差不可忽略，极角排序的时候要用叉积的方法进行排序，规避精度问题。 叉积方法排序之前，需要做一个投射，将这个平面上的点处理到两个象限中去。 代码#define MAXN 1000+10int n,pn,ans,cnt,l,r,sum,num,p;struct node&#123; int x,y,sta;&#125;Point[MAXN], temp[MAXN];int detmul(const node a, const node b)&#123; return a.x*b.y-b.x*a.y;&#125;bool cmp(const node a, const node b)&#123; return detmul(a,b)&gt;0;&#125;int main(int argc, char const *argv[])&#123; while(scanf(&quot;%d&quot;, &amp;n),n) &#123; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;Point[i].x, &amp;Point[i].y,&amp;Point[i].sta); &#125; ans=0; for(pn=0;pn&lt;n;pn++) &#123; cnt=0; for(int i=0;i&lt;n;i++) &#123; if(i==pn) continue; temp[cnt].x=Point[i].x-Point[pn].x; temp[cnt].y=Point[i].y-Point[pn].y; temp[cnt].sta=Point[i].sta; if(temp[cnt].y&lt;0||(temp[cnt].y==0&amp;&amp;temp[cnt].x&lt;0)) &#123; temp[cnt].x*=-1; temp[cnt].y*=-1; temp[cnt].sta=!temp[cnt].sta; &#125; cnt++; &#125; sort(temp,temp+cnt,cmp); l=r=sum=0; for(int i=0;i&lt;cnt;i++) &#123; if(temp[i].sta==0) l++; &#125; for(int i=0;i&lt;cnt;i=p) &#123; num=0; for(p=i;p&lt;cnt;p++) &#123; if(detmul(temp[i],temp[p])) break; if(temp[p].sta) r++; else num++; &#125; sum=max(sum,l+r+1); sum=max(sum,cnt-l-r+p-i+1); l-=num; &#125; ans=max(ans,sum); &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年11月4日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 120 Stacks of Flapjacks","slug":"UVa-120-Stacks-of-Flapjacks","date":"2014-11-04T15:19:29.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-120-Stacks-of-Flapjacks/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-120-Stacks-of-Flapjacks/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=56 理解特别涨姿势的一道题。题目不难，只要理解题目中所谓的翻转的意思，很好做。但是我在看题解的过程中，被STL的各种酷炫吓呆，感觉string类真的好好用= =。要是自己用char数组模拟的话，可能会写得各种坑。 默默记录一下： istringstream iss(str);，专门用于操作string类的一个类，可以这样用for(int tmp; iss&gt;&gt;tmp; que.push_front(tmp));。超酷炫有木有！。！ deque&lt;int&gt;::iterator it 迭代器，方便好用不多说= = reverse(Max, que.end()); 用于容器中两个元素的交换，超级好用。 distance(que.begin(), Max) 返回两个迭代器之间的距离，也是相当的赞。 恩- -，好好学STL，大有前途。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=56 理解特别涨姿势的一道题。题目不难，只要理解题目中所谓的翻转的意思，很好做。但是我在看题解的过程中，被STL的各种酷炫吓呆，感觉string类真的好好用= =。要是自己用char数组模拟的话，可能会写得各种坑。 默默记录一下： istringstream iss(str);，专门用于操作string类的一个类，可以这样用for(int tmp; iss&gt;&gt;tmp; que.push_front(tmp));。超酷炫有木有！。！ deque&lt;int&gt;::iterator it 迭代器，方便好用不多说= = reverse(Max, que.end()); 用于容器中两个元素的交换，超级好用。 distance(que.begin(), Max) 返回两个迭代器之间的距离，也是相当的赞。 恩- -，好好学STL，大有前途。 代码string str;int main(int argc, char const *argv[])&#123; while(getline(cin,str)) &#123; cout&lt;&lt;str&lt;&lt;endl; istringstream iss(str); deque&lt;int&gt; que; for(int tmp; iss&gt;&gt;tmp; que.push_front(tmp)); for(deque&lt;int&gt;::iterator it=que.begin(); it!=que.end(); ++it) &#123; deque&lt;int&gt;::iterator Max = max_element(it, que.end()); if(Max!=it) &#123; if(Max != que.end()-1) &#123; reverse(Max, que.end()); cout&lt;&lt;distance(que.begin(), Max)+1&lt;&lt;&apos; &apos;; &#125; reverse(it,que.end()); cout&lt;&lt;distance(que.begin(),it)+1&lt;&lt;&apos; &apos;; &#125; &#125; cout&lt;&lt;&quot;0\\n&quot;; &#125; return 0;&#125; 更新日志 2014年11月4日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 714 Copying Books","slug":"UVa-714-Copying-Books","date":"2014-11-04T13:29:52.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-714-Copying-Books/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-714-Copying-Books/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=113&amp;page=show_problem&amp;problem=655 理解比赛的时候读懂了题意，但是没有拿出来敲，因为感觉自己应该是敲不出来的。实际上，这是一道小白书上提到过的题目，也就是最大值最小化问题。使用一个pos数组来保存是否在此分段，然后使用二分最小值来确定pos的取值。实际上我还不是能够非常具体地描述中间二分的过程，不妨在二分的循环当中打印pos数组的值来找一找感觉。 Input:19 3100 200 300 400 500 600 700 800 900Output:0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 00 0 0 1 0 0 1 0 00 0 0 1 0 0 1 0 00 0 0 0 0 0 0 1 00 0 0 0 0 0 1 1 00 0 0 0 1 0 1 1 00 1 0 0 1 0 1 1 00 1 0 0 1 0 1 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 0100 200 300 400 500 / 600 700 / 800 900 除去最后一行是答案，不去考虑之外，我们可以看到这是一个在中央取值，然后不断向右靠拢的过程。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=113&amp;page=show_problem&amp;problem=655 理解比赛的时候读懂了题意，但是没有拿出来敲，因为感觉自己应该是敲不出来的。实际上，这是一道小白书上提到过的题目，也就是最大值最小化问题。使用一个pos数组来保存是否在此分段，然后使用二分最小值来确定pos的取值。实际上我还不是能够非常具体地描述中间二分的过程，不妨在二分的循环当中打印pos数组的值来找一找感觉。 Input:19 3100 200 300 400 500 600 700 800 900Output:0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 00 0 0 1 0 0 1 0 00 0 0 1 0 0 1 0 00 0 0 0 0 0 0 1 00 0 0 0 0 0 1 1 00 0 0 0 1 0 1 1 00 1 0 0 1 0 1 1 00 1 0 0 1 0 1 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 0 1 00 0 0 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 1 0 0 1 0 1 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 0 0 1 0 00 0 0 0 1 0 1 0 00 0 0 0 1 0 1 0 0100 200 300 400 500 / 600 700 / 800 900 除去最后一行是答案，不去考虑之外，我们可以看到这是一个在中央取值，然后不断向右靠拢的过程。 代码#define MAXN 500+10int m,k;ll arr[MAXN],sum,Min, ans;bool vis[MAXN];int divide(ll M)&#123; memset(vis,0,sizeof(vis)); int cnt=0; int pos=m-1; while(pos&gt;=0) &#123; ll sum=0; bool ok=true; while(pos&gt;=0&amp;&amp;sum+arr[pos]&lt;=M) &#123; ok=false; sum+=arr[pos]; --pos; &#125; if(ok) &#123; return k+1; &#125; if(pos&gt;=0) vis[pos]=true; ++cnt; for(int i=0;i&lt;m;i++) &#123; cout&lt;&lt;vis[i]&lt;&lt;&apos; &apos;; &#125; cout&lt;&lt;endl; &#125; return cnt;&#125;ll binary()&#123; ll l=Min,r=sum,mid; while(l&lt;r) &#123; mid=(l+r)&gt;&gt;1; if(divide(mid)&lt;=k) r=mid; else l=mid+1; &#125; return r;&#125;void init()&#123; scanf(&quot;%d%d&quot;, &amp;m,&amp;k); sum=0,Min=0; for(int i=0; i&lt;m; ++i) &#123; scanf(&quot;%lld&quot;, &amp;arr[i]); sum+=arr[i]; if(arr[i]&gt;Min) Min=arr[i]; &#125;&#125;int main(int argc, char const *argv[])&#123; int t; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; init(); ans=binary(); int cnt=divide(ans); for(int i=0; i&lt;m-1&amp;&amp;cnt&lt;k; ++i) &#123; if(!vis[i]) &#123; vis[i]=true; ++cnt; &#125; &#125; for(int i=0; i&lt;m; ++i) &#123; if(i) printf(&quot; %lld&quot;, arr[i]); else printf(&quot;%lld&quot;, arr[i]); if(vis[i]) &#123; printf(&quot; /&quot;); &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月4日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11134 Fabled Rooks","slug":"UVa-11134-Fabled-Rooks","date":"2014-11-04T12:58:56.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/04/UVa-11134-Fabled-Rooks/","link":"","permalink":"https://xuanwo.org/2014/11/04/UVa-11134-Fabled-Rooks/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=2075 理解比赛的时候没有写出来。其实很容易可以看出来，这个题目可以变成两个子题目，也就是X和Y方向并没有直接的关系，完全可以看成在X方向是不重叠摆放和在Y方向是不重叠摆放的问题。一开始的想法是只要对它进行排序，然后逐个判断是否符合题意就OK，但是后来发现这样并不能解决问题。后来看了题解，决定采用优先队列来维护可以选择的区间。也就是每次都在区间[l,r]中选取l最小且r最小的区间，然后设一个变量maxx保存一下当前已经摆放到了什么位置。要是存在一个l&lt;maxx，那么则需要将这个l修改为maxx，并且重新放入队列中。这样，就能保证后面的棋子都不会和前面已经摆好的重叠。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=2075 理解比赛的时候没有写出来。其实很容易可以看出来，这个题目可以变成两个子题目，也就是X和Y方向并没有直接的关系，完全可以看成在X方向是不重叠摆放和在Y方向是不重叠摆放的问题。一开始的想法是只要对它进行排序，然后逐个判断是否符合题意就OK，但是后来发现这样并不能解决问题。后来看了题解，决定采用优先队列来维护可以选择的区间。也就是每次都在区间[l,r]中选取l最小且r最小的区间，然后设一个变量maxx保存一下当前已经摆放到了什么位置。要是存在一个l&lt;maxx，那么则需要将这个l修改为maxx，并且重新放入队列中。这样，就能保证后面的棋子都不会和前面已经摆好的重叠。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 5010int n;int i,j;struct NODE&#123; int l, r, id; friend bool operator&lt;(const Node&amp; a, const Node&amp;b) &#123; if(a.l != b.l) return a.l &gt; b.l; return a.r &gt; b.r; &#125;&#125; arr1[MAXN], arr2[MAXN];int ans[MAXN][2];bool check(Node* arr, int pos)&#123; priority_queue&lt;Node&gt;Q; for(int i=0; i&lt;n; ++i) Q.push(arr[i]); int maxx=0; while(!Q.empty()) &#123; Node tmp = Q.top(); Q.pop(); if(tmp.r &lt; maxx) return false; if(tmp.l &lt; maxx) &#123; tmp.l=maxx; Q.push(tmp); continue; &#125; int cur = max(maxx, tmp.l); ans[tmp.id][pos] = cur; maxx = cur+1; &#125; return true;&#125;int main(int argc, char const *argv[])&#123; while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123; for(i=0; i&lt;n; ++i) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;arr1[i].l,&amp;arr2[i].l,&amp;arr1[i].r,&amp;arr2[i].r); arr1[i].id = arr2[i].id = i; &#125; if(check(arr1,0) &amp;&amp; check(arr2,1)) &#123; for(i=0; i&lt;n; ++i) printf(&quot;%d %d\\n&quot;, ans[i][0], ans[i][1]); &#125; else &#123; puts(&quot;IMPOSSIBLE&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年10月27日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CF拉练第一场","slug":"Contest-CUGB-CF1","date":"2014-11-04T10:28:10.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/04/Contest-CUGB-CF1/","link":"","permalink":"https://xuanwo.org/2014/11/04/Contest-CUGB-CF1/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=61581#overview 比赛总结这场比赛打得很挫，一上来看到D题之前做过，就直接贴了代码，被学长们狠狠地批评了一顿。确实，之前做过并不意味着我就能直接贴我的代码，我再写一次不一定写得出来，而且也丧失了一次检验自己是否真的确实掌握了的机会。以后一定要多注意，比赛态度要端正，不能看到自己做过的题就像占到了便宜一样，直接贴出自己的AC代码。事实上可以看到，自己跟即将退役的12级差距还是很大的，这些水题都A不掉，或者姿势不优越，考虑不全面，思路受限这些问题暴露的很明显。还是题目做的太少，多做题，多总结。 分题讲解A题（纯水题）通过简单的分析就能搞定，一道比较简单的贪心。http://xuanwo.org/2014/11/03/CF-4B/ B题（DP）没做出来，一开始想的是DFS，但是没有处理好2跟5，以及出现0的一些情况。赛后看题解，才写出来使用DP的解法。http://xuanwo.org/2014/11/03/CF-2B/ C题（模拟）WA了很多发，比赛的时候考虑的还是太不全面，没能从正面解决.http://xuanwo.org/2014/11/02/CF-3C/ D题（计算几何）之前做过的题目，用到了海伦公式和计算圆心角知识。http://xuanwo.org/2014/10/21/CF-1C/ E题（贪心）用的贪心的思想，先使得所有的’?’都变为’)’，再来处理合法性和最优化的问题。http://xuanwo.org/2014/11/03/CF-3D/ 更新日志 2014年11月3日 初稿。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"13级个人赛第一场","slug":"Contest-CUGB-13-Person-1","date":"2014-11-04T10:28:10.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/04/Contest-CUGB-13-Person-1/","link":"","permalink":"https://xuanwo.org/2014/11/04/Contest-CUGB-13-Person-1/","excerpt":"","text":"比赛地址http://acm.hust.edu.cn/vjudge/contest/view.action?cid=61737#overview 比赛总结这次比赛打得还行- -，最近生活比较规律，连带着人也变得机智很多，暴力乱搞加开脑洞，过了很多题。但是，也从侧面暴露出编码能力不强，算法功底不扎实的缺点。接下来还是要好好训练，多多刷题。跟队友多交流，相互促进，不停地PUSH自己。 分题讲解A题（STL，模拟）比赛的时候真的看不懂题意= =，太弱了。赛后看的题解大涨姿势，学会了好多神奇的技巧。只要理解了翻转的过程，题目并不是很难。http://xuanwo.org/2014/11/04/UVa-120-Stacks-of-Flapjacks/ B题（构造）超想像CLJ一样来一句傻逼题。开脑洞过了题之后还没反应过来= =，当时的唯一想法是卧槽，这么逗的题怎么没人过？然后吐槽了范神带歪了榜= =，导致前面很多水题大家都没做出来。http://xuanwo.org/2014/11/05/UVa-1605-Building-for-UN/ C题（暴力）乱搞，开了一个一千六百万的数组二分过了。不知道是谁告诉我只要学会暴力就能区域赛拿银来着= =。http://xuanwo.org/2014/11/05/UVa-1152-4-Values-whose-Sum-is-0/ D题（贪心）把问题想得太复杂，其实X和Y方向根本就没有关系，完全可以分开考虑。http://xuanwo.org/2014/11/04/UVa-11134-Fabled-Rooks/ E题（贪心）大胆地喊一句：傻逼题。想了半天的还差点开始敲网络流模板的我更加傻逼= =。http://xuanwo.org/2014/11/05/UVa-11054-Wine-trading-in-Gergovia/ F题（几何）扫描线算法，当年土豪学长跟我们说过，但是打比赛的时候完全没有印象。也跟读题能力有关系，看到题目长，题意复杂就不敢下手，太弱了，要加强。http://xuanwo.org/2014/11/04/UVa-1606-Amphiphilic-Carbon-Molecules/ G题（模拟）一开始以为是神奇的数据结构，实际上不用那么复杂。http://xuanwo.org/2014/11/05/UVa-11572-Unique-Snowflakes/ H题（二分，乱搞）感觉是最长上升子序列演变过来的题目。http://xuanwo.org/2014/11/05/UVa-1471-Defense-Lines/ I题（几何）赛后看了大神的论文，数形结合是厉害啊= =。http://xuanwo.org/2014/11/04/UVa-1451-Average/ J题（贪心）小白书上的最大值最小化问题。http://xuanwo.org/2014/11/04/UVa-714-Copying-Books/ K题（水题）傻逼题——我还WA了一发。。。http://xuanwo.org/2014/11/05/UVa-10954-Add-All/ L题（分治）貌似是第一次接触分治，这种把大问题分解为多个小问题的思想需要掌握。http://xuanwo.org/2014/11/05/UVa-12627-Erratic-Expansion/ M题（模拟，剪枝）很多人过的题，但是我没想出来怎么敲。http://xuanwo.org/2014/11/06/UVa-11093-Just-Finish-it-up/ N题O题（模拟）跟G题有点像，同样是另外开一个数组用来保存第一次出现的位置，这个技巧感觉很有用。http://xuanwo.org/2014/11/04/UVa-12174-Shuffle/ 更新日志 2014年11月5日 完成部分题解。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 4 B Before an Exam","slug":"CF-4B","date":"2014-11-03T19:13:39.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/03/CF-4B/","link":"","permalink":"https://xuanwo.org/2014/11/03/CF-4B/","excerpt":"题目源地址： http://codeforces.com/contest/4/problem/B 理解水题一枚。首先计算出最小的边界和，然后计算出最大的边界和。只要题目给定的sum不在这个范围内，一定无解。然后使用贪心的方法，计算出tem=最大边界和-sum。然后一个一个减去两个边界之间的差值，直到tem被减为零。","text":"题目源地址： http://codeforces.com/contest/4/problem/B 理解水题一枚。首先计算出最小的边界和，然后计算出最大的边界和。只要题目给定的sum不在这个范围内，一定无解。然后使用贪心的方法，计算出tem=最大边界和-sum。然后一个一个减去两个边界之间的差值，直到tem被减为零。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 30+10int sum,d,Max[MAXN],Min[MAXN];int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d %d&quot;,&amp;d,&amp;sum)) &#123; int Maxt=0,Mint=0; for(int i=0;i&lt;d;i++) &#123; scanf(&quot;%d %d&quot;,Min+i,Max+i); Mint+=Min[i]; Maxt+=Max[i]; &#125; if(sum&gt;=Mint&amp;&amp;sum&lt;=Maxt) &#123; puts(&quot;YES&quot;); int tem=Maxt-sum; for(int i=0;i&lt;d;i++) &#123; if(Max[i]-Min[i]&lt;tem) &#123; tem-=(Max[i]-Min[i]); Max[i]=Min[i]; &#125; else &#123; Max[i]-=tem; break; &#125; &#125; for(int i=0;i&lt;d;i++) if(i!=d-1) printf(&quot;%d &quot;,Max[i]); else printf(&quot;%d\\n&quot;,Max[i]); &#125; else &#123; puts(&quot;NO&quot;); &#125; &#125;&#125; 更新日志 2014-11-3 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 3 D Least Cost Bracket Sequence","slug":"CF-3D","date":"2014-11-03T17:18:07.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/03/CF-3D/","link":"","permalink":"https://xuanwo.org/2014/11/03/CF-3D/","excerpt":"题目源地址： http://codeforces.com/contest/3/problem/D 理解比赛的时候没有做出来，赛后看了琦神的解题报告才明白应该怎么敲。实际上这个题目需要解决两个问题：第一是合法性，也就是是否满足左右括号匹配；第二是最优化，也就是要求Cost消耗最小。使用一个变量cnt遍历输入的字符串，遇到’(‘则自增，遇到’)’则自减。这样，只要判断cnt是否为零，就能判断是不是合法。一开始的时候将每一个’?’都重置为’)’，然后维护一个保存左右括号消耗差和当前节点的优先队列。然后开始不断地从优先队列中取出键对，使用保存了所有右括号消耗和的ss变量去减。经过这样的处理之后，cnt只有两种情况。cnt不为零时，说明不可能合法，输出”-1”，cnt为零时，说明有解，输出ss以及最后符合要求的字符串。","text":"题目源地址： http://codeforces.com/contest/3/problem/D 理解比赛的时候没有做出来，赛后看了琦神的解题报告才明白应该怎么敲。实际上这个题目需要解决两个问题：第一是合法性，也就是是否满足左右括号匹配；第二是最优化，也就是要求Cost消耗最小。使用一个变量cnt遍历输入的字符串，遇到’(‘则自增，遇到’)’则自减。这样，只要判断cnt是否为零，就能判断是不是合法。一开始的时候将每一个’?’都重置为’)’，然后维护一个保存左右括号消耗差和当前节点的优先队列。然后开始不断地从优先队列中取出键对，使用保存了所有右括号消耗和的ss变量去减。经过这样的处理之后，cnt只有两种情况。cnt不为零时，说明不可能合法，输出”-1”，cnt为零时，说明有解，输出ss以及最后符合要求的字符串。 代码#define MAXN 50000+10char s[MAXN];ll ss;int cnt;int a,b;priority_queue&lt;pair&lt;ll, int&gt; &gt; que;int main(int argc, char const *argv[])&#123; scanf(&quot;%s&quot;, s+1); ss=0,cnt=0; for(int i=1; s[i]; i++) &#123; if(s[i]==&apos;(&apos;) &#123; cnt++; &#125; else if(s[i]==&apos;)&apos;) &#123; cnt--; &#125; else &#123; scanf(&quot;%d%d&quot;, &amp;a,&amp;b); ss+=b; cnt--; s[i]=&apos;)&apos;; que.push(pair&lt;ll,int&gt; (b-a,i)); &#125; if(cnt&lt;0) &#123; if(que.empty()) break; pair&lt;ll,int&gt; f = que.top(); que.pop(); ss-=f.first; cnt+=2; s[f.second]=&apos;(&apos;; &#125; &#125; if(cnt!=0) printf(&quot;-1\\n&quot;); else printf(&quot;%lld\\n%s\\n&quot;, ss,s+1); return 0;&#125; 更新日志 2014年11月3日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 2 B The least round way","slug":"CF-2B","date":"2014-11-03T15:02:38.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/03/CF-2B/","link":"","permalink":"https://xuanwo.org/2014/11/03/CF-2B/","excerpt":"题目源地址： http://codeforces.com/contest/2/problem/B 理解比赛的时候没有做出来，一看就知道应该是一个DP，选取一个2或者5最少的路径。首先处理一下，设TWO为0，FIVE为1。在输入的时候就进行判断，当前输入的数和’0’，’2’，’5’之间的关系。得到的结果存在一个数组中，这样就得到整个数组中最多的0的个数。然后对2和5的数量进行比较，只需要考虑比较少的那个。然后对第一个数为0的情况进行特判，此时只要随手输出就可以了。如果第一个数不为0，则开始取2比较少的路径开始行走。 &gt;大概是我写得不是很优美= =，在提交的时候遇到了各种问题，debug了半天，还是没有找出究竟错在哪里。直到我脑洞一开，把所有变量的定义放在了main函数的里面，居然过了！过了！！了！！！蛋疼，不知道问题到底在哪里= =，唉，存疑。","text":"题目源地址： http://codeforces.com/contest/2/problem/B 理解比赛的时候没有做出来，一看就知道应该是一个DP，选取一个2或者5最少的路径。首先处理一下，设TWO为0，FIVE为1。在输入的时候就进行判断，当前输入的数和’0’，’2’，’5’之间的关系。得到的结果存在一个数组中，这样就得到整个数组中最多的0的个数。然后对2和5的数量进行比较，只需要考虑比较少的那个。然后对第一个数为0的情况进行特判，此时只要随手输出就可以了。如果第一个数不为0，则开始取2比较少的路径开始行走。 &gt;大概是我写得不是很优美= =，在提交的时候遇到了各种问题，debug了半天，还是没有找出究竟错在哪里。直到我脑洞一开，把所有变量的定义放在了main函数的里面，居然过了！过了！！了！！！蛋疼，不知道问题到底在哪里= =，唉，存疑。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;stdarg.h&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define N 1100+10const int TWO = 0;const int FIVE = 1;int main()&#123; int sum[N][N][2]; int dir[N][N][2]; char output[N*4]; int n,i,j,k; ll tmp,ans; int x,y,n25[2]; int len, type,nowx,nowy; bool ok; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; ok = false; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;n; j++) &#123; scanf(&quot;%d&quot;,&amp;tmp); if(tmp == 0) &#123; ok = true; x = i,y = j; n25[TWO] = n25[FIVE] = 1; &#125; else &#123; n25[TWO] = n25[FIVE] = 0; while(tmp %2 == 0) &#123; n25[TWO]++; tmp &gt;&gt;= 1; &#125; while(tmp %5 == 0) &#123; n25[FIVE]++; tmp /= 5; &#125; &#125; for(k=0; k&lt;2; k++) &#123; if(!i &amp;&amp; !j) &#123; sum[i][j][k] = n25[k]; &#125; else if(j &amp;&amp; i) &#123; if(sum[i-1][j][k] &lt; sum[i][j-1][k]) &#123; dir[i][j][k] = 1; sum[i][j][k] = sum[i-1][j][k] + n25[k]; &#125; else &#123; dir[i][j][k] = 0; sum[i][j][k] = sum[i][j-1][k] + n25[k]; &#125; &#125; else if(!i) &#123; dir[i][j][k] = 0; sum[i][j][k] = sum[i][j-1][k] + n25[k]; &#125; else if(!j) &#123; dir[i][j][k] = 1; sum[i][j][k] = sum[i-1][j][k] + n25[k]; &#125; &#125; &#125; &#125; k = TWO; if(sum[n-1][n-1][TWO] &gt; sum[n-1][n-1][FIVE]) k = FIVE; if(sum[n-1][n-1][k] &gt; 1 &amp;&amp; ok) &#123; printf(&quot;1\\n&quot;); for(int i = 0; i &lt; x; i++) putchar(&apos;D&apos;); for(int j = 0; j &lt; y; j++) putchar(&apos;R&apos;); for(int i = x; i &lt; n-1; i++) putchar(&apos;D&apos;); for(int j = y; j &lt; n-1; j++) putchar(&apos;R&apos;); putchar(&apos;\\n&apos;); &#125; else &#123; printf(&quot;%d\\n&quot;, sum[n-1][n-1][k]); output[2*n-2] = 0; for(i = n-1, j = n-1; i &gt; 0 || j &gt; 0; dir[i][j][k]?i--:j--) output[i+j-1] = dir[i][j][k]?&apos;D&apos;:&apos;R&apos;; printf(&quot;%s\\n&quot;, output); &#125; &#125; return 0;&#125; 更新日志 2014年11月3日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 4 A Watermelon","slug":"CF-4A","date":"2014-11-03T11:23:56.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/03/CF-4A/","link":"","permalink":"https://xuanwo.org/2014/11/03/CF-4A/","excerpt":"题目源地址： http://codeforces.com/contest/4/problem/A 理解真不愧是过了1W+的题= =，水的真可怕。唯一的trick是当w等于2的时候，不能分成两个偶数。","text":"题目源地址： http://codeforces.com/contest/4/problem/A 理解真不愧是过了1W+的题= =，水的真可怕。唯一的trick是当w等于2的时候，不能分成两个偶数。 代码int w;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;w); if(w==2) printf(&quot;NO\\n&quot;); else &#123; if(w%2==0) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月3日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 3 A Shortest path of the king","slug":"CF-3A","date":"2014-11-03T11:03:26.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/03/CF-3A/","link":"","permalink":"https://xuanwo.org/2014/11/03/CF-3A/","excerpt":"题目源地址： http://codeforces.com/contest/3/problem/A 理解第一开始的想法是可以用DFS或者BFS搞定。后来仔细想了想，发现其实不需要这么复杂，通过建立一个坐标系，可以轻松搞定这个问题。首先坐标化，将A~H转化为1~8，方便后续的处理，同时计算出终点与起点位移在x，y轴上的投影，分别设为mx，my。然后下面是模拟的步骤： 处理斜角：循环对mx和my进行递增或者递减的操作，直到有一个值变为零。 处理直线：对mx或者my进行递增或者递减的操作，直到这个值也为零，此时已经模拟完毕。 有两个值得注意的地方： 首先需要输出步数，很显然，步数就是max(abs(mx),abs(my))。 不需要记忆路径，每次处理mx和my的时候，顺便把路径输出即可。","text":"题目源地址： http://codeforces.com/contest/3/problem/A 理解第一开始的想法是可以用DFS或者BFS搞定。后来仔细想了想，发现其实不需要这么复杂，通过建立一个坐标系，可以轻松搞定这个问题。首先坐标化，将A~H转化为1~8，方便后续的处理，同时计算出终点与起点位移在x，y轴上的投影，分别设为mx，my。然后下面是模拟的步骤： 处理斜角：循环对mx和my进行递增或者递减的操作，直到有一个值变为零。 处理直线：对mx或者my进行递增或者递减的操作，直到这个值也为零，此时已经模拟完毕。 有两个值得注意的地方： 首先需要输出步数，很显然，步数就是max(abs(mx),abs(my))。 不需要记忆路径，每次处理mx和my的时候，顺便把路径输出即可。 代码char a[10];int sx,sy,ex,ey;int ans;int mx,my;void init()&#123; gets(a); sx=a[0]-&apos;a&apos;+1; sy=a[1]-&apos;0&apos;; gets(a); ex=a[0]-&apos;a&apos;+1; ey=a[1]-&apos;0&apos;; mx=ex-sx; my=ey-sy;&#125;int main(int argc, char const *argv[])&#123; init(); ans=max(abs(mx),abs(my)); printf(&quot;%d\\n&quot;, ans); while(mx*my!=0) &#123; if(mx&gt;0&amp;&amp;my&gt;0) &#123; printf(&quot;RU\\n&quot;); mx--; my--; &#125; else if(mx&gt;0&amp;&amp;my&lt;0) &#123; printf(&quot;RD\\n&quot;); mx--; my++; &#125; else if(mx&lt;0&amp;&amp;my&gt;0) &#123; printf(&quot;LU\\n&quot;); mx++; my--; &#125; else &#123; printf(&quot;LD\\n&quot;); mx++; my++; &#125; &#125; if(mx&gt;0) &#123; while(mx&gt;0) &#123; printf(&quot;R\\n&quot;); mx--; &#125; &#125; else if(mx&lt;0) &#123; while(mx&lt;0) &#123; printf(&quot;L\\n&quot;); mx++; &#125; &#125; else if(my&gt;0) &#123; while(my&gt;0) &#123; printf(&quot;U\\n&quot;); my--; &#125; &#125; else &#123; while(my&lt;0) &#123; printf(&quot;D\\n&quot;); my++; &#125; &#125; return 0;&#125; 更新日志 2014年11月3日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 3 C Tic-tac-toe","slug":"CF-3C","date":"2014-11-02T17:30:22.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/02/CF-3C/","link":"","permalink":"https://xuanwo.org/2014/11/02/CF-3C/","excerpt":"题目源地址： http://codeforces.com/problemset/problem/3/C 理解一开始看到3*3，第一反应是想要枚举出所有可能的情况，也就是总共有9^3次种，但是发现自己很难处理这些情况，后来还是决定用暴力模拟的方法来做。 错误解法为了简化情况的讨论，我取’.’为0，’X’为1，’0’为2。这样，只要三个数的积为0，说明没有人胜利；三个数的积为1，说明先手胜；三个数的积为8，说明后手胜。这样，在判定胜负的时候，情况就简单了很多。但是，我犯的错误就是对非法的状况考虑得不全面，或者说，懒得去自己判定是否非法，直接将非法的判断写在else语句里面，导致这段语句摆在前面挂test4，摆在后面挂test8这样尴尬局面的发生。 正确解法赛后我重新写了这道题，正面强干，没有转换成int数组来处理。将胜负判定和非法判定全都写成了独立的函数，在最开始先判断是否非法，然后判定有没有出现胜者，最后判定是谁进行下一步。","text":"题目源地址： http://codeforces.com/problemset/problem/3/C 理解一开始看到3*3，第一反应是想要枚举出所有可能的情况，也就是总共有9^3次种，但是发现自己很难处理这些情况，后来还是决定用暴力模拟的方法来做。 错误解法为了简化情况的讨论，我取’.’为0，’X’为1，’0’为2。这样，只要三个数的积为0，说明没有人胜利；三个数的积为1，说明先手胜；三个数的积为8，说明后手胜。这样，在判定胜负的时候，情况就简单了很多。但是，我犯的错误就是对非法的状况考虑得不全面，或者说，懒得去自己判定是否非法，直接将非法的判断写在else语句里面，导致这段语句摆在前面挂test4，摆在后面挂test8这样尴尬局面的发生。 正确解法赛后我重新写了这道题，正面强干，没有转换成int数组来处理。将胜负判定和非法判定全都写成了独立的函数，在最开始先判断是否非法，然后判定有没有出现胜者，最后判定是谁进行下一步。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int xcnt;int ocnt;char brd[3][3];bool win(char tmp)&#123; for (int i = 0; i &lt; 3; i++) &#123; if (brd[i][0] == tmp &amp;&amp; brd[i][1] == tmp &amp;&amp; brd[i][2] == tmp) return true; if (brd[0][i] == tmp &amp;&amp; brd[1][i] == tmp &amp;&amp; brd[2][i] == tmp) return true; &#125; if (brd[1][1] != tmp) return false; if (brd[0][0] == tmp &amp;&amp; brd[2][2] == tmp) return true; if (brd[0][2] == tmp &amp;&amp; brd[2][0] == tmp) return true; return false;&#125;bool legal()&#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; xcnt += brd[i][j] == &apos;X&apos;; ocnt += brd[i][j] == &apos;0&apos;; &#125; &#125; if (xcnt - ocnt &gt; 1) return false; if (xcnt - ocnt &lt; 0) return false; if (win(&apos;X&apos;) &amp;&amp; xcnt == ocnt) return false; if (win(&apos;0&apos;) &amp;&amp; xcnt - ocnt == 1) return false; return true;&#125;int main(int argc, char const *argv[])&#123; xcnt = 0; ocnt = 0; char stmp[4]; for (int i = 0; i &lt; 3; i++) &#123; scanf(&quot;%s&quot;, stmp); for (int j = 0; j &lt; 3; j++) brd[i][j] = stmp[j]; &#125; do &#123; if (!legal()) &#123; printf(&quot;illegal\\n&quot;); break; &#125; if (win(&apos;X&apos;)) &#123; printf(&quot;the first player won\\n&quot;); break; &#125; if (win(&apos;0&apos;)) &#123; printf(&quot;the second player won\\n&quot;); break; &#125; if (xcnt + ocnt == 9) &#123; printf(&quot;draw\\n&quot;); break; &#125; if (xcnt == ocnt) &#123; printf(&quot;first\\n&quot;); break; &#125; if (xcnt - ocnt == 1) &#123; printf(&quot;second\\n&quot;); break; &#125; &#125; while (true); return 0;&#125; 更新日志 2014年11月2日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 1374 Power Calculus","slug":"UVa-1374-Power-Calculus","date":"2014-11-02T15:04:43.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/02/UVa-1374-Power-Calculus/","link":"","permalink":"https://xuanwo.org/2014/11/02/UVa-1374-Power-Calculus/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=512&amp;page=show_problem&amp;problem=4120 理解这次的题意比较清楚，就是给定n，求出从1变换到n的最小步数。同样的迭代深搜，- -，我不行了= =，一口气补了三道，整个人都虚了。。 还是来小结一下吧。以前做的DFS都是裸题，很容易就能看出来。而迭代深搜这一类的题目，通常都是给定一些条件，要求求出指定条件的一些组合，可能是字符串也有可能是数。而且，通常都会有暴力的做法，不过姿势不优越的话，很容易超时。然后在迭代深搜的过程中，一定要注意初始状态和边界条件，要不然很容易陷入死循环或者无法得到完整的结果。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=512&amp;page=show_problem&amp;problem=4120 理解这次的题意比较清楚，就是给定n，求出从1变换到n的最小步数。同样的迭代深搜，- -，我不行了= =，一口气补了三道，整个人都虚了。。 还是来小结一下吧。以前做的DFS都是裸题，很容易就能看出来。而迭代深搜这一类的题目，通常都是给定一些条件，要求求出指定条件的一些组合，可能是字符串也有可能是数。而且，通常都会有暴力的做法，不过姿势不优越的话，很容易超时。然后在迭代深搜的过程中，一定要注意初始状态和边界条件，要不然很容易陷入死循环或者无法得到完整的结果。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define N 3005int aid, tmp, v[N], rec[N], pTow[50], ans[N];bool dfs(int d, int s)&#123; if (d == tmp &amp;&amp; s == aid) return true; if (d &gt;= tmp || s &gt; 1500) return false; if (s * pTow[tmp - d] &lt; aid) return false; rec[d] = s; v[s] = 1; for (int i = 0; i &lt;= d; i++) &#123; int u = rec[i] + s; if (v[u] == 0) if (dfs(d + 1, u)) return true; u = abs(s - rec[i]); if (v[u] == 0) if (dfs(d + 1, u)) return true; &#125; v[s] = 0; return false;&#125;int solve()&#123; tmp = 0; memset(v, 0, sizeof(v)); while (1) &#123; if (dfs(0, 1)) break; tmp++; &#125; return tmp;&#125;void init()&#123; pTow[0] = 1; for (int i = 1; i &lt;= 31; i++) pTow[i] = pTow[i - 1] * 2;&#125;int main(int argc, char const *argv[])&#123; init(); while (scanf(&quot;%d&quot;, &amp;aid) == 1 &amp;&amp; aid) &#123; printf(&quot;%d\\n&quot;, solve()); &#125; return 0;&#125; 更新日志 2014年11月2日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 129 Krypton Factor","slug":"UVa-129-Krypton-Factor","date":"2014-11-02T14:52:47.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/02/UVa-129-Krypton-Factor/","link":"","permalink":"https://xuanwo.org/2014/11/02/UVa-129-Krypton-Factor/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=65 理解题意不是很好懂= =，我搬运一下翻译。 &gt;Problem“超级氪因素大赛”(译注：英国的一档电视心智竞答节目）的主办方雇你来对付那些足智多谋的参赛选手。在比赛的一个环节中，节目主持人将念出一长串的字母来考验选手的记忆能力。因为许多选手都是分析字串模式的高手，为了增加一些比赛的难度，主办方决定不再使用那些含有特定重复子串的字串。但是他们又不能将所有重复的子串都删掉，如果那样的话字串中就不存在两个相同的单字了，这反倒会让问题变的非常简单。为了解决这一问题，他们决定仅删除那些包含相邻重复子串的字串。我们将存在上述相邻重复情况的字串称为“easy”（简单），否则称为“hard”（难）。 &gt;Input and Output为了能给节目主持人提供无限量的问题字串，要求你来写一个程序执行生成运算。程序从输入中读取多行数据，每行包括两个整数n和L（即按此顺序给出），其中n &gt; 0，L的范围是1 ≤ L ≤ 26。根据这些输入，程序要按照字母表升序打印出第n个“hard”字串（由字母表中的前L个字母构成），并在接下来的一行打印这个串的长度。按照上述规则，第一个串应该是“A”。对于给定的n和L，你可以认为第n个“hard”串是一定存在的。比方说，当L = 3时，头7个“hard”字串为：AABABAABACABACAABACABABACABA字串可能很长，因此要将它们分成4个字为一组，中间用空格隔开。如果超过16组，则换一行，再接着输出第17组。ABAC ABA7输入由一行两个零表示结束。你的程序可以限定最大的字串长度为80。 回溯搜索，还用到了string的一些比较方便的函数。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=3&amp;page=show_problem&amp;problem=65 理解题意不是很好懂= =，我搬运一下翻译。 &gt;Problem“超级氪因素大赛”(译注：英国的一档电视心智竞答节目）的主办方雇你来对付那些足智多谋的参赛选手。在比赛的一个环节中，节目主持人将念出一长串的字母来考验选手的记忆能力。因为许多选手都是分析字串模式的高手，为了增加一些比赛的难度，主办方决定不再使用那些含有特定重复子串的字串。但是他们又不能将所有重复的子串都删掉，如果那样的话字串中就不存在两个相同的单字了，这反倒会让问题变的非常简单。为了解决这一问题，他们决定仅删除那些包含相邻重复子串的字串。我们将存在上述相邻重复情况的字串称为“easy”（简单），否则称为“hard”（难）。 &gt;Input and Output为了能给节目主持人提供无限量的问题字串，要求你来写一个程序执行生成运算。程序从输入中读取多行数据，每行包括两个整数n和L（即按此顺序给出），其中n &gt; 0，L的范围是1 ≤ L ≤ 26。根据这些输入，程序要按照字母表升序打印出第n个“hard”字串（由字母表中的前L个字母构成），并在接下来的一行打印这个串的长度。按照上述规则，第一个串应该是“A”。对于给定的n和L，你可以认为第n个“hard”串是一定存在的。比方说，当L = 3时，头7个“hard”字串为：AABABAABACABACAABACABABACABA字串可能很长，因此要将它们分成4个字为一组，中间用空格隔开。如果超过16组，则换一行，再接着输出第17组。ABAC ABA7输入由一行两个零表示结束。你的程序可以限定最大的字串长度为80。 回溯搜索，还用到了string的一些比较方便的函数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;void Sequence(string &amp;str, int &amp;n, int L)&#123; int nLen = str.length(), nHalf = (str.length() + 1) / 2; for (char i = &apos;A&apos;, iEnd = L + &apos;A&apos;, m = 1; i &lt; iEnd; ++i) &#123; str.push_back(i); for (m = 1; m &lt;= nHalf; ++m) &#123; if (equal(str.end() - m, str.end(), str.end() - m * 2)) &#123; m = 0; break; &#125; &#125; if (m != 0) &#123; if (--n == 0) return; Sequence(str, n, L); if (n == 0) return; &#125; str.erase(nLen); &#125;&#125;int main(int argc, char const *argv[])&#123; for (int n, L; cin &gt;&gt; n &gt;&gt; L &amp;&amp; n != 0; ) &#123; string str; Sequence(str, n, L); int nLen = str.length(); for (size_t i = 4; i &lt; str.length(); i += 5) &#123; str.insert(str.begin() + i, i == 79 ? &apos;\\n&apos; : &apos; &apos;); &#125; cout &lt;&lt; str &lt;&lt; &apos;\\n&apos; &lt;&lt; nLen &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年11月2日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 524 Prime Ring Problem","slug":"UVa-524-Prime-Ring-Problem","date":"2014-11-02T13:47:34.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/02/UVa-524-Prime-Ring-Problem/","link":"","permalink":"https://xuanwo.org/2014/11/02/UVa-524-Prime-Ring-Problem/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=465 理解一开始写了一个特别暴力的程序，吃饭之前让它一直跑，但是一直到我吃完饭回来还在跑14- -，默然泪。然后推倒重来，开始用回朔法重写。实际上，我并不需要把所有的排列完全生成出来再进行判断，通过回朔法，我可以在生成排列的同时进行判断。这里也运用了深搜的思想，实际上是一个n*n的矩阵，我要找出满足表达式i+A[cur-1]为指数的那条路径。搞定了主要的算法，下面就是一些细节的处理。首先，我不需要每一次都调用isPrime函数，因为n&lt;=16，也就是可能出现的最大和是小于32的，我可以在预处理中先判断好是否为质数再拿来用。其次，事先必须指定A[0]=1，vis[1]=1，同时dfs()是从1开始的，注意数组的下标。最后，是输出的处理：每一行末尾的空格，每组数据之间的空行，不要多也不要少，虽然琐碎但是却会决定你能否AC。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=465 理解一开始写了一个特别暴力的程序，吃饭之前让它一直跑，但是一直到我吃完饭回来还在跑14- -，默然泪。然后推倒重来，开始用回朔法重写。实际上，我并不需要把所有的排列完全生成出来再进行判断，通过回朔法，我可以在生成排列的同时进行判断。这里也运用了深搜的思想，实际上是一个n*n的矩阵，我要找出满足表达式i+A[cur-1]为指数的那条路径。搞定了主要的算法，下面就是一些细节的处理。首先，我不需要每一次都调用isPrime函数，因为n&lt;=16，也就是可能出现的最大和是小于32的，我可以在预处理中先判断好是否为质数再拿来用。其次，事先必须指定A[0]=1，vis[1]=1，同时dfs()是从1开始的，注意数组的下标。最后，是输出的处理：每一行末尾的空格，每组数据之间的空行，不要多也不要少，虽然琐碎但是却会决定你能否AC。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 50int n,flag=0;int A[MAXN],isp[MAXN],vis[MAXN];bool isPrime(int x)&#123; for(int j=2; j&lt;=(int)sqrt(x); j++) &#123; if(x%j==0) return false; &#125; return true;&#125;void dfs(int cur)&#123; if(cur==n &amp;&amp; isp[A[0]+A[n-1]]) &#123; for(int i=0; i&lt;n; i++) &#123; printf(&quot;%d&quot;, A[i]); if(i!=n-1) printf(&quot;%c&quot;, &apos; &apos;); &#125; printf(&quot;\\n&quot;); &#125; else for(int i=2; i&lt;=n; i++) &#123; if((!vis[i]&amp;&amp;isp[i+A[cur-1]])) &#123; A[cur]=i; vis[i]=1; dfs(cur+1); vis[i]=0; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; for(int i=1; i&lt;100; i++) &#123; if(isPrime(i)) isp[i]=i; else isp[i]=0; &#125; while(~scanf(&quot;%d&quot;, &amp;n)) &#123; flag++; if(flag&gt;1) printf(&quot;\\n&quot;); printf(&quot;Case %d:\\n&quot;, flag); memset(vis,0,sizeof(vis)); A[0]=1; vis[1]=1; dfs(1); &#125; return 0;&#125; 更新日志 2014年11月2日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 725 Division","slug":"UVa-725-Division","date":"2014-11-02T11:58:24.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/02/UVa-725-Division/","link":"","permalink":"https://xuanwo.org/2014/11/02/UVa-725-Division/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=9&amp;page=show_problem&amp;problem=666 理解提议比较简单，给你0~9这十个数字，要求将其组合为两个五位数X和Y，使得其满足X/Y=N这样的形式。然后就想到了用STL里面的next_permutation函数，很快把代码写了出来，中间还用到了queue来存储答案。不过WA了两发之后开始怀疑是不是STL效率太低导致T了，改用数组模拟，但是还是WA了。经过三个小时的漫长Debug之路，才发现原来问题出在输入输出，我多输出了一个空行！！！真的是。。。太。。。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=9&amp;page=show_problem&amp;problem=666 理解提议比较简单，给你0~9这十个数字，要求将其组合为两个五位数X和Y，使得其满足X/Y=N这样的形式。然后就想到了用STL里面的next_permutation函数，很快把代码写了出来，中间还用到了queue来存储答案。不过WA了两发之后开始怀疑是不是STL效率太低导致T了，改用数组模拟，但是还是WA了。经过三个小时的漫长Debug之路，才发现原来问题出在输入输出，我多输出了一个空行！！！真的是。。。太。。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int num[10]= &#123;0,1,2,3,4,5,6,7,8,9&#125;;int a[100][100],b[100][100];int ans[100];int n,x,y,tmp;void init()&#123; memset(ans,0,sizeof(ans)); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); do &#123; x=num[0]*10000+num[1]*1000+num[2]*100+num[3]*10+num[4]; y=num[5]*10000+num[6]*1000+num[7]*100+num[8]*10+num[9]; if(x%y==0) &#123; tmp=x/y; a[tmp][ans[tmp]]=x; b[tmp][ans[tmp]]=y; ans[tmp]++; &#125; &#125; while(next_permutation(num,num+10));&#125;int main(int argc, char const *argv[])&#123; init(); int casen=0; while(~scanf(&quot;%d&quot;, &amp;n)&amp;&amp;n) &#123; if(casen&gt;0) printf(&quot;\\n&quot;); casen++; if(ans[n]==0) printf(&quot;There are no solutions for %d.\\n&quot;, n); else &#123; for(int i=0; i&lt;ans[n]; i++) &#123; printf(&quot;%05d / %05d = %d\\n&quot;, a[n][i], b[n][i], n); &#125; &#125; &#125; return 0;&#125; 更新日志 2014年11月2日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1011 数的计算","slug":"CodeVS-1011","date":"2014-11-01T10:39:19.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/01/CodeVS-1011/","link":"","permalink":"https://xuanwo.org/2014/11/01/CodeVS-1011/","excerpt":"题目源地址： http://codevs.cn/problem/1011/ 理解题目的分类是递推，自然就往递推那个方向去想。通过简单的推理可以发现，f[n]的值恰好等于f[1]~f[n/2]的和，之后的代码就比较简单了。","text":"题目源地址： http://codevs.cn/problem/1011/ 理解题目的分类是递推，自然就往递推那个方向去想。通过简单的推理可以发现，f[n]的值恰好等于f[1]~f[n/2]的和，之后的代码就比较简单了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1001long long n,i,j,f[MAXN];int main(int argc, char const *argv[])&#123; cin&gt;&gt;n; f[1]=1; for(i=2; i&lt;=n; i++) &#123; f[i]=1; for(j=1; j&lt;=i/2; j++) f[i]+=f[j]; &#125; cout&lt;&lt;f[n]&lt;&lt;endl; return 0;&#125; 更新日志 2014年11月1日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1012 最大公约数和最小公倍数问题","slug":"CodeVS-1012","date":"2014-11-01T10:17:25.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/11/01/CodeVS-1012/","link":"","permalink":"https://xuanwo.org/2014/11/01/CodeVS-1012/","excerpt":"题目源地址： http://codevs.cn/problem/1012/ 理解自然是水题= =。只要用一个循环就可以搞定，最大公约数用gcd，最小公倍数就是ij/gcd(i,j)，没有什么问题。不过这个题意不是很清晰，是否为同一组数字的判断并没有讲到。实际上，3 60和60 3是两组数组。这个理解上的问题，导致我的结果一直都是标准答案的一半，折腾了一会儿。除此之外，这个简单的思路还有很多可以优化的地方，比如在判断了gcd是否等于x之后，后面判断最小公倍数只要使用ij/x就可以了；还有，一开始令i=x之后，后面每一次都递增x就可以保证i与j始终为x的约束，但注意，还是要用gcd来判断最大公约数是不是x；过题之后找了一下题解，发现有人提出，循环的最大值是sqrt(y)，稍微想了想，确实如此，这个优化也能省下很多循环。","text":"题目源地址： http://codevs.cn/problem/1012/ 理解自然是水题= =。只要用一个循环就可以搞定，最大公约数用gcd，最小公倍数就是ij/gcd(i,j)，没有什么问题。不过这个题意不是很清晰，是否为同一组数字的判断并没有讲到。实际上，3 60和60 3是两组数组。这个理解上的问题，导致我的结果一直都是标准答案的一半，折腾了一会儿。除此之外，这个简单的思路还有很多可以优化的地方，比如在判断了gcd是否等于x之后，后面判断最小公倍数只要使用ij/x就可以了；还有，一开始令i=x之后，后面每一次都递增x就可以保证i与j始终为x的约束，但注意，还是要用gcd来判断最大公约数是不是x；过题之后找了一下题解，发现有人提出，循环的最大值是sqrt(y)，稍微想了想，确实如此，这个优化也能省下很多循环。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int x,y;int ans=0,flag=0;int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%d%d&quot;, &amp;x,&amp;y)) &#123; if(x&gt;y) swap(x,y); ans=0; for(int i=x; i&lt;=y; i+=x) &#123; for(int j=i; j&lt;=y; j+=x) &#123; if(i*j/x==y&amp;&amp;gcd(i,j)==x) &#123; ans++; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans&lt;&lt;1); &#125; return 0;&#125; 更新日志 2014年11月1日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 445 Marvelous Mazes","slug":"UVa-445-Marvelous-Mazes","date":"2014-11-01T09:47:48.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/01/UVa-445-Marvelous-Mazes/","link":"","permalink":"https://xuanwo.org/2014/11/01/UVa-445-Marvelous-Mazes/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=94&amp;page=show_problem&amp;problem=386 理解我又逗了= =。题意很简单，给你指定规则的字符串，要求你转换成一个图。我写了一个特别复杂的实现，结果总是得不到想要的结果。后来才意识到switch语句妙用，顿感自己太不机智了。实际上，只要对每一个字符进行判断就可以了，如果是数字就叠加起来得到c，如果是b就输出前面算出的c个空格，如果是！就输出回车，如果是字母就输出前面算出来的c个字母。根本就不需要进行复杂的正数处理操作，涨姿势了。除此之外，还有没有必要等到全部输入完了之后再进行处理。因为本地编译的时候看起来输入和输出混在了一起，实际上，输入来自于stdin，输出来自于stdout，是不会出现混淆的。所以可以放心大胆地进行单行处理，这样就省掉一个超大的二维数组。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=94&amp;page=show_problem&amp;problem=386 理解我又逗了= =。题意很简单，给你指定规则的字符串，要求你转换成一个图。我写了一个特别复杂的实现，结果总是得不到想要的结果。后来才意识到switch语句妙用，顿感自己太不机智了。实际上，只要对每一个字符进行判断就可以了，如果是数字就叠加起来得到c，如果是b就输出前面算出的c个空格，如果是！就输出回车，如果是字母就输出前面算出来的c个字母。根本就不需要进行复杂的正数处理操作，涨姿势了。除此之外，还有没有必要等到全部输入完了之后再进行处理。因为本地编译的时候看起来输入和输出混在了一起，实际上，输入来自于stdin，输出来自于stdout，是不会出现混淆的。所以可以放心大胆地进行单行处理，这样就省掉一个超大的二维数组。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;char s[100010];int main(int argc, char const *argv[])&#123; while(gets(s)) &#123; int c=0; for(int i=0; s[i]!=&apos;\\0&apos;; i++) &#123; switch(s[i]) &#123; case &apos;b&apos;: &#123; for(int j=0; j&lt;c; j++) printf(&quot; &quot;); c=0; break; &#125; case &apos;1&apos;: c=c+1; break; case &apos;2&apos;: c=c+2; break; case &apos;3&apos;: c=c+3; break; case &apos;4&apos;: c=c+4; break; case &apos;5&apos;: c=c+5; break; case &apos;6&apos;: c=c+6; break; case &apos;7&apos;: c=c+7; break; case &apos;8&apos;: c=c+8; break; case &apos;9&apos;: c=c+9; break; case &apos;!&apos;: printf(&quot;\\n&quot;); default: &#123; for(int j=0; j&lt;c; j++) printf(&quot;%c&quot;,s[i]); c=0; break; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月1日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 490 Rotating Sentences","slug":"UVa-490-Rotating-Sentences","date":"2014-11-01T09:21:56.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/11/01/UVa-490-Rotating-Sentences/","link":"","permalink":"https://xuanwo.org/2014/11/01/UVa-490-Rotating-Sentences/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=94&amp;page=show_problem&amp;problem=431 理解题意很好理解，就是将字符串旋转九十度。一开始脑洞开的比较大，想要搞两个字符串数组，然后两个for遍历。后来仔细想想根本就不需要，只要在输出的时候，处理一下顺序就可以了。然后被卡在了输入输出上面，之前没有做过这种类型的题目，不知道单组的输入怎么结束。后来听学长解释才明白，就算是单组，也可以用EOF来结束的，之后的问题就比较简单了。但是提交之后，挂了一发PE。仔细检查之后，认为问题出在题目中输入的那个换行，除此之外，还有自己先前调用的一个计数变量i的值比应有的值多了1。Debug之后，幸福的A了","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=94&amp;page=show_problem&amp;problem=431 理解题意很好理解，就是将字符串旋转九十度。一开始脑洞开的比较大，想要搞两个字符串数组，然后两个for遍历。后来仔细想想根本就不需要，只要在输出的时候，处理一下顺序就可以了。然后被卡在了输入输出上面，之前没有做过这种类型的题目，不知道单组的输入怎么结束。后来听学长解释才明白，就算是单组，也可以用EOF来结束的，之后的问题就比较简单了。但是提交之后，挂了一发PE。仔细检查之后，认为问题出在题目中输入的那个换行，除此之外，还有自己先前调用的一个计数变量i的值比应有的值多了1。Debug之后，幸福的A了 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1&lt;&lt;10char a[MAXN][MAXN];int i=0;int Max=0,tmp=0;;int main(int argc, char const *argv[])&#123; memset(a,0,sizeof(a)); while(gets(a[i++])) &#123; tmp=strlen(a[i-1]); if(Max&lt;tmp) Max=tmp; &#125; for(int j=0; j&lt;Max; j++) &#123; for(int k=i-1; k&gt;=0; k--) &#123; if(!a[k][j]) a[k][j]=&apos; &apos;; &#125; &#125; for(int j=0; j&lt;Max; j++) &#123; for(int k=i-2; k&gt;=0; k--) &#123; printf(&quot;%c&quot;, a[k][j]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年11月1日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 414 Machined Surfaces","slug":"UVa-414-Machined-Surfaces","date":"2014-10-31T17:13:19.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/31/UVa-414-Machined-Surfaces/","link":"","permalink":"https://xuanwo.org/2014/10/31/UVa-414-Machined-Surfaces/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=355 理解题意还是比较好理解的，实际上就是求将两端合并，中间还会剩余多少个空格。只要找到X最多的那一行，问题就变得简单了。不过还是逗了一发，因为忘记把freopen注释掉= =，蛋疼。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=355 理解题意还是比较好理解的，实际上就是求将两端合并，中间还会剩余多少个空格。只要找到X最多的那一行，问题就变得简单了。不过还是逗了一发，因为忘记把freopen注释掉= =，蛋疼。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int N;int a[20],Max = 0;char line[30];int ans;int main()&#123; //freopen (&quot;414.in&quot;,&quot;r&quot;,stdin); while(scanf(&quot;%d&quot;,&amp;N),N) &#123; ans=0,Max=0; memset(a,0,sizeof(a)); memset(line,0,sizeof(line)); getchar(); for (int i=0; i&lt;N; i++) &#123; gets(line); for (int j=0; line[j]; j++) if (line[j]==&apos;X&apos;) a[i]++; if (a[i]&gt;Max) Max = a[i]; &#125; for (int i=0; i&lt;N; i++) ans += (Max-a[i]); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 更新日志 2014年10月31日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1501 二叉树最大宽度和高度","slug":"CodeVS-1501","date":"2014-10-31T16:45:17.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/31/CodeVS-1501/","link":"","permalink":"https://xuanwo.org/2014/10/31/CodeVS-1501/","excerpt":"题目源地址： http://codevs.cn/problem/1501/ 理解数据结构的基础题，不过我把它做成了一道模拟题= =。","text":"题目源地址： http://codevs.cn/problem/1501/ 理解数据结构的基础题，不过我把它做成了一道模拟题= =。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int a[1000][2],s[1000];int i,n,x,y;void dfs(int i,int k)&#123; s[k]=s[k]+1; if(k&gt;x) x=k; if(a[i][1]!=0) dfs(a[i][1],k+1); if(a[i][2]!=0) dfs(a[i][2],k+1);&#125;int main(void)&#123; scanf(&quot;%d&quot;,&amp;n); memset(a,0,sizeof(a)); memset(s,0,sizeof(s)); for(i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i][1],&amp;a[i][2]); x=0; dfs(1,1); y=0; for(i=1;i&lt;1000;i++) if(s[i]&gt;y) y=s[i]; printf(&quot;%d %d&quot;,y,x); return 0;&#125; 更新日志 2014年10月31日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 494 Kindergarten Counting Game","slug":"UVa-494-Kindergarten-Counting-Game","date":"2014-10-31T16:20:15.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/31/UVa-494-Kindergarten-Counting-Game/","link":"","permalink":"https://xuanwo.org/2014/10/31/UVa-494-Kindergarten-Counting-Game/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=435 理解同样是一道很简单的题目。只要求出给定的一句话中出现的单词的个数，有两个地方需要注意。 输入应当注意不能使用scanf(&quot;%s&quot;, str)这样的写法，会直接停在有空格的地方。采用getline是一个好主意，不过输入的效率会比较低，要是比较虚的话，可以用速度快一点的gets。 具体的单词判断上，我一开始犯了一个错误，认为只要判断空格的个数就OK了，实际上，a_a是两个单词。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=435 理解同样是一道很简单的题目。只要求出给定的一句话中出现的单词的个数，有两个地方需要注意。 输入应当注意不能使用scanf(&quot;%s&quot;, str)这样的写法，会直接停在有空格的地方。采用getline是一个好主意，不过输入的效率会比较低，要是比较虚的话，可以用速度快一点的gets。 具体的单词判断上，我一开始犯了一个错误，认为只要判断空格的个数就OK了，实际上，a_a是两个单词。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1&lt;&lt;10string a;int ans=0,is=0;int main(int argc, char const *argv[])&#123; while(getline(cin, a)) &#123; ans=0;is=0; for(int i=0;i&lt;=a.length();i++) &#123; if((a[i]&gt;=&apos;A&apos;&amp;&amp;a[i]&lt;=&apos;Z&apos;)||(a[i]&gt;=&apos;a&apos;&amp;&amp;a[i]&lt;=&apos;z&apos;)) &#123; is=1; &#125; else &#123; ans+=is; is=0; &#125; &#125; printf(&quot;%d\\n&quot;, ans+is); &#125; return 0;&#125; 更新日志 2014年10月31日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 458 The Decoder","slug":"UVa-458-The-Decoder","date":"2014-10-30T15:16:38.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/30/UVa-458-The-Decoder/","link":"","permalink":"https://xuanwo.org/2014/10/30/UVa-458-The-Decoder/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=399 理解看起来有点吓人，实际上是一道很水的题目。直接在编译器里面计算了一下’1’-‘*’的值，为7。只要字符串里面的每一个字符都减去7，就能得到想要的结果。采用了一个姿势不是很优越的遍历，不知道还有没有更好的优化空间。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=399 理解看起来有点吓人，实际上是一道很水的题目。直接在编译器里面计算了一下’1’-‘*’的值，为7。只要字符串里面的每一个字符都减去7，就能得到想要的结果。采用了一个姿势不是很优越的遍历，不知道还有没有更好的优化空间。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1&lt;&lt;10char a[MAXN],b[MAXN];int main(int argc, char const *argv[])&#123; while(~scanf(&quot;%s&quot;,a)) &#123; memset(b,0,sizeof(b)); for(int i=0;i&lt;strlen(a);i++) &#123; b[i]=a[i]-7; &#125; printf(&quot;%s\\n&quot;, b); &#125; return 0;&#125; 更新日志 2014年10月30日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10300 Ecological Premium","slug":"UVa-10300-Ecological-Premium","date":"2014-10-30T15:00:57.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/30/UVa-10300-Ecological-Premium/","link":"","permalink":"https://xuanwo.org/2014/10/30/UVa-10300-Ecological-Premium/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1241 理解这个是英文阅读理解题= =。看起来很绕很绕的样子，要求每个动物占据的面积然后乘上什么环境友好度，再乘上动物的个数。实际上，就是求面积乘上环境友好度的和。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1241 理解这个是英文阅读理解题= =。看起来很绕很绕的样子，要求每个动物占据的面积然后乘上什么环境友好度，再乘上动物的个数。实际上，就是求面积乘上环境友好度的和。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 20+10int t,f,farm[MAXN],animals[MAXN],value[MAXN];int ans;void init()&#123; memset(farm,0,sizeof(farm)); memset(animals,0,sizeof(animals)); memset(value,0,sizeof(value)); ans=0; scanf(&quot;%d&quot;, &amp;f); for(int i=0;i&lt;f;i++) &#123; scanf(&quot;%d%d%d&quot;, &amp;farm[i], &amp;animals[i], &amp;value[i]); &#125;&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; init(); for(int i=0;i&lt;f;i++) &#123; ans+=farm[i]*value[i]; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年10月30日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1160 蛇形矩阵","slug":"CodeVS-1160","date":"2014-10-29T22:01:17.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/29/CodeVS-1160/","link":"","permalink":"https://xuanwo.org/2014/10/29/CodeVS-1160/","excerpt":"题目源地址： http://codevs.cn/problem/1160/ 理解一道模拟的，一直在纠结这个规律怎么推。一开始的想法是，从最中间开始，由1向n*n不断循环，后来发现这个循环有点难写。折腾了很久还是没有写出来，后来通过观察发现，这个矩阵的右下对角线正好满足一个公差为2的等差数列的平方。根据这个分别来完成递加和递减的过程。","text":"题目源地址： http://codevs.cn/problem/1160/ 理解一道模拟的，一直在纠结这个规律怎么推。一开始的想法是，从最中间开始，由1向n*n不断循环，后来发现这个循环有点难写。折腾了很久还是没有写出来，后来通过观察发现，这个矩阵的右下对角线正好满足一个公差为2的等差数列的平方。根据这个分别来完成递加和递减的过程。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 1000int n,u[MAXN][MAXN],x,y,i,j,t,s=0;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;,&amp;n); for(i=n/2+1,t=1; i&lt;=n; ++i,t+=2) &#123; u[i][i]=t*t; x=y=i; while(y&gt;i-t+1) --y,u[x][y]=u[x][y+1]-1; while(x&gt;i-t+1) --x,u[x][y]=u[x+1][y]-1; while(y&lt;i) ++y,u[x][y]=u[x][y-1]-1; while(x&lt;i-1) ++x,u[x][y]=u[x-1][y]-1; &#125; for(i=1; i&lt;=n; ++i) &#123; for(j=1; j&lt;=n; ++j) &#123; printf(&quot;%d &quot;,u[i][j]); s+=((i==j||i+j==n+1)?u[i][j]:0); &#125; printf(&quot;\\n&quot;); &#125; printf(&quot;%d&quot;,s); return 0;&#125; 更新日志 2014年10月29日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1083 Cantor表","slug":"CodeVS-1083","date":"2014-10-29T21:05:44.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/29/CodeVS-1083/","link":"","permalink":"https://xuanwo.org/2014/10/29/CodeVS-1083/","excerpt":"题目源地址： http://codevs.cn/problem/1083/ 理解一道基础题，但是我在如何建立模型上面想了很久。事实上，我们可以按照斜线分类，第1条斜线有1个数，第2条有2个数，以此类推，第i条有i个数。这样，我们可以很轻松的知道，前i条共有S(i)=1/2i(i+1)个数。由方程n&lt;=S(k)，我们可以求出n所在的斜线的位置，也就是floor(sqrt(8.0*n+1)-1)/2。本来在小白书上面，这个问题已经被解决了，但是CodeVS上面的这道题采用了不同的排列规则。通过观察可以发现，这个规则和斜线数k的奇偶性有关。只要进行一次简单的判断就可以让结果按照需要的规则进行排列了。","text":"题目源地址： http://codevs.cn/problem/1083/ 理解一道基础题，但是我在如何建立模型上面想了很久。事实上，我们可以按照斜线分类，第1条斜线有1个数，第2条有2个数，以此类推，第i条有i个数。这样，我们可以很轻松的知道，前i条共有S(i)=1/2i(i+1)个数。由方程n&lt;=S(k)，我们可以求出n所在的斜线的位置，也就是floor(sqrt(8.0*n+1)-1)/2。本来在小白书上面，这个问题已经被解决了，但是CodeVS上面的这道题采用了不同的排列规则。通过观察可以发现，这个规则和斜线数k的奇偶性有关。只要进行一次简单的判断就可以让结果按照需要的规则进行排列了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int main(int argc, char const *argv[])&#123; int n; while(~scanf(&quot;%d&quot;, &amp;n)) &#123; int k=(int)floor((sqrt(8.0*n+1)-1)/2-(1e-9))+1; int s=k*(k+1)/2; if(k%2==0) printf(&quot;%d/%d\\n&quot;, k-s+n,s-n+1); else printf(&quot;%d/%d\\n&quot;, s-n+1,k-s+n); &#125; return 0;&#125; 更新日志 2014年10月29日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10071 Back to High School Physics","slug":"UVa-10071-Back-to-High-School-Physics","date":"2014-10-29T20:09:12.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/29/UVa-10071-Back-to-High-School-Physics/","link":"","permalink":"https://xuanwo.org/2014/10/29/UVa-10071-Back-to-High-School-Physics/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1012 理解很简单的一道水题，通过简单的计算就能得出最后的结果是2vt。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1012 理解很简单的一道水题，通过简单的计算就能得出最后的结果是2vt。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int main(int argc, char const *argv[])&#123; ll t,v; while(~scanf(&quot;%lld%lld&quot;, &amp;v,&amp;t )) &#123; printf(&quot;%lld\\n&quot;, 2*v*t); &#125; return 0;&#125; 更新日志 2014年10月29日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10055  Hashmat the Brave Warrior","slug":"UVa-10055-Hashmat-the-Brave-Warrior","date":"2014-10-29T13:24:02.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/29/UVa-10055-Hashmat-the-Brave-Warrior/","link":"","permalink":"https://xuanwo.org/2014/10/29/UVa-10055-Hashmat-the-Brave-Warrior/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=996 理解AOAPC上的基础题，一个非常简单的求两个数之间的差，注意数据的范围，应当采用%lld。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=996 理解AOAPC上的基础题，一个非常简单的求两个数之间的差，注意数据的范围，应当采用%lld。 代码#include &lt;stdio.h&gt;using namespace std;int main()&#123; long long int a,b; while(scanf(&quot;%lld%lld&quot;, &amp;a,&amp;b)==2) &#123; printf(&quot;%lld\\n&quot;, a&gt;b?a-b:b-a); &#125; return 0;&#125; 更新日志 2014年10月29日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 12325 Zombie's Treasure Chest","slug":"UVa-12325-Zombie's-Treasure-Chest","date":"2014-10-27T16:49:40.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/27/UVa-12325-Zombie's-Treasure-Chest/","link":"","permalink":"https://xuanwo.org/2014/10/27/UVa-12325-Zombie's-Treasure-Chest/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3747 理解本以为是一件非常简单的贪心，但是狂WA6发，完全不明白到底发生了什么。一开始觉得是一个背包问题，只要直接计算性价比（价值/体积），然后优先选择性价比高的物品就可以了。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3747 理解本以为是一件非常简单的贪心，但是狂WA6发，完全不明白到底发生了什么。一开始觉得是一个背包问题，只要直接计算性价比（价值/体积），然后优先选择性价比高的物品就可以了。 代码 更新日志 2014年10月27日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 10976 Fractions Again?!","slug":"UVa-10976-Fractions-Again","date":"2014-10-27T16:13:36.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/27/UVa-10976-Fractions-Again/","link":"","permalink":"https://xuanwo.org/2014/10/27/UVa-10976-Fractions-Again/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1917 理解直接暴力做，最多有n-1种可能，每种可能全都尝试一遍，看看能不能找到合适的解，定eps为1e-4，幸运1A。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1917 理解直接暴力做，最多有n-1种可能，每种可能全都尝试一遍，看看能不能找到合适的解，定eps为1e-4，幸运1A。 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;#include &lt;math.h&gt;using namespace std;#define LL long long int#define MAXN 10000+10LL xbuf[MAXN];LL ybuf[MAXN];int main()&#123; LL k; while(~scanf(&quot;%lld&quot;,&amp;k)) &#123; LL y = 1; LL cnt = 0; memset(xbuf, 0, sizeof(xbuf)); memset(ybuf, 0, sizeof(ybuf)); for(y=1; y&lt;=2*k; y++) &#123; double x = 1.0 / (1.0/k - 1.0/y); LL xInt = (LL)(x+0.5); if(x&gt;0 &amp;&amp; fabs(x-xInt)&lt;1e-4) &#123; xbuf[cnt] = xInt; ybuf[cnt] = y; cnt++; &#125; &#125; printf(&quot;%lld\\n&quot;, cnt); for(int i=0; i&lt;cnt; i++) &#123; printf(&quot;1/%lld = 1/%lld + 1/%lld\\n&quot;, k, xbuf[i], ybuf[i]); &#125; &#125;&#125; 更新日志 2014年10月27日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"UVa 11059 Maximum Product","slug":"UVa-11059-Maximum-Product","date":"2014-10-27T14:05:31.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/27/UVa-11059-Maximum-Product/","link":"","permalink":"https://xuanwo.org/2014/10/27/UVa-11059-Maximum-Product/","excerpt":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=22&amp;page=show_problem&amp;problem=2000 理解这道题卡了两个半小时，各种神体位卡数据。最开始题意理解错误，认为是要求出最大的乘积，实际上应该是求最大的连续积。然后在for循环的开始和结束全都卡了很多次，卡long long，卡输出，卡边界条件，直到队友看不下去了来帮我看代码，才终于解脱= =。天若了，真的太弱了- -，遇到这种坑特别多的题目，发挥就各种失常，这样可不行。","text":"题目源地址： http://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=22&amp;page=show_problem&amp;problem=2000 理解这道题卡了两个半小时，各种神体位卡数据。最开始题意理解错误，认为是要求出最大的乘积，实际上应该是求最大的连续积。然后在for循环的开始和结束全都卡了很多次，卡long long，卡输出，卡边界条件，直到队友看不下去了来帮我看代码，才终于解脱= =。天若了，真的太弱了- -，遇到这种坑特别多的题目，发挥就各种失常，这样可不行。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----\\n&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAXN 18+10int n,flag=0;int a[MAXN];long long int ans;long long int tmp;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; ans=a[0]; for(int i=0;i&lt;n;i++) &#123; for(int j=n-1;j&gt;=i;j--) &#123; tmp=1; for(int x=i;x&lt;=j;x++) &#123; tmp*=a[x]; &#125; if(ans&lt;tmp) ans=tmp; &#125; &#125; if(ans&lt;0) ans=0; printf(&quot;Case #%d: The maximum product is %lld.\\n\\n&quot;, ++flag, ans); &#125;&#125;/*32 4 -352 5 -1 2 -1**/ 更新日志 2014年10月27日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"大学生网站集合","slug":"WebsitesForStudents","date":"2014-10-25T13:46:37.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/25/WebsitesForStudents/","link":"","permalink":"https://xuanwo.org/2014/10/25/WebsitesForStudents/","excerpt":"前言即使是在搜索引擎如此发达的今天，依然有很多偏僻但是特别有用的网站被无数SEO们死死地压在身下。比如，直到现场赛的前几天，才从学长们的口中知道了在线数列大全（OEIS）这样神一般的网站。我就不禁想，像这样的网站是不是并不在少数？我们是不是可以把自己积累的一些好网站共享出来，让大家都能在搜寻某方面的信息可以对症下药，而不是用几个关键词翻来覆去地在Google上面盲目的搜寻？于是，这个大学生网站集合项目就诞生了。","text":"前言即使是在搜索引擎如此发达的今天，依然有很多偏僻但是特别有用的网站被无数SEO们死死地压在身下。比如，直到现场赛的前几天，才从学长们的口中知道了在线数列大全（OEIS）这样神一般的网站。我就不禁想，像这样的网站是不是并不在少数？我们是不是可以把自己积累的一些好网站共享出来，让大家都能在搜寻某方面的信息可以对症下药，而不是用几个关键词翻来覆去地在Google上面盲目的搜寻？于是，这个大学生网站集合项目就诞生了。 简介本库旨在建设一个对大学生有益有用的网站集合，欢迎参与编辑。 标准有益：大学生就业指导，技能学习。有用：常用的一些在线工具或者技巧。 说明非商业，不推广，纯收录，不排名。来源网站不能违反相关的法律法规，广告尽可能少，访问速度最好要快。原则上按专业学科进行分类，难以分类的进入通用类。类别较多，请多多使用Ctrl+F。不限制网站语言，推荐中文或英文为主。 交流欢迎大家将珍藏已久的好网站共享出来，您可以： 使用 Issues 以及 Pull Request贡献者名单: https://github.com/Xuanwo/WebsitesForStudents/graphs/contributors 更新日志 2014年10月25日 新增文章。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"}]},{"title":"Codeforces Beta Round 2 A Winner","slug":"CF-2A","date":"2014-10-22T15:06:04.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/22/CF-2A/","link":"","permalink":"https://xuanwo.org/2014/10/22/CF-2A/","excerpt":"题目源地址： http://codeforces.com/contest/2/problem/A 理解真尼玛给俄式英语跪了= =，游戏规则中最关键的地方各种看不懂。 If score is negative, this means that the player has lost in the round.` 这句话一直看不懂，是不是只要为负就能直接出局？还是就算暂时是负的也是没有关系的，只要最后大于最后的M就可以？直到看到CF的多组样例之后才明白，应该是后面一种。除了这个之外，好好地学习了一下STL中的map，vector和迭代器，感觉好厉害！涨姿势了。","text":"题目源地址： http://codeforces.com/contest/2/problem/A 理解真尼玛给俄式英语跪了= =，游戏规则中最关键的地方各种看不懂。 If score is negative, this means that the player has lost in the round.` 这句话一直看不懂，是不是只要为负就能直接出局？还是就算暂时是负的也是没有关系的，只要最后大于最后的M就可以？直到看到CF的多组样例之后才明白，应该是后面一种。除了这个之外，好好地学习了一下STL中的map，vector和迭代器，感觉好厉害！涨姿势了。 新技能getMap初始化： map&lt;string,int&gt; myMap; Vector初始化: vector&lt;int&gt; myVector;赋值: myVector.push_back(); 迭代器初始化： map&lt;string,int&gt;::iterator myIterator; 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int main()&#123; int n, m; vector&lt;string&gt; info_s; vector&lt;int&gt; info_p; map&lt;string, int&gt; pt, round; scanf(&quot;%d&quot;, &amp;n); for(int i=0; i&lt;n; ++i) &#123; char s[40]; int p; scanf(&quot;%s%d&quot;, s, &amp;p); info_s.push_back(s); info_p.push_back(p); pt[s] += p; &#125; m = -1; for(map&lt;string, int&gt;::iterator it=pt.begin(); it!=pt.end(); ++it) m = max(m, it-&gt;second); pt.clear(); for(int i=0; i&lt;n; ++i) &#123; pt[info_s[i]] += info_p[i]; if(pt[info_s[i]] &gt;= m &amp;&amp; round.find(info_s[i]) == round.end()) round[info_s[i]] = i; &#125; string sol; int k = n; for(map&lt;string, int&gt;::iterator it=round.begin(); it!=round.end(); ++it) if(pt[it-&gt;first]==m &amp;&amp; k&gt;it-&gt;second) k=it-&gt;second, sol=it-&gt;first; puts(sol.c_str()); return 0;&#125; 更新日志 2014年10月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 1 C Ancient Berland Circus","slug":"CF-1C","date":"2014-10-21T17:23:43.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/21/CF-1C/","link":"","permalink":"https://xuanwo.org/2014/10/21/CF-1C/","excerpt":"题目源地址： http://codeforces.com/contest/1/problem/C 理解题意很简单，就是给出一个正N边形的三个点，要求求出这个正N边形的最小面积。然后就是我不停地逗的过程了= =，因为手滑，在计算3个角的时候，全都采用了反cos函数的方法求解，debug的时候一直以为是double精度的问题，直到看到这样下图，我才恍然大悟= =，可怜我的两个小时。","text":"题目源地址： http://codeforces.com/contest/1/problem/C 理解题意很简单，就是给出一个正N边形的三个点，要求求出这个正N边形的最小面积。然后就是我不停地逗的过程了= =，因为手滑，在计算3个角的时候，全都采用了反cos函数的方法求解，debug的时候一直以为是double精度的问题，直到看到这样下图，我才恍然大悟= =，可怜我的两个小时。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-4)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;double a,b,c,r,q,s;double A,B,C,angel,ans,n;struct node&#123; double x,y;&#125; piller[3];double dis(node a, node b)&#123; return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;double fgcd(double a, double b)&#123; if(fabs(b-0)&lt;=eps) return a; if(fabs(a-0)&lt;=eps) return b; return fgcd(b,fmod(a,b));&#125;void init()&#123; memset(piller,0,sizeof(piller)); for(int i=0; i&lt;3; i++) &#123; scanf(&quot;%lf%lf&quot;, &amp;piller[i].x,&amp;piller[i].y); &#125; a=dis(piller[0],piller[1]); b=dis(piller[1],piller[2]); c=dis(piller[0],piller[2]); q=(a+b+c)/2; s=sqrt(q*(q-a)*(q-b)*(q-c)); r=a*b*c/(4*s); A=acos(1-a*a/r/r/2); B=acos(1-b*b/r/r/2); C=2*pi-A-B;&#125;int main(int argc, char const *argv[])&#123; init(); ans=pi/fgcd(A,fgcd(B,C))*r*r*sin(fgcd(A,fgcd(B,C))); printf(&quot;%.8lf\\n&quot;,ans); return 0;&#125; 更新日志 2014年10月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 1 B Spreadsheets","slug":"CF-1B","date":"2014-10-21T14:35:33.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/21/CF-1B/","link":"","permalink":"https://xuanwo.org/2014/10/21/CF-1B/","excerpt":"题目源地址： http://codeforces.com/contest/1/problem/B 理解大水题一道，不过我坑了很久，实在是代码功底太弱。题意非常简单，给出两种表格的坐标体系，要你进行相互转化，本质上是一道26进制转化类的题目。我遇到的坑基本上分为两类，一个是在判断当前输入的字符串属于何种类型，第二是在具体实现过程中的BUG。首先，讲一讲判断的过程。我另外写了一个判断的函数，一开始想的比较简单，只要判断第二个是不是字符，就OK。挂在了Test 2，错误样例是A1。然后就在思考，这两种坐标体系的根本不同到底在哪里。实际上，RXCY体系中一定有字符R和C，R和C之间必定会有一个数字。从这一点出发，重写了一遍judge函数，总算是搞定了问题。其次，来看一下在具体的实现过程中的BUG。这一次挂在了Test 6，一个总共有1000个的输入= =，错误的样例是R228C494和R98C688。观察之后发现，问题出在进退位上，因为在A—Z的体系中，实际上是没有代表’0’这个字符的，所以，当R或者C坐标上出现整除的时候，就会发现本应出现’Z’的地方，出现了字符’@’。不过在挂了这么多发之后，偷懒直接进行了特判，当’Z’出现字符串末尾，也就是c%26==0时，直接指定它为’Z’；当Z出现在字符串最前方时，直接在输出中过滤。然后= =，A了。","text":"题目源地址： http://codeforces.com/contest/1/problem/B 理解大水题一道，不过我坑了很久，实在是代码功底太弱。题意非常简单，给出两种表格的坐标体系，要你进行相互转化，本质上是一道26进制转化类的题目。我遇到的坑基本上分为两类，一个是在判断当前输入的字符串属于何种类型，第二是在具体实现过程中的BUG。首先，讲一讲判断的过程。我另外写了一个判断的函数，一开始想的比较简单，只要判断第二个是不是字符，就OK。挂在了Test 2，错误样例是A1。然后就在思考，这两种坐标体系的根本不同到底在哪里。实际上，RXCY体系中一定有字符R和C，R和C之间必定会有一个数字。从这一点出发，重写了一遍judge函数，总算是搞定了问题。其次，来看一下在具体的实现过程中的BUG。这一次挂在了Test 6，一个总共有1000个的输入= =，错误的样例是R228C494和R98C688。观察之后发现，问题出在进退位上，因为在A—Z的体系中，实际上是没有代表’0’这个字符的，所以，当R或者C坐标上出现整除的时候，就会发现本应出现’Z’的地方，出现了字符’@’。不过在挂了这么多发之后，偷懒直接进行了特判，当’Z’出现字符串末尾，也就是c%26==0时，直接指定它为’Z’；当Z出现在字符串最前方时，直接在输出中过滤。然后= =，A了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug &quot;output for debug\\n&quot;#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 40000int t;char str[MAXN],ans[MAXN];bool judge(char str[])&#123; string tmp=str; if(tmp.find(&apos;C&apos;)&gt;=tmp.size()||tmp.find(&apos;R&apos;)&gt;=tmp.size()||tmp.find(&apos;C&apos;)&lt;tmp.find(&apos;R&apos;)) return true; else &#123; for(int i=tmp.find(&apos;R&apos;); i&lt;=tmp.find(&apos;C&apos;); i++) &#123; if(str[i]&lt;=&apos;9&apos;) return false; &#125; return true; &#125; return false;&#125;void exceltorxcy(char str[])&#123; int r=0,c=0; int len=strlen(str); for(int i=0; i&lt;len; i++) &#123; if(str[i]&gt;=&apos;A&apos;&amp;&amp;str[i]&lt;=&apos;Z&apos;) &#123; c=c*26+str[i]-&apos;A&apos;+1; &#125; else &#123; r=r*10+str[i]-&apos;0&apos;; &#125; &#125; printf(&quot;R%dC%d\\n&quot;, r,c);&#125;void rxcytoexcel(char str[])&#123; int i,j,c=0,r=0; int len=strlen(str); for(i=0; i&lt;len; i++) &#123; if(str[i]==&apos;C&apos;) break; if(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;) &#123; r=r*10+str[i]-&apos;0&apos;; &#125; &#125; for(j=i; j&lt;len; j++) &#123; if(str[j]&gt;=&apos;0&apos;&amp;&amp;str[j]&lt;=&apos;9&apos;) &#123; c=c*10+str[j]-&apos;0&apos;; &#125; &#125; i=0; while(c/26!=0) &#123; if(c%26==0) &#123; ans[i]=&apos;Z&apos;; c-=1; &#125; else &#123; ans[i]=c%26+&apos;A&apos;-1; &#125; c/=26; i++; &#125; ans[i]=c%26+&apos;A&apos;-1; for(; i&gt;=0; i--) &#123; if(ans[i]!=&apos;@&apos;) printf(&quot;%c&quot;, ans[i]); &#125; printf(&quot;%d\\n&quot;, r);&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%d&quot;, &amp;t); while(t--) &#123; memset(ans,0,sizeof(ans)); scanf(&quot;%s&quot;, str); if(judge(str)) exceltorxcy(str); else rxcytoexcel(str); &#125; return 0;&#125;/*R228C494RZ228R98C688**/ 更新日志 2014年10月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1842 递归第一次","slug":"CodeVS-1842","date":"2014-10-20T21:40:51.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/20/CodeVS-1842/","link":"","permalink":"https://xuanwo.org/2014/10/20/CodeVS-1842/","excerpt":"题目源地址： http://codevs.cn/problem/1842/ 理解还是一道水题，不过卡了RE。研究之后发现，问题出在我的记忆化搜索上面，我的记忆化数组的下标出现了负值，所以出现了RE。后来想了想，通过加上一个最小负数的绝对值，使得出现的每一个x都是非负数，然后解决了这个问题。","text":"题目源地址： http://codevs.cn/problem/1842/ 理解还是一道水题，不过卡了RE。研究之后发现，问题出在我的记忆化搜索上面，我的记忆化数组的下标出现了负值，所以出现了RE。后来想了想，通过加上一个最小负数的绝对值，使得出现的每一个x都是非负数，然后解决了这个问题。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 10000int x;int n[MAXN];int f(int x)&#123; if(n[x+30]!=0) return n[x+30]; if(x&gt;=0) return n[x+30]=5; else &#123; return n[x+30]=f(x+1)+f(x+2)+1; &#125;&#125;int main(int argc, char const *argv[])&#123; memset(n,0,sizeof(n)); scanf(&quot;%d&quot;, &amp;x); printf(&quot;%d\\n&quot;, f(x)); return 0;&#125; 更新日志 2014年10月20日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1475 m进制转十进制","slug":"CodeVS-1475","date":"2014-10-20T20:55:41.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/20/CodeVS-1475/","link":"","permalink":"https://xuanwo.org/2014/10/20/CodeVS-1475/","excerpt":"题目源地址： http://codevs.cn/problem/1475/ 理解跟上一道题差不多- -，也是简单的写了一个循环，然后使用累积法计算十进制的值。不过有一个小小的坑，就是’A’字符的ANSI值不是’9’+1，而是’9’+7。为了省的麻烦，我还是采用了-‘A’+10这样的方法。","text":"题目源地址： http://codevs.cn/problem/1475/ 理解跟上一道题差不多- -，也是简单的写了一个循环，然后使用累积法计算十进制的值。不过有一个小小的坑，就是’A’字符的ANSI值不是’9’+1，而是’9’+7。为了省的麻烦，我还是采用了-‘A’+10这样的方法。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 16int n,m;char num[MAXN]= &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;char str[MAXN];void init()&#123; memset(str,0,sizeof(str)); scanf(&quot;%s%d&quot;, str,&amp;m); n=0;&#125;void solve(char str[],int m)&#123; int i=0,len=strlen(str); for(i=0; i&lt;len; i++) &#123; if(str[i]&lt;=&apos;9&apos;) n+=(str[i]-&apos;0&apos;)*pow(m,len-i-1); else n+=(str[i]-&apos;A&apos;+10)*pow(m,len-i-1); &#125;&#125;int main(int argc, char const *argv[])&#123; init(); solve(str,m); printf(&quot;%d\\n&quot;, n); return 0;&#125; 更新日志 2014年10月20日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1474 十进制转m进制","slug":"CodeVS-1474","date":"2014-10-20T20:18:02.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/20/CodeVS-1474/","link":"","permalink":"https://xuanwo.org/2014/10/20/CodeVS-1474/","excerpt":"题目源地址： http://codevs.cn/problem/1474/ 理解一开始就看到了下面的提示——可以使用反向取余法，然后就去百度了一下，结果没有发现什么有用的东西- -，然后坑爹的麦当劳的网络又一直连不上GoAgent，直接导致谷歌也上不去，然后就只能靠自己YY反向取余法到底是个什么玩意儿了。题目自然是十分简单，给的数也不大，n&lt;=100，暴力一点也是OK的。然后就联想到了计算机导论课上老师讲的进制转换的知识点。只要不停地使用n去除以m，余数作为当前位置上的数，商作为下一次运算的n参与循环。直到n&lt;m的时候停止。不过有一个地方需要注意的是，通过这种方法求出来的char数组和答案正好是逆序的，需要将它转换过来。我记得学长有个奇特的技巧可以将字符串逆序输出= =，不过现在条件受限，自己写一个for循环吧。","text":"题目源地址： http://codevs.cn/problem/1474/ 理解一开始就看到了下面的提示——可以使用反向取余法，然后就去百度了一下，结果没有发现什么有用的东西- -，然后坑爹的麦当劳的网络又一直连不上GoAgent，直接导致谷歌也上不去，然后就只能靠自己YY反向取余法到底是个什么玩意儿了。题目自然是十分简单，给的数也不大，n&lt;=100，暴力一点也是OK的。然后就联想到了计算机导论课上老师讲的进制转换的知识点。只要不停地使用n去除以m，余数作为当前位置上的数，商作为下一次运算的n参与循环。直到n&lt;m的时候停止。不过有一个地方需要注意的是，通过这种方法求出来的char数组和答案正好是逆序的，需要将它转换过来。我记得学长有个奇特的技巧可以将字符串逆序输出= =，不过现在条件受限，自己写一个for循环吧。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;#define MAXN 16int n,m;char num[MAXN]=&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;,&apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;;char str[MAXN],ans[MAXN];void init()&#123; memset(str,0,sizeof(str)); memset(ans,0,sizeof(ans)); scanf(&quot;%d%d&quot;, &amp;n,&amp;m);&#125;void solve(int n,int m)&#123; int i=0,tmp=n; while(tmp/m!=0) &#123; str[i++]=num[tmp%m]; tmp=tmp/m; &#125; str[i]=tmp%m+&apos;0&apos;; int len = strlen(str); for(int j=0;j&lt;len;j++) &#123; ans[j]=str[len-j-1]; &#125; ans[len]=&apos;\\0&apos;;&#125;int main(int argc, char const *argv[])&#123; init(); solve(n,m); printf(&quot;%s\\n&quot;, ans); return 0;&#125; 更新日志 2014年10月20日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 3038 3n+1问题","slug":"CodeVS-3038","date":"2014-10-15T14:40:28.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/15/CodeVS-3038/","link":"","permalink":"https://xuanwo.org/2014/10/15/CodeVS-3038/","excerpt":"题目源地址： http://codevs.cn/problem/3038/ 理解水题。一个简单的递归，实际上有一个小小的Trick，因为题目中说明了到目前为止没有证明，所以返回值为-1的情况完全可以不用考虑。","text":"题目源地址： http://codevs.cn/problem/3038/ 理解水题。一个简单的递归，实际上有一个小小的Trick，因为题目中说明了到目前为止没有证明，所以返回值为-1的情况完全可以不用考虑。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;int t,n;int func(int n)&#123; int step=0; while(n!=1) &#123; if(n%2==0) n=n/2; else n=3*n+1; step++; &#125; return step;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d\\n&quot;, func(n)); &#125;&#125; 更新日志 2014年10月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"CodeVS 1212 最大公约数","slug":"CodeVS-1212","date":"2014-10-15T12:04:02.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/15/CodeVS-1212/","link":"","permalink":"https://xuanwo.org/2014/10/15/CodeVS-1212/","excerpt":"题目源地址： http://codevs.cn/problem/1212/ 理解水题。只要使用gcd递归就可以搞定。","text":"题目源地址： http://codevs.cn/problem/1212/ 理解水题。只要使用gcd递归就可以搞定。 新技能getGCD模板代码 int gcd(int a, int b)&#123; return b==0?a:gcd(b,a%b);&#125; 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;ll a,b;ll gcd(ll a, ll b)&#123; return b==0?a:gcd(b,a%b);&#125;int main(int argc, char const *argv[])&#123; scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b); printf(&quot;%lld&quot;, gcd(a,b)); return 0;&#125; 更新日志 2014年10月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Codeforces Beta Round 1 A Theatre Square","slug":"CF-1A","date":"2014-10-14T17:00:08.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/10/14/CF-1A/","link":"","permalink":"https://xuanwo.org/2014/10/14/CF-1A/","excerpt":"题目源地址： http://codeforces.com/contest/1/problem/A 理解大水题一道。只要求出每一边最大的块数就可以了。","text":"题目源地址： http://codeforces.com/contest/1/problem/A 理解大水题一道。只要求出每一边最大的块数就可以了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define ll long long intusing namespace std;ll n, m, a;void init()&#123; scanf(&quot;%I64d%I64d%I64d&quot;, &amp;n, &amp;m, &amp;a);&#125;int main(int argc, char const *argv[])&#123; init(); ll x = n % a == 0 ? n / a : n / a + 1; ll y = m % a == 0 ? m / a : m / a + 1; printf(&quot;%I64d&quot;, x * y); return 0;&#125; 更新日志 2014年10月14日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1050 To the Max","slug":"POJ-1050-To-the-Max","date":"2014-10-07T23:41:26.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/10/07/POJ-1050-To-the-Max/","link":"","permalink":"https://xuanwo.org/2014/10/07/POJ-1050-To-the-Max/","excerpt":"题目源地址： http://poj.org/problem?id=1050 理解题意不难理解，在一个矩阵中寻找一个和最大的子矩阵，可以看作是一个二维的DP问题。不过受到时间的限制，太过暴力的程序显然是不行的，所以现在的问题在于，如何把一个二维的问题转化为一个一维的问题。小脑一动，我们可以想到可以将把矩阵的高度压缩为1之后，在进行一次简单的求最大子序列和就可以实现了。","text":"题目源地址： http://poj.org/problem?id=1050 理解题意不难理解，在一个矩阵中寻找一个和最大的子矩阵，可以看作是一个二维的DP问题。不过受到时间的限制，太过暴力的程序显然是不行的，所以现在的问题在于，如何把一个二维的问题转化为一个一维的问题。小脑一动，我们可以想到可以将把矩阵的高度压缩为1之后，在进行一次简单的求最大子序列和就可以实现了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;//#define LOCAL#define MAXN 102int n, a[MAXN][MAXN];int tmp[MAXN];int maxALL, maxONE;void init()&#123; scanf(&quot;%d&quot;, &amp;n); memset(tmp, 0, sizeof(tmp)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf(&quot;%d&quot;, &amp;a[i][j]); &#125; &#125;&#125;int dp(int *arr, int n)&#123; int max = 0, x = 0; for (int i = 0; i &lt; n; i++) &#123; if (x &lt; 0) x = arr[i]; else &#123; x += arr[i]; if (x &gt; max) max = x; &#125; &#125; return max;&#125;int main(int argc, char const *argv[])&#123;#ifdef LOCAL freopen(&quot;1050.in&quot;, &quot;r&quot;, stdin); //freopen(&quot;.out&quot;, &quot;w&quot;, stdout);#endif init(); for (int i = 0; i &lt; n; i++) &#123; memset(tmp, 0, sizeof(tmp)); for (int j = i; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) tmp[k] += a[j][k]; maxONE = dp(tmp, n); if (maxONE &gt; maxALL) maxALL = maxONE; &#125; &#125; cout &lt;&lt; maxALL &lt;&lt; endl; return 0;&#125; 更新日志 2014年10月07日 已AC，因为freopen忘了改WA了一发。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2479 Maximum sum","slug":"POJ-2479-Maximum-sum","date":"2014-10-07T00:25:21.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/10/07/POJ-2479-Maximum-sum/","link":"","permalink":"https://xuanwo.org/2014/10/07/POJ-2479-Maximum-sum/","excerpt":"题目源地址： http://poj.org/problem?id=2479 理解因为超时卡了很久，不得不换了一种更加优越的方法。不过有点丑，有机会重写一次吧= =","text":"题目源地址： http://poj.org/problem?id=2479 理解因为超时卡了很久，不得不换了一种更加优越的方法。不过有点丑，有机会重写一次吧= = 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define LOCAL#define MAXN 50001int t, a[MAXN];int l[MAXN], r[MAXN], dp[MAXN], ans, big;int m, i, res, tmp;void init()&#123; ans = 0, big = 0; memset(a, 0, sizeof(a)); memset(l, 0, sizeof(l)); memset(r, 0, sizeof(r)); memset(dp, 0, sizeof(dp)); scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; i++) scanf(&quot;%d&quot;, &amp;a[i]);&#125;int main(int argc, char **argv)&#123;#ifdef LOCAL freopen(&quot;2479.in&quot;, &quot;r&quot;, stdin); freopen(&quot;2479.out&quot;, &quot;w&quot;, stdout);#endif scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; init(); tmp = 0; res = -10001; for (i = 0; i &lt; m; ++i) &#123; tmp += a[i]; if (tmp &gt; res) res = tmp; if (tmp &lt; 0) tmp = 0; l[i] = res; &#125; res = -10001; tmp = 0; for (i = m - 1; i &gt;= 0; --i) &#123; tmp += a[i]; if (tmp &gt; res) res = tmp; if (tmp &lt; 0) tmp = 0; r[i] = res; &#125; res = l[0] + r[1]; for (i = 0; i &lt; m - 1; ++i) &#123; tmp = l[i] + r[i + 1]; if (tmp &gt; res) res = tmp; &#125; printf (&quot;%d\\n&quot;, res); &#125; return 0;&#125; 更新日志 2014年10月07日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3624 Charm Bracelet","slug":"POJ-3624-Charm-Bracelet","date":"2014-10-05T10:52:48.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/05/POJ-3624-Charm-Bracelet/","link":"","permalink":"https://xuanwo.org/2014/10/05/POJ-3624-Charm-Bracelet/","excerpt":"题目源地址： http://poj.org/problem?id=3624 理解这道题拖了很久很久，一直没有搞定，对DP以及背包问题的理解，一直处在一个瓶颈之中，特别烦躁。知道今天在比赛群里面问了学长，才发现是空间优化的问题，二维的记忆化数组会直接超出容量限制。想通了这一点后，优化就变得简单了。只要另外定义一个新的数组f[MAXN]，从M-&gt;w[i]进行循环，最后的f[m]就是所要求的结果。","text":"题目源地址： http://poj.org/problem?id=3624 理解这道题拖了很久很久，一直没有搞定，对DP以及背包问题的理解，一直处在一个瓶颈之中，特别烦躁。知道今天在比赛群里面问了学长，才发现是空间优化的问题，二维的记忆化数组会直接超出容量限制。想通了这一点后，优化就变得简单了。只要另外定义一个新的数组f[MAXN]，从M-&gt;w[i]进行循环，最后的f[m]就是所要求的结果。 代码挂在空间占用上的代码 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAXN 3403#define MAXW 12881int n, m;int w[MAXN], d[MAXN];int dp[MAXN][MAXW];void init()&#123; memset(w, 0, sizeof(w)); memset(d, 0, sizeof(d)); memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; d[i]; &#125;&#125;//不作任何优化的搜索，TLE/*int rec(int i, int j)&#123; int res; if (i == n) &#123; res = 0; &#125; else if (j &lt; w[i]) &#123; res = rec(i + 1, j); &#125; else &#123; res = max(rec(i + 1, j), rec(i + 1, j - w[i]) + d[i]); &#125; return res;&#125;**///采用记忆化搜索，出现WA，TLE，MLE，然后我一怒之下还交了一发CE= =，不知道错在哪里。/*int rec(int i, int j)&#123; if (dp[i][j] &gt;= 0) return dp[i][j]; int res; if (i == n) &#123; res = 0; &#125; else if (j &lt; w[i]) &#123; res = rec(i + 1, j); &#125; else &#123; res = max(rec(i + 1, j), rec(i + 1, j - w[i]) + d[i]); &#125; return dp[i][j] = res;&#125;**/void solve()&#123; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt;= m; j++) &#123; if (j &lt; w[i]) &#123; dp[i][j] = dp[i + 1][j]; &#125; else &#123; dp[i][j] = max(dp[i + 1][j], dp[i + 1][j - w[i]] + d[i]); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); solve(); printf(&quot;%d\\n&quot;, dp[0][m]); return 0;&#125; 修改之后成功AC的代码 #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAXN 20000int n, m;int w[MAXN], d[MAXN];int dp[MAXN];void init()&#123; memset(w, 0, sizeof(w)); memset(d, 0, sizeof(d)); memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; w[i] &gt;&gt; d[i]; &#125;&#125;void solve()&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = m; j &gt;= w[i]; j--) &#123; dp[j] = max(dp[j], dp[j - w[i]] + d[i]); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); solve(); printf(&quot;%d\\n&quot;, dp[m]); return 0;&#125; 更新日志 2014年10月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"深澜HTML登陆——防掉线，开共享","slug":"SRUN","date":"2014-10-03T20:38:27.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/10/03/SRUN/","link":"","permalink":"https://xuanwo.org/2014/10/03/SRUN/","excerpt":"前言一直以来使用的是老版的SRUN3000.exe客户端，同时也忍受着老版客户端频繁掉线以及莫名卡死等诡异问题。来到实验室之后，老版客户端出现了秒退的现象，刚登陆就提示“检测到代理服务，已自动下线”；使用新版的客户端，则提示“与绑定的IP不一致或开启了共享，balabala”。看来深澜的限制已经影响到我的正常使用了，不如自己捣鼓一下吧。下面直接放出解决方案（地大专用），如果对原理感兴趣的可以继续往下看。","text":"前言一直以来使用的是老版的SRUN3000.exe客户端，同时也忍受着老版客户端频繁掉线以及莫名卡死等诡异问题。来到实验室之后，老版客户端出现了秒退的现象，刚登陆就提示“检测到代理服务，已自动下线”；使用新版的客户端，则提示“与绑定的IP不一致或开启了共享，balabala”。看来深澜的限制已经影响到我的正常使用了，不如自己捣鼓一下吧。下面直接放出解决方案（地大专用），如果对原理感兴趣的可以继续往下看。 解决方案点击下载网页登陆版深澜客户端 HTML源代码IPv4登陆&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Srun Login!&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function submit() &#123; document.getElementById(&apos;submit&apos;).click(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;submit();&quot;&gt; &lt;form action=&quot;http://202.204.105.195:3333/cgi-bin/do_login&quot; method=&quot;post&quot;&gt; &lt;!--将账号，密码，MAC地址分别填写进value=&quot;&quot;的俩冒号中，例如value=&quot;1234567&quot;--&gt; &lt;p&gt;账号：&lt;input name=&quot;username&quot; value=&quot;&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/p&gt; &lt;p&gt;MAC：&lt;input name=&quot;mac&quot; type=&quot;hidden&quot; value=&quot;&quot;&gt;&lt;/p&gt; &lt;input name=&quot;n&quot; type=&quot;hidden&quot; value=&quot;99&quot;&gt; &lt;input name=&quot;type&quot; type=&quot;hidden&quot; value=&quot;3&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;OK&quot; /&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; IPv6登陆&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Srun Login!&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function submit() &#123; document.getElementById(&apos;submit&apos;).click(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;submit();&quot;&gt; &lt;form action=&quot;http://[2001:da8:214:102:d6be:d9ff:feaa:422a]/cgi-bin/do_login&quot; method=&quot;post&quot;&gt; &lt;!--将账号，密码，MAC地址分别填写进value=&quot;&quot;的俩冒号中，例如value=&quot;1234567&quot;--&gt; &lt;p&gt;账号：&lt;input name=&quot;username&quot; value=&quot;&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot;&gt;&lt;/p&gt; &lt;input name=&quot;n&quot; type=&quot;hidden&quot; value=&quot;100&quot;&gt; &lt;input name=&quot;is_pad&quot; value=&quot;1&quot;&gt; &lt;input name=&quot;type&quot; type=&quot;hidden&quot; value=&quot;1&quot;&gt; &lt;p&gt;&lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;OK&quot; /&gt;&lt;/p&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; login页面&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;Srun Login!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; iframe &#123; border:none; width:100%; display:block; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;ipv6.html&quot;&gt; &lt;/iframe&gt; &lt;iframe src=&quot;ipv4.html&quot;&gt; &lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 鸣谢 @Austin Lee @范神 @嘉琦学长 更新日志 2014年10月03日 捣鼓了一天，总算能用了。期间因为对POST的错误理解，还绕了一个大弯子。以后再完善吧，争取做出一个可用的版本，不用复杂的配置，可移植性强。 2015年05月06日 当前版本已经失效，仅IPv6可用，替代可用：gate.cugbteam.org","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"}]},{"title":"跨城公交网站的想法","slug":"transport-website","date":"2014-09-10T09:49:15.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/09/10/transport-website/","link":"","permalink":"https://xuanwo.org/2014/09/10/transport-website/","excerpt":"","text":"功能痛点跨城市的公共交通导航 实现途径调用各大地图服务提供商的API（比如百度） 实现方法将一条需求的导航路线分成三段： 出发城市-&gt;城市之间的长途交通（长途汽车，火车，飞机，轮船）-&gt;到达城市 根据所选择的交通方式的不同，分别在各自城市内设定起点至对应站点。 可能的具体功能点 最优费用计算 最短到达时间 行程规划 用于旅游导航服务（携程快来收购我，233333） 盈利方式 关联广告（流量变现） 票券代购（收取服务费，感觉不靠谱） 相关风险 没有什么技术难度，很容易被百度地图之类的作为一个小功能加入，难以竞争。 地图依赖于服务提供商的更新，上游受到控制，相关API可能被限制调用。 更新日志 2014年09月10日 简单的完成列举了自己的想法。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"}]},{"title":"世界——我的游戏狂想曲","slug":"world","date":"2014-09-07T05:20:01.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2014/09/07/world/","link":"","permalink":"https://xuanwo.org/2014/09/07/world/","excerpt":"前言凌晨，打了一个电话之后发现大脑意外的活跃，毫无睡意。躺在床上百无聊赖的时候突然想要自己来设计一个游戏，我梦想中的完美游戏。大部分创意都来自我看过的小说（吐槽一下中国市场上百花齐放的网游小说，相比之下刀剑神域的idea实在太low了），只是这次我希望寻找出一个办法来使得这些元素更好地结合在一起。游戏的名字，暂且定为——世界。","text":"前言凌晨，打了一个电话之后发现大脑意外的活跃，毫无睡意。躺在床上百无聊赖的时候突然想要自己来设计一个游戏，我梦想中的完美游戏。大部分创意都来自我看过的小说（吐槽一下中国市场上百花齐放的网游小说，相比之下刀剑神域的idea实在太low了），只是这次我希望寻找出一个办法来使得这些元素更好地结合在一起。游戏的名字，暂且定为——世界。 简要介绍3D（如果未来出现了虚拟现实技术，肯定是要是支持的），MMORPG，写实风。 游戏开始时，每个角色会被随机分配到一个角色（嘛，可以理解为投胎）。可能是西方某个领主的儿子，以后会继承他的城堡；可能是东方某个皇帝的私生子，与每个MPC的好感值都特别低（@琼恩·雪诺）。 游戏开始于石器时代，采取的社会形式是部落形态。这个阶段不会出现超越时代的武器以及超越时代的技术，直到有人探索到了青铜器的科技。（在关于科技发展这个方面，我不知道怎样处理比较合适。如果完全拟真的话，感觉难度太高，而且无法控制游戏进程。不如采取探索的形式，同样遵循随机的原则。不过如果专精于科学家的话，会提高发现相关技术的几率） 游戏遵循完全的随机原则（我需要一个牛逼透了的随机算法）。一个科学家可能因为发现了电灯泡一夜成名（@爱迪生），而一个国王可能因为偶遇一只野猪惨死（@可怜的七国之王），一个默默无名的盗贼会因为发现了某个秘籍而成为江湖的传说（@无数网游小说的主角）。 游戏中，人生而平等。每个角色只有一条命，同一个账号下不同角色之间没有关联。每个角色设定了初始寿命为100年，游戏与现实的流速比为10:1（没错，我要创造一个游戏界的不死神话）。这个初始寿命会因为饮食习惯，生活习惯或者意外事件发生变动。 本游戏全平台制霸，要求做到每次更新都不需要停机。世界地图按照地球1:1建模，可以考虑使用Google地图的数据，只要使用地形图就OK。（请允许我在此引用那个著名的梗：只缺一个敲代码的了） 一开始所有主城都归NPC所有，默认为当地国家的首都。 战斗系统基本上分成两个阶段：冷兵器和热兵器。 冷兵器时代主要的战斗方式为两种：身体和魔法。 身体自然好理解，基本上参照《骑马与砍杀》来做就OK，不过要支持各种各样的兵器，也就是要做到近距离能用剑砍，远距离能用弓箭手，当然了，骑马肯定省不了。为了防止某些脑洞大开的人存在，别的动物也得设计上骑乘的功能（牛？羊？猪？）。 魔法泛指所有无法用科学解释的能力，包括西方的魔法，东方的气功以及各种内功心法。虽说这些能力无法用科学解释，但是在战斗时肯定还是通过可以用科学解释的方式来战斗的。也就是说，不存在直接致死的魔法，必须通过某些手段来伤害到他人。比如，火球术必须攻击到脑袋才能造成足够的伤害，要是攻击到他的盔甲神马的，在地上滚一圈就没事了。从这个意义上来讲，魔法的战斗力是被削弱了的。当然啦，这个领域就有大量的作品可以用来参考了，包括《魔兽世界》在内的很多MMORPG都可以成为素材。 热兵器时代这个就简单了= =，基本照着《使命召唤》来就好,上天入地无所不能啊。不过考虑到实现的可能性（程序员早就死的差不多了= =），现代化的武器无需太过真实的模拟，飞机就参考《鹰击长空》，潜艇就参考《猎杀潜航》，坦克就参考《坦克世界》。至于航母嘛= =，还不知道怎么处理，待续吧。 战争系统网游嘛= =，不能完全种田是不是，不打仗怎么挣钱，不打仗哪来的生产力？ 胜利条件某一方提出投降，或者某一方的首都被占领（此时战败方可以组建流亡政府） 战场设定不另外开辟战场空间，直接在世界地图上开战（这一点对于被侵略国不太舒服- -，嘛，落后就要挨打，永远是真理）。同时兵力调配不会出现超自然现象，该坐飞机的坐飞机，该骑马的骑马，该走过去的就走过去。允许使用任何兵法或者阴谋诡计，神马截粮草，烧粮仓，借东风之类的，尽管来。 对主城的特殊设定在若干个版本之后，玩家的实力可能已经威胁到主城的地位。此时，玩家可以选择向主城发起进攻。成功，有一位领主可以进驻主城，该领主将获得该国家全部税收的10%，并且出任该国家的最高领导人；失败，玩家将会遭到主城所在势力的追杀和通缉。 资源系统值得一提的是这个游戏内的主城资源数量是有限的，也就是说主城的店铺内的各种商品价格会随着资源的价格上下波动。举一个简单的例子，当年风调雨顺的话，米饭的价格会下降；要是兵荒马乱，米饭的价格就会上升。下面从产生和消费两个角度分别介绍一下资源系统。 资源的产生所有的资源都来自于人们的各种采集或者种植活动，没有从天上掉下来的馅饼。现在主城里摆出来卖的，不过是你们进入游戏之前由NPC们采集出来的而已。也就是说，玩家们所购买的每一粒米饭都是别人种植出来。基于简单的经济学原理，米饭的价格持续上扬，就会有更多的人（包括NPC和玩家）会去种植稻谷，产出多了，米饭的价格就会下降，从而维持了整个系统的经济运行不会出现崩溃。同时，随着整个时代的生产力的提高，资源的价格会不断下降，而稀有资源的价格会不断上升（也不一定，这个取决于资源数量变少导致的采集困难所增加的成本与生产力提高导致的成本下降的多少。） 资源的消费资源的消费渠道很多。要是自己精通冶炼技术的话，可以自己炼铁；可以出售给铁匠铺，可以上厕所的时候掉进马桶（怪我咯），可以吃饭的时候被小偷偷走，可以走在路上包裹破了全都掉在地上= =，也可以被某个路过的王侯看见直接抢走。总之，整个资源的体系是不断循环的，是构建这个游戏的一块基石。 职业系统没有主副职业之分，不过有着职业熟练度。长期从事某项工作，可以加快完成工作的速度以及提高工作完成的质量，并提高在该职业上的探索几率，有一定概率成为该职业的宗师。 种族系统我说了这是写实风的MMORPG=。=，哈，没有龙族哪有人玩？ 人族几率最高，魔法感知力平庸（东方世界有独特的技巧可以增强战斗力） 结婚系统这个喜闻乐见的系统到底要不要开放呢？理论上来说，为了保持游戏的平衡，每一位新增的玩家都必须是某一对夫妻的后代（私生子也算哦=。=，@琼恩·雪诺）在游戏的早期，由于玩家数量不足，大部分玩家将会成为NPC的后代；在游戏发展成熟之后，大部分新增玩家将会是玩家夫妻的后代，不足的缺额将有NPC来补充。考虑到人类人口的自然增长，预计这样的缺额在长时间之内将会一直存在。 教学系统基于婚姻系统的存在，可以在后代的成长阶段自然导入教学系统——学得快的早点成家立业，学得慢的天天只会喝奶（@鹰巢城少主，简直无情）。按照10:1的时间流速比计算，大部分人的教学时间将会长达两年左右，期间父母必须履行抚养义务（少出任务，多陪陪孩子- -）教学期间体型自然增长，到25岁左右时大部分身体属性达到最高值，并且附带婚姻系统的开放（具体时间取决于所在势力的规定）。要是运气不好被分到某天朝要再来一次高考的话= =，我只能说，怪我咯？ 插件系统游戏太过庞大了= =，已经不是一家公司能完成的游戏了，所以可以开放出插件系统。只要先做出一个平台，剩下的部分可以交给别的公司来完成。同时，部分游戏内容的插件话，有利于维护并且提高游戏体验。 比如说，每一个体育项目可以单独开发一个插件，可以拥有自己的UI，自己的操作方式。只要在领地上建立对应的场馆，引用该插件，就可以完成对该种体育项目的支持。比如篮球交给2K公司来做，也要给他s们留口饭吃是不是。 扩散开去，这样可以实现对很多小众人群的照顾，比如插花，绘画，茶道等等~~ 开放API 生存本能（饿了吃，困了睡，包括自我认知） 感官系统（五感，部分角色有一定几率丢失） 动作系统（基于人类自身属性，所能完成的动作不一） 各版本概览V1.0 石器时代人们以部落形式存在，没有统一的势力。此时不支持任何插件，不支持货币兑换（就算换了，你也没地方买吃的= =），不开放世界地图，仅开放最基础的生活系统，游戏内容主要围绕文明存继为主。主要的敌人为各种生物以及自然天气，此时期预计大部分玩家将因为饥饿致死。游戏内容 体验与野兽的激情战斗（请自行脑补《骑马与砍杀》形态的战斗） 感受“谁知盘中餐，粒粒皆辛苦”的艰辛（怪我咯） 成为部落长老，享受万众拥戴的乐趣（除了容易饿死，别的什么都好）详细设定 各种族比例均衡，人族略多，各个种族之间无敌对关系（基本上也没有什么往来）。 更新日志 2014年09月07日 完成简要介绍。 2014年09月08日 完善部分设定，除此之外，中秋节快乐~ 2016年02月21日 移除了过多的23333","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Games","slug":"Games","permalink":"https://xuanwo.org/tags/Games/"}]},{"title":"TiddlyWiki中文教程","slug":"tiddlywiki-doc-cn","date":"2014-08-29T09:18:06.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/29/tiddlywiki-doc-cn/","link":"","permalink":"https://xuanwo.org/2014/08/29/tiddlywiki-doc-cn/","excerpt":"","text":"前言TiddlyWiki是我见过的配置最为简单的Wiki系统，纯HTML实现，不需要服务器，没有复杂的依赖，使用体验非常赞。但是国内使用的人实在太少，而且TiddlyWiki更新迭代很快，原有的一些文档已经不再适用于最新版本的TiddlyWiki了。 基础教学下载如下页面:http://tiddlywiki.com/empty.html，保存至自己想要保存的地方。做任何修改之后，点击保存，浏览器会自动弹出另存为窗口，覆盖自己原先保存的html文件即可。没错，就是这么简单！ 更新日志 2014年08月29日 我们的征途，当是星辰大海。 2014年09月03日 完成基础教学，接下来会依次补充基于浏览器的高阶用法，以及如何在node.js服务器上使用它，不过快开学了，最近有点忙= =。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"}]},{"title":"修改Foobar2000的皮肤","slug":"foobar2000-skins","date":"2014-08-28T22:09:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/28/foobar2000-skins/","link":"","permalink":"https://xuanwo.org/2014/08/28/foobar2000-skins/","excerpt":"大图镇楼，没错，这就是Foobar2000.) 前言之前装过好几次Foobar2000，但后来都删掉了，原因是它的界面着实不符合我的审美。直到后来偶然间看到某大神图才发现，原来Foobar2000的正确打开方式是这样的！但是由于版本变迁，前辈们写的文章已经不太适用于最新的版本了，在主题的配置上绕了好大的弯子，决定自己来完成一篇教程。","text":"大图镇楼，没错，这就是Foobar2000.) 前言之前装过好几次Foobar2000，但后来都删掉了，原因是它的界面着实不符合我的审美。直到后来偶然间看到某大神图才发现，原来Foobar2000的正确打开方式是这样的！但是由于版本变迁，前辈们写的文章已经不太适用于最新的版本了，在主题的配置上绕了好大的弯子，决定自己来完成一篇教程。 配置下载到自己喜欢的皮肤这里提供了十个全世界好评度最高的皮肤，没有一一核实是否为最新版，也不确定是否兼容，有问题的话请联系我。点击这里进入城通网盘下载 把主题包内的所有文件复制到Foobar2000安装目录下 重新打开Foobar2000，此时会跳出提示，选择 打开设置，选择自己喜欢的配色 享受自己的音乐生活吧～更新日志 2014年08月28日 完成基本的配置步骤并提供了下载地址。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"SourceTree使用SSH连接Github","slug":"sourcetree-ssh-github","date":"2014-08-28T21:44:21.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/28/sourcetree-ssh-github/","link":"","permalink":"https://xuanwo.org/2014/08/28/sourcetree-ssh-github/","excerpt":"","text":"问题描述使用SourceTree软件用SSH的方式来克隆Github上面的某一个库，但是始终出现Permission Denied。 解决方案修改SourceTree默认的SSH客户端，使用OpenSSH来链接（仅适用于Git）。工具-&gt;选项-&gt;一般，SSH客户端选择OpenSSH。SSH密钥选择之前已经生成好的SSH密钥，纯文件形式，无后缀，一般位于C:\\Users\\yourname\\.ssh目录下。 更新日志 2014年08月28日 完成解决方案。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://xuanwo.org/tags/Github/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"Sublime For Wiz —— 为知笔记的Sublime插件","slug":"sublime-for-wiz","date":"2014-08-27T15:59:17.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/27/sublime-for-wiz/","link":"","permalink":"https://xuanwo.org/2014/08/27/sublime-for-wiz/","excerpt":"介绍一个非常简单的为知插件，基于大神发布的Vim编辑器修改而来，使用了CodeMirror开源库，目前的功能只不过是更换了编辑页面而已，简陋的很。目标是为为知提供良好的代码高亮及Markdown实时渲染功能。","text":"介绍一个非常简单的为知插件，基于大神发布的Vim编辑器修改而来，使用了CodeMirror开源库，目前的功能只不过是更换了编辑页面而已，简陋的很。目标是为为知提供良好的代码高亮及Markdown实时渲染功能。 版本信息主版本：v0.1CodeMirror版本：v4.5 Todo 完善代码高亮 完善Sublime的快捷键设定 更新日志 2014年08月27日 v0.1发布，上传至为知应用中心。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"POJ 3069 Saruman's Army","slug":"POJ-3069-Saruman's-Army","date":"2014-08-25T09:31:30.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/25/POJ-3069-Saruman's-Army/","link":"","permalink":"https://xuanwo.org/2014/08/25/POJ-3069-Saruman's-Army/","excerpt":"题目源地址： http://poj.org/problem?id=3069 理解每一个点有自己的范围，要求所有的点都被覆盖。一开始的解法就是贪心，从最左边开始考虑，距离这个点r以内的区域内一定要有被标记的点（包括自身），只要不断的叠加上去就OK。后来自己想过另外一种解法，每个点的区域都进行标记，一旦两个点有重叠的部分，则意味着有一个点是多余的。不过计算之后感觉时间复杂度有点高，可能达到了O(N^3)的级别，就没有继续向下去。","text":"题目源地址： http://poj.org/problem?id=3069 理解每一个点有自己的范围，要求所有的点都被覆盖。一开始的解法就是贪心，从最左边开始考虑，距离这个点r以内的区域内一定要有被标记的点（包括自身），只要不断的叠加上去就OK。后来自己想过另外一种解法，每个点的区域都进行标记，一旦两个点有重叠的部分，则意味着有一个点是多余的。不过计算之后感觉时间复杂度有点高，可能达到了O(N^3)的级别，就没有继续向下去。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAXN 1001int point[MAXN];int r, n;int cover[MAXN];void init()&#123; memset(point, 0, sizeof(point)); memset(cover, 0, sizeof(cover)); for (int i = 0; i &lt; n; i++) cin &gt;&gt; point[i]; sort(point, point + n);&#125;int main(int argc, char const *argv[])&#123; while (cin &gt;&gt; r &gt;&gt; n &amp;&amp; r != -1 &amp;&amp; n != -1) &#123; init(); int i = 0, ans = 0; while (i &lt; n) &#123; int s = point[i++]; while (i &lt; n &amp;&amp; point[i] &lt;= s + r) i++; int p = point[i - 1]; while (i &lt; n &amp;&amp; point[i] &lt;= p + r) i++; ans++; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年08月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3617 Best Cow Line","slug":"POJ-3617-Best-Cow-Line","date":"2014-08-24T21:42:20.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/24/POJ-3617-Best-Cow-Line/","link":"","permalink":"https://xuanwo.org/2014/08/24/POJ-3617-Best-Cow-Line/","excerpt":"题目源地址： http://poj.org/problem?id=3617 理解根据题目中所描述的数据结构来构建一个字典序最小的字符串。贪心算法：不断取S的开头和末尾中较小的一个字符添加到T的末尾。特别的，当两个字符大小一样时，则需要比较下一个字符。","text":"题目源地址： http://poj.org/problem?id=3617 理解根据题目中所描述的数据结构来构建一个字典序最小的字符串。贪心算法：不断取S的开头和末尾中较小的一个字符添加到T的末尾。特别的，当两个字符大小一样时，则需要比较下一个字符。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAX_N 2000int n, i;char s[MAX_N + 1];int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; getchar(); scanf(&quot;%c&quot;, &amp;s[i]); &#125; int a = 0, b = n - 1; int flag = 0; while (a &lt;= b) &#123; bool left = false; for (i = 0; a + i &lt;= b; i++) &#123; if (s[a + i] &lt; s[b - i]) &#123; left = true; break; &#125; else if (s[a + i] &gt; s[b - i]) &#123; left = false; break; &#125; &#125; ++flag; cout &lt;&lt; (left ? s[a++] : s[b--]) &lt;&lt; (flag % 80 ? &quot;&quot; : &quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月24日 已AC。 2014年08月25日 代码BUG修正，解决了PE问题，昨天没看就以为自己过了真的是。。。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3414 Pots","slug":"POJ-3414-Pots","date":"2014-08-24T21:11:39.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/24/POJ-3414-Pots/","link":"","permalink":"https://xuanwo.org/2014/08/24/POJ-3414-Pots/","excerpt":"题目源地址： http://poj.org/problem?id=3414 理解因为卡一道题然后整整两天没有做题目什么的太不科学了- -。纠结的难点在于，我怎么样把实现操作的路径打印出来。事实上，标记全部的六种状态，然后在bfs的过程中，把每一个状态全都输出到一个数组中去，然后再进行输出。","text":"题目源地址： http://poj.org/problem?id=3414 理解因为卡一道题然后整整两天没有做题目什么的太不科学了- -。纠结的难点在于，我怎么样把实现操作的路径打印出来。事实上，标记全部的六种状态，然后在bfs的过程中，把每一个状态全都输出到一个数组中去，然后再进行输出。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int maxn = 110;int vis[maxn][maxn];int a, b, c;int step;int flag;struct Status&#123; int k1, k2; int op; int step; int pre;&#125; q[maxn *maxn];int id[maxn *maxn];int lastIndex;void bfs()&#123; Status now, next; int head, tail; head = tail = 0; q[tail].k1 = 0; q[tail].k2 = 0; q[tail].op = 0; q[tail].step = 0; q[tail].pre = 0; tail++; memset(vis, 0, sizeof(vis)); vis[0][0] = 1; while (head &lt; tail) &#123; now = q[head]; head++; if (now.k1 == c || now.k2 == c) &#123; flag = 1; step = now.step; lastIndex = head - 1; &#125; for (int i = 1; i &lt;= 6; i++) &#123; if (i == 1) &#123; next.k1 = a; next.k2 = now.k2; &#125; else if (i == 2) &#123; next.k1 = now.k1; next.k2 = b; &#125; else if (i == 3) &#123; next.k1 = 0; next.k2 = now.k2; &#125; else if (i == 4) &#123; next.k1 = now.k1; next.k2 = 0; &#125; else if (i == 5) &#123; if (now.k1 + now.k2 &lt;= b) &#123; next.k1 = 0; next.k2 = now.k1 + now.k2; &#125; else &#123; next.k1 = now.k1 + now.k2 - b; next.k2 = b; &#125; &#125; else if (i == 6) &#123; if (now.k1 + now.k2 &lt;= a) &#123; next.k1 = now.k1 + now.k2; next.k2 = 0; &#125; else &#123; next.k1 = a; next.k2 = now.k1 + now.k2 - a; &#125; &#125; next.op = i; if (!vis[next.k1][next.k2]) &#123; vis[next.k1][next.k2] = 1; next.step = now.step + 1; next.pre = head - 1; q[tail].k1 = next.k1; q[tail].k2 = next.k2; q[tail].op = next.op; q[tail].step = next.step; q[tail].pre = next.pre; tail++; if (next.k1 == c || next.k2 == c) &#123; flag = 1; step = next.step; lastIndex = tail - 1; return; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) != EOF) &#123; flag = 0; step = 0; bfs(); if (flag) &#123; printf(&quot;%d\\n&quot;, step); id[step] = lastIndex; for (int i = step - 1; i &gt;= 1; i--) &#123; id[i] = q[id[i + 1]].pre; &#125; for (int i = 1; i &lt;= step; i++) &#123; if (q[id[i]].op == 1) printf(&quot;FILL(1)\\n&quot;); else if (q[id[i]].op == 2) printf(&quot;FILL(2)\\n&quot;); else if (q[id[i]].op == 3) printf(&quot;DROP(1)\\n&quot;); else if (q[id[i]].op == 4) printf(&quot;DROP(2)\\n&quot;); else if (q[id[i]].op == 5) printf(&quot;POUR(1,2)\\n&quot;); else if (q[id[i]].op == 6) printf(&quot;POUR(2,1)\\n&quot;); &#125; &#125; else printf(&quot;impossible\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月24日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1250 Tanning Salon","slug":"POJ-1250-Tanning-Salon","date":"2014-08-22T22:41:28.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/22/POJ-1250-Tanning-Salon/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-1250-Tanning-Salon/","excerpt":"题目源地址： http://poj.org/problem?id=1250 理解旅行者的问题，按照题目意思来就好。","text":"题目源地址： http://poj.org/problem?id=1250 理解旅行者的问题，按照题目意思来就好。 新技能get代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int MAX = 60;int main(int argc, char const *argv[])&#123; int n, i, id, ans; char str[MAX]; bool vis[MAX], tan[MAX]; while (cin &gt;&gt; n &amp;&amp; n) &#123; memset(vis, 0, sizeof(vis)); memset(tan, 0, sizeof(tan)); cin &gt;&gt; str; ans = 0; for (i = 0; i &lt; strlen(str); i ++) &#123; id = str[i] - &apos;A&apos;; if (!vis[id]) &#123; vis[id] = true; if (n &gt; 0) &#123; n --; tan[id] = true; &#125; else ans ++; &#125; else &#123; if (tan[id]) n ++; &#125; &#125; if (ans == 0) printf(&quot;All customers tanned successfully.\\n&quot;); else printf(&quot;%d customer(s) walked away.\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2109 Power of Cryptography","slug":"POJ-2109-Power-of-Cryptography","date":"2014-08-22T22:32:28.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2109-Power-of-Cryptography/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2109-Power-of-Cryptography/","excerpt":"题目源地址： http://poj.org/problem?id=2109 理解直接暴力求。","text":"题目源地址： http://poj.org/problem?id=2109 理解直接暴力求。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; double n , m ; while ( scanf( &quot;%lf%lf&quot; , &amp;m , &amp;n ) != EOF ) printf( &quot;%.0f\\n&quot; , exp(log(n) / m)); return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2328 Guessing Game","slug":"POJ-2328-Guessing-Game","date":"2014-08-22T22:28:14.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2328-Guessing-Game/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2328-Guessing-Game/","excerpt":"题目源地址： http://poj.org/problem?id=2328 理解猜数字游戏，还是比较熟悉的模型。先确定一个正确数字，另一个人猜数字，然后回答猜测数字比正确数字是太高、太低还是正确。现在题中给定猜测的过程，让我们用程序验证这个猜测过程中，回答是否正确。","text":"题目源地址： http://poj.org/problem?id=2328 理解猜数字游戏，还是比较熟悉的模型。先确定一个正确数字，另一个人猜数字，然后回答猜测数字比正确数字是太高、太低还是正确。现在题中给定猜测的过程，让我们用程序验证这个猜测过程中，回答是否正确。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;char str[3][20] = &#123;&quot;too high&quot;, &quot;too low&quot;, &quot;right on&quot;&#125;;int answer[1100];int getnum[1100];int getanswer(char ans[])&#123; if (strcmp(str[0], ans) == 0) &#123; return 1; &#125; else if (strcmp(str[1], ans) == 0) &#123; return -1; &#125; else if (strcmp(str[2], ans) == 0) &#123; return 0; &#125;&#125;int main(int argc, char const *argv[])&#123; char tmp[20]; int num, rightnum; int i, j; int flag; while (scanf(&quot;%d&quot;, &amp;num), num != 0) &#123; getchar(); gets(tmp); answer[0] = getanswer(tmp); getnum[0] = num; for (i = 0; answer[i] != 0; ) &#123; i++; scanf(&quot;%d&quot;, &amp;num); getchar(); gets(tmp); answer[i] = getanswer(tmp); getnum[i] = num; &#125; rightnum = getnum[i]; i++; for (flag = 1, j = 0; j &lt; i - 1; j++) &#123; if (getnum[j] - rightnum &gt; 0 &amp;&amp; answer[j] == 1 ) &#123; continue; &#125; else if (getnum[j] - rightnum &lt; 0 &amp;&amp; answer[j] == -1) &#123; continue; &#125; else &#123; flag = 0; break; &#125; &#125; if (flag) &#123; printf(&quot;Stan may be honest\\n&quot;); &#125; else if (flag == 0) &#123; printf(&quot;Stan is dishonest\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2363 Blocks","slug":"POJ-2363-Blocks","date":"2014-08-22T22:21:48.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2363-Blocks/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2363-Blocks/","excerpt":"题目源地址： http://poj.org/problem?id=2363 理解直接暴力计算，没有啥算法。","text":"题目源地址： http://poj.org/problem?id=2363 理解直接暴力计算，没有啥算法。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int getarea(int a, int b, int c)&#123; return 2 * (a * b + b * c + a * c);&#125;int main(int argc, char const *argv[])&#123; int a, b, c; int area, v, tmp; int ii, casenum; scanf(&quot;%d&quot;, &amp;casenum); for (ii = 0; ii &lt; casenum; ii++) &#123; scanf(&quot;%d&quot;, &amp;v); area = 1000000; for (a = 1; a &lt;= sqrt(v); a++) &#123; if (v % a == 0) &#123; for (b = a; b &lt;= sqrt(v); b++) &#123; if (v % b == 0) &#123; c = v / a / b; if (v % c == 0 &amp;&amp; a * b * c == v) &#123; tmp = getarea(a, b, c); if (tmp &lt; area) &#123; area = tmp; &#125; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, area); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2459 Feed Accounting","slug":"POJ-2459-Feed-Accounting","date":"2014-08-22T22:12:13.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2459-Feed-Accounting/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2459-Feed-Accounting/","excerpt":"题目源地址： http://poj.org/problem?id=2459 理解英文题- -，阅读理解很重要。&gt;容我搬运一下大牛的翻译：就是说有一个人，有F1公斤的草料，需要储存到一个空仓库中，但是不知道要从什么时候开始添加才能够保证，在第D天的时候还剩下F2公斤草料，因为这个人家附近后C头牛出没，他们会来偷吃草料，每头牛来偷吃草料的时间段不一样。如果牛过来吃草料的时候，草料就会少，且每头牛每天吃且仅吃1公斤/天/头。问，如果要保证第D天的时候会剩余下F2公斤草料，需要在哪一天的时候添加这F1公斤草料。","text":"题目源地址： http://poj.org/problem?id=2459 理解英文题- -，阅读理解很重要。&gt;容我搬运一下大牛的翻译：就是说有一个人，有F1公斤的草料，需要储存到一个空仓库中，但是不知道要从什么时候开始添加才能够保证，在第D天的时候还剩下F2公斤草料，因为这个人家附近后C头牛出没，他们会来偷吃草料，每头牛来偷吃草料的时间段不一样。如果牛过来吃草料的时候，草料就会少，且每头牛每天吃且仅吃1公斤/天/头。问，如果要保证第D天的时候会剩余下F2公斤草料，需要在哪一天的时候添加这F1公斤草料。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int account[2100];int main(int argc, char const *argv[])&#123; int c, f1, f2, d; int day1, day2; int i, j, result, tmp; while (scanf(&quot;%d%d%d%d&quot;, &amp;c, &amp;f1, &amp;f2, &amp;d) != EOF) &#123; memset(account, 0, sizeof(account)); for (i = 0; i &lt; c; i++) &#123; scanf(&quot;%d%d&quot;, &amp;day1, &amp;day2); for (j = day1; j &lt;= day2; j++) &#123; account[j]++; &#125; &#125; tmp = f1 - f2; for (i = d; i &gt;= 1 &amp;&amp; tmp &gt; 0; i--) &#123; tmp -= account[i]; &#125; printf(&quot;%d\\n&quot;, i + 1); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2470 Ambiguous permutations","slug":"POJ-2470-Ambiguous-permutations","date":"2014-08-22T22:09:08.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2470-Ambiguous-permutations/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2470-Ambiguous-permutations/","excerpt":"题目源地址： http://poj.org/problem?id= 理解对于一个有N个元素的队列，队列元素为[1,2,…,N-1,N]，进行一次队列变换，当前队列“数字i的位置”将成为变换后队列的第i个元素的值（下标从1开始）。","text":"题目源地址： http://poj.org/problem?id= 理解对于一个有N个元素的队列，队列元素为[1,2,…,N-1,N]，进行一次队列变换，当前队列“数字i的位置”将成为变换后队列的第i个元素的值（下标从1开始）。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int arr[110000];int end[110000];int change(int arr[], int n)&#123; int i, j; int flag = 1; for (i = 1; i &lt;= n; i++) &#123; end[arr[i]] = i; &#125; for (i = 1; i &lt;= n; i++) &#123; if (end[i] != arr[i]) &#123; flag = 0; &#125; &#125; return flag;&#125;int main(int argc, char const *argv[])&#123; int n, i; while (scanf(&quot;%d&quot;, &amp;n), n != 0) &#123; memset(arr, 0, sizeof(arr)); memset(end, 0, sizeof(end)); for (i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; if (change(arr, n)) &#123; printf(&quot;ambiguous\\n&quot;); &#125; else &#123; printf(&quot;not ambiguous\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2535 Very Simple Problem","slug":"POJ-2535-Very-Simple-Problem","date":"2014-08-22T22:04:55.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2535-Very-Simple-Problem/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2535-Very-Simple-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=2535 理解N个评委，P道题目，每个评委对每道题进行评分。对于单个评委来说，如果他评分中的最高分的题目被视为该评委认定的“最困难的题目”，他评分中的最低分的题目被视为该评委认定的“最简单的题目”。对于每一道题，如果没有评委评定为“最困难的题目”，且有超过半数（不等于）的评委评定为“最简单的题目”，则这就可以被认为是“非常简单的题目”。","text":"题目源地址： http://poj.org/problem?id=2535 理解N个评委，P道题目，每个评委对每道题进行评分。对于单个评委来说，如果他评分中的最高分的题目被视为该评委认定的“最困难的题目”，他评分中的最低分的题目被视为该评委认定的“最简单的题目”。对于每一道题，如果没有评委评定为“最困难的题目”，且有超过半数（不等于）的评委评定为“最简单的题目”，则这就可以被认为是“非常简单的题目”。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int N, P;int arr[110];int easy[110];int hard[110];int main(int argc, char const *argv[])&#123; int i, j; int tmp, flag; int min, max; while (scanf(&quot;%d%d&quot;, &amp;N, &amp;P) != EOF) &#123; memset(easy, 0, sizeof(easy)); memset(hard, 0, sizeof(hard)); for (i = 0; i &lt; N; i++) &#123; min = 10000; max = -1; for (j = 0; j &lt; P; j++) &#123; scanf(&quot;%d&quot;, &amp;arr[j]); if (min &gt; arr[j]) &#123; min = arr[j]; &#125; if (max &lt; arr[j]) &#123; max = arr[j]; &#125; &#125; for (j = 0; j &lt; P; j++) &#123; if (arr[j] == min) &#123; easy[j]++; &#125; if (arr[j] == max &amp;&amp; !hard[j]) &#123; hard[j] = 1; &#125; &#125; &#125; flag = 0; for (i = 0; i &lt; P; i++) &#123; if (easy[i] &gt; N / 2 &amp;&amp; hard[i] == 0) &#123; if (flag) &#123; printf(&quot; &quot;); &#125; printf(&quot;%d&quot;, i + 1); flag = 1; &#125; &#125; if (flag == 0) &#123; printf(&quot;0\\n&quot;); &#125; else &#123; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2538 WERTYU","slug":"POJ-2538-WERTYU","date":"2014-08-22T21:44:21.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2538-WERTYU/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2538-WERTYU/","excerpt":"题目源地址： http://poj.org/problem?id=2538 理解键盘错位，分别一一对应即可。做到这道题目的时候才想起来，想当年我把我们家的联想键盘拆了，装回去的时候加减号弄反了。。","text":"题目源地址： http://poj.org/problem?id=2538 理解键盘错位，分别一一对应即可。做到这道题目的时候才想起来，想当年我把我们家的联想键盘拆了，装回去的时候加减号弄反了。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;char str[200];void init()&#123; int i; str[&apos;1&apos;] = &apos;`&apos;; for (i = 2; i &lt;= 10; i++) &#123; str[&apos;0&apos; + i % 10] = &apos;0&apos; + i - 1; &#125; str[&apos;-&apos;] = &apos;0&apos;; str[&apos;=&apos;] = &apos;-&apos;; str[&apos;W&apos;] = &apos;Q&apos;; str[&apos;E&apos;] = &apos;W&apos;; str[&apos;R&apos;] = &apos;E&apos;; str[&apos;T&apos;] = &apos;R&apos;; str[&apos;Y&apos;] = &apos;T&apos;; str[&apos;U&apos;] = &apos;Y&apos;; str[&apos;I&apos;] = &apos;U&apos;; str[&apos;O&apos;] = &apos;I&apos;; str[&apos;P&apos;] = &apos;O&apos;; str[&apos;[&apos;] = &apos;P&apos;; str[&apos;]&apos;] = &apos;[&apos;; str[&apos;\\\\&apos;] = &apos;]&apos;; str[&apos;S&apos;] = &apos;A&apos;; str[&apos;D&apos;] = &apos;S&apos;; str[&apos;F&apos;] = &apos;D&apos;; str[&apos;G&apos;] = &apos;F&apos;; str[&apos;H&apos;] = &apos;G&apos;; str[&apos;J&apos;] = &apos;H&apos;; str[&apos;K&apos;] = &apos;J&apos;; str[&apos;L&apos;] = &apos;K&apos;; str[&apos;;&apos;] = &apos;L&apos;; str[&apos;\\&apos;&apos;] = &apos;;&apos;; str[&apos;X&apos;] = &apos;Z&apos;; str[&apos;C&apos;] = &apos;X&apos;; str[&apos;V&apos;] = &apos;C&apos;; str[&apos;B&apos;] = &apos;V&apos;; str[&apos;N&apos;] = &apos;B&apos;; str[&apos;M&apos;] = &apos;N&apos;; str[&apos;,&apos;] = &apos;M&apos;; str[&apos;.&apos;] = &apos;,&apos;; str[&apos;/&apos;] = &apos;.&apos;;&#125;int main(int argc, char const *argv[])&#123; char ch; init(); while ((ch = getchar()) != EOF) &#123; if (ch != &apos; &apos; &amp;&amp; ch != &apos;\\n&apos;) &#123; putchar(str[ch]); &#125; else &#123; putchar(ch); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2562 Primary Arithmetic","slug":"POJ-2562-Primary-Arithmetic","date":"2014-08-22T21:41:23.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2562-Primary-Arithmetic/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2562-Primary-Arithmetic/","excerpt":"题目源地址： http://poj.org/problem?id=2562 理解高精度的模拟加法进位，数组模拟之。","text":"题目源地址： http://poj.org/problem?id=2562 理解高精度的模拟加法进位，数组模拟之。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;char num1[20];char num2[20];int main(int argc, char const *argv[])&#123; int add, tmp; int carry; int i, j; int len1, len2; while (scanf(&quot;%s %s&quot;, num1, num2), strcmp(num1, &quot;0&quot;) != 0 || strcmp(num2, &quot;0&quot;) != 0)&#123; getchar(); len1 = strlen(num1); len2 = strlen(num2); for (carry = add = 0, i = len1 - 1, j = len2 - 1 ; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--)&#123; if ((num1[i] - &apos;0&apos;) + (num2[j] - &apos;0&apos;) + add &gt;= 10)&#123; add = 1; carry ++; &#125; else&#123; add = 0; &#125; &#125; for (; i &gt;= 0; i--)&#123; if (num1[i] - &apos;0&apos; + add &gt;= 10)&#123; carry++; add = 1; &#125; else &#123; add = 0; &#125; &#125; for (; j &gt;= 0; j--)&#123; if (num2[j] - &apos;0&apos; + add &gt;= 10)&#123; carry++; add = 1; &#125; else &#123; add = 0; &#125; &#125; if (carry == 0)&#123; printf(&quot;No carry operation.\\n&quot;); &#125; else if (carry == 1)&#123; printf(&quot;1 carry operation.\\n&quot;); &#125; else&#123; printf(&quot;%d carry operations.\\n&quot;, carry); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2575 Jolly Jumpers","slug":"POJ-2575-Jolly-Jumpers","date":"2014-08-22T21:37:59.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2575-Jolly-Jumpers/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2575-Jolly-Jumpers/","excerpt":"题目源地址： http://poj.org/problem?id=2575 理解又是一道已经A过的题目，咦，都是什么时候做的啊？","text":"题目源地址： http://poj.org/problem?id=2575 理解又是一道已经A过的题目，咦，都是什么时候做的啊？ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int num; while (cin &gt;&gt; num) &#123; int i; int *Jump = (int *)malloc(sizeof(int) * num); bool *flag = (bool *)malloc(sizeof(bool) * num); memset(flag, false, sizeof(bool)*num); for (int j = 0; j &lt; num; j++) &#123; cin &gt;&gt; Jump[j]; &#125; for (i = 1; i &lt; num; i++) &#123; int tmp; tmp = abs(Jump[i] - Jump[i - 1]); if (flag[tmp]) &#123; break; &#125; flag[tmp] = true; &#125; if (i == num) &#123; cout &lt;&lt; &quot;Jolly&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Not jolly&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2579 Blurred Vision","slug":"POJ-2579-Blurred-Vision","date":"2014-08-22T21:35:15.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2579-Blurred-Vision/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2579-Blurred-Vision/","excerpt":"题目源地址： http://poj.org/problem?id=2579 理解对于一个RC的矩阵，输出矩阵中每一个22的小方格四个值的平均值（向下取整）。挨个遍历即可，注意边界。","text":"题目源地址： http://poj.org/problem?id=2579 理解对于一个RC的矩阵，输出矩阵中每一个22的小方格四个值的平均值（向下取整）。挨个遍历即可，注意边界。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int arr[10][10];char sign[3][20] = &#123;&quot;START&quot;, &quot;END&quot;, &quot;ENDOFINPUT&quot;&#125;;int main(void)&#123; int i, j; int r, c; int ave; char tmp[20]; while (scanf(&quot;%s&quot;, tmp), strcmp(tmp, sign[2])) &#123; memset(arr, 0, sizeof(arr)); scanf(&quot;%d%d&quot;, &amp;r, &amp;c); getchar(); for (i = 0; i &lt; r; i++) &#123; for (j = 0; j &lt; c; j++) &#123; arr[i][j] = getchar() - &apos;0&apos;; &#125; getchar(); &#125; for (i = 1; i &lt; r; i++) &#123; for (j = 1; j &lt; c; j++) &#123; ave = arr[i][j] + arr[i - 1][j] + arr[i][j - 1] + arr[i - 1][j - 1]; printf(&quot;%d&quot;, ave / 4); &#125; printf(&quot;\\n&quot;); &#125; scanf(&quot;%s&quot;, tmp); getchar(); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2636 Electrical Outlets","slug":"POJ-2636-Electrical-Outlets","date":"2014-08-22T21:32:53.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2636-Electrical-Outlets/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2636-Electrical-Outlets/","excerpt":"题目源地址： http://poj.org/problem?id=2636 理解今天做的时候发现2636.cpp文件已经存在了，有点神奇= =，改了一下头文件，直接提交了。","text":"题目源地址： http://poj.org/problem?id=2636 理解今天做的时候发现2636.cpp文件已经存在了，有点神奇= =，改了一下头文件，直接提交了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int N, K, O, ans; int i; scanf(&quot;%d&quot;, &amp;N); while (N--) &#123; ans = 0; scanf(&quot;%d&quot;, &amp;K); for (i = 0; i &lt; K; i++) &#123; scanf(&quot;%d&quot;, &amp;O); ans += O; &#125; printf(&quot;%d\\n&quot;, ans - K + 1); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2664 Prerequisites?","slug":"POJ-2664-Prerequisites","date":"2014-08-22T21:30:44.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-2664-Prerequisites/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2664-Prerequisites/","excerpt":"题目源地址： http://poj.org/problem?id= 理解将已经选择的课程标记下来，然后对于每一个类别分别进行验证是否已经符合了要求。","text":"题目源地址： http://poj.org/problem?id= 理解将已经选择的课程标记下来，然后对于每一个类别分别进行验证是否已经符合了要求。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int arr[10010];int main(int argc, char const *argv[])&#123; int k, c; int num, need, tmp, taken; int flag; int i, j; while (scanf(&quot;%d&quot;, &amp;k), k != 0) &#123; memset(arr, 0, sizeof(arr)); scanf(&quot;%d&quot;, &amp;c); for (i = 0; i &lt; k; i++) &#123; scanf(&quot;%d&quot;, &amp;tmp); arr[tmp] = 1; &#125; flag = 1; for (i = 0; i &lt; c; i++) &#123; scanf(&quot;%d%d&quot;, &amp;num, &amp;need); for (j = taken = 0; j &lt; num; j++) &#123; scanf(&quot;%d&quot;, &amp;tmp); if (arr[tmp] == 1) &#123; taken ++; &#125; &#125; if (taken &lt; need) &#123; flag = 0; &#125; &#125; if (flag) &#123; printf(&quot;yes\\n&quot;); &#125; else &#123; printf(&quot;no\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3006 Dirichlet's Theorem on Arithmetic Progressions","slug":"POJ-3006-Dirichlet's-Theorem-on-Arithmetic-Progressions","date":"2014-08-22T18:13:27.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-3006-Dirichlet's-Theorem-on-Arithmetic-Progressions/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3006-Dirichlet's-Theorem-on-Arithmetic-Progressions/","excerpt":"题目源地址： http://poj.org/problem?id=3006 理解筛法打素数表，然后暴力得到这些数字，判断是否为素数，若是则次数times+1,直到得到第n个素数。","text":"题目源地址： http://poj.org/problem?id=3006 理解筛法打素数表，然后暴力得到这些数字，判断是否为素数，若是则次数times+1,直到得到第n个素数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define N 1000000int prime[N];void init()&#123; int i, j, k; for (i = 0; i &lt; N; i++) &#123; prime[i] = 1; &#125; prime[0] = 0; prime[1] = 0; for (i = 0; i &lt; N; i++) &#123; if (prime[i] != 0) &#123; for (j = i + i; j &lt; N; j += i) &#123; prime[j] = 0; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; int a, d, n; int times, i, tmp; init(); while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;d, &amp;n), a != 0 || d != 0 || n != 0) &#123; times = 0; for (i = a; i &lt; 1000000 &amp;&amp; times != n; i += d) &#123; if (prime[i] != 0) &#123; times++; tmp = i; &#125; &#125; printf(&quot;%d\\n&quot;, tmp); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3077 Rounders","slug":"POJ-3077-Rounders","date":"2014-08-22T17:52:36.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-3077-Rounders/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3077-Rounders/","excerpt":"题目源地址： http://poj.org/problem?id=3077 理解咦，居然又碰到一道高精度的题目，Java水过。","text":"题目源地址： http://poj.org/problem?id=3077 理解咦，居然又碰到一道高精度的题目，Java水过。 代码import java.math.BigInteger;import java.util.*;public class Main &#123; public static void main(String args[]) &#123; int n, s, i; Scanner cin = new Scanner( System.in ); n = cin.nextInt(); while ( n-- != 0 ) &#123; s = cin.nextInt(); for ( i = 10; i &lt;= 100000000; i *= 10 ) if ( s &gt;= i ) &#123; s = (s + i / 2) / i * i; &#125; System.out.println( s ); &#125; return; &#125;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3183 Stump Removal","slug":"POJ-3183-Stump-Removal","date":"2014-08-22T17:31:04.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-3183-Stump-Removal/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3183-Stump-Removal/","excerpt":"题目源地址： http://poj.org/problem?id=3183 理解只要找到比两边大的小高峰即可，注意特殊情况的判断，比如在最开始和最后面。","text":"题目源地址： http://poj.org/problem?id=3183 理解只要找到比两边大的小高峰即可，注意特殊情况的判断，比如在最开始和最后面。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n; int i, j; int flag; int now, last, next; scanf(&quot;%d&quot;, &amp;n); last = -1, now = 0; for (i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;next); if (last &lt;= now &amp;&amp; now &gt;= next) &#123; printf(&quot;%d\\n&quot;, i - 1); &#125; last = now; now = next; &#125; if (now &gt;= last) &#123; printf(&quot;%d\\n&quot;, i - 1); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3300 Tour de France","slug":"POJ-3300-Tour-de-France","date":"2014-08-22T17:24:38.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-3300-Tour-de-France/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3300-Tour-de-France/","excerpt":"题目源地址： http://poj.org/problem?id=3300 理解好多轮子= =。计算前后轮的齿轮比，再进行排序，找到前一种比后一种最大的那个。","text":"题目源地址： http://poj.org/problem?id=3300 理解好多轮子= =。计算前后轮的齿轮比，再进行排序，找到前一种比后一种最大的那个。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int rear[15];int front[15];float dratio[300];int main(int argc, char const *argv[])&#123; int f, r; int i, j, k; float max, tmp; while (scanf(&quot;%d&quot;, &amp;f), f != 0) &#123; memset(dratio, 0, sizeof(dratio)); memset(rear, 0, sizeof(rear)); memset(front, 0, sizeof(front)); scanf(&quot;%d&quot;, &amp;r); for (i = 0; i &lt; f; i++) &#123; scanf(&quot;%d&quot;, &amp;front[i]); &#125; for (i = k = 0, max = -1; i &lt; r; i++) &#123; scanf(&quot;%d&quot;, &amp;rear[i]); for (j = 0; j &lt; f; j++) &#123; dratio[k++] = (float)rear[i] / (float)front[j]; &#125; &#125; sort(dratio, dratio + k); max = -1; for (i = 0; i &lt; k - 1 ; i++) &#123; tmp = dratio[i + 1] / dratio[i]; if (tmp &gt; max) &#123; max = tmp; &#125; &#125; printf(&quot;%.2f\\n&quot;, max); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3302 Subsequence","slug":"POJ-3302-Subsequence","date":"2014-08-22T17:21:34.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/22/POJ-3302-Subsequence/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3302-Subsequence/","excerpt":"题目源地址： http://poj.org/problem?id=3302 理解直接用一个循环，遍历str1，与str2进行单字符匹配，如果匹配成功就count++。如果count==strlen(str1),则输出YES，遍历正序、逆序各一次，都没有则输出NO。","text":"题目源地址： http://poj.org/problem?id=3302 理解直接用一个循环，遍历str1，与str2进行单字符匹配，如果匹配成功就count++。如果count==strlen(str1),则输出YES，遍历正序、逆序各一次，都没有则输出NO。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;char str1[110];char str2[110];int main(int argc, char const *argv[])&#123; int ii, casenum; int count; int len1, len2; int i, j; int flag; scanf(&quot;%d&quot;, &amp;casenum); getchar(); for (ii = 0; ii &lt; casenum; ii++) &#123; scanf(&quot;%s%s&quot;, str1, str2); len1 = strlen(str1); len2 = strlen(str2); flag = 0; for (i = j = count = 0; !flag &amp;&amp; j &lt; len1; j++) &#123; if (str1[j] == str2[i]) &#123; count++; i++; &#125; if (count == len2) &#123; flag = 1; &#125; &#125; for (count = i = 0, j = len1 - 1; !flag &amp;&amp; j &gt;= 0; j--) &#123; if (str1[j] == str2[i]) &#123; count++; i++; &#125; if (count == len2) &#123; flag = 1; &#125; &#125; if (flag) &#123; printf(&quot;YES\\n&quot;); &#125; else &#123; printf(&quot;NO\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3325 ICPC Score Totalizer Software","slug":"POJ-3325-ICPC-Score-Totalizer-Software","date":"2014-08-22T17:18:27.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/22/POJ-3325-ICPC-Score-Totalizer-Software/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-3325-ICPC-Score-Totalizer-Software/","excerpt":"题目源地址： http://poj.org/problem?id=3325 理解去掉一个最高分，一个最低分，求平均值。小学的时候经常做这样的题目- -","text":"题目源地址： http://poj.org/problem?id=3325 理解去掉一个最高分，一个最低分，求平均值。小学的时候经常做这样的题目- - 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int max, min, tmp; int n, sum; int i, j; while (scanf(&quot;%d&quot;, &amp;n), n != 0) &#123; min = 1001; max = -1; for (i = sum = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;tmp); if (tmp &lt; min) &#123; min = tmp; &#125; if (tmp &gt; max) &#123; max = tmp; &#125; sum += tmp; &#125; sum -= (max + min); printf(&quot;%d\\n&quot;, sum / (n - 2)); &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2251 Dungeon Master","slug":"POJ-2251-Dungeon-Master","date":"2014-08-22T09:23:20.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/22/POJ-2251-Dungeon-Master/","link":"","permalink":"https://xuanwo.org/2014/08/22/POJ-2251-Dungeon-Master/","excerpt":"题目源地址： http://poj.org/problem?id=2251 理解拖了好久的三维BFS题。天真的觉得pair类可以直接扩展到三维中去，结果编译器直接报了错，可惜了那么多的代码，全都要推倒重来了。借鉴了某个神牛的写法，特别是在输入上面，顿时感觉以前的处理方法姿势太不优美了。做这类题目的时候，经常有一个困扰就是我的记步器如何实现，从前都是单独设一个steps这样的变量，现在看来，每一个点设一个可能更好理解一点。","text":"题目源地址： http://poj.org/problem?id=2251 理解拖了好久的三维BFS题。天真的觉得pair类可以直接扩展到三维中去，结果编译器直接报了错，可惜了那么多的代码，全都要推倒重来了。借鉴了某个神牛的写法，特别是在输入上面，顿时感觉以前的处理方法姿势太不优美了。做这类题目的时候，经常有一个困扰就是我的记步器如何实现，从前都是单独设一个steps这样的变量，现在看来，每一个点设一个可能更好理解一点。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define MAXN 35using namespace std;#define MAX_NUM 31class Node&#123;public: int l, r, c; int time;public: bool operator==(const Node &amp;rhs) const &#123; return l == rhs.l &amp;&amp; r == rhs.r &amp;&amp; c == rhs.c; &#125;&#125;;int layer, row, col;Node start, end;bool dic[MAX_NUM][MAX_NUM][MAX_NUM];bool flag[MAX_NUM][MAX_NUM][MAX_NUM];int steps[6][3] = &#123; &#123;0, 0, 1&#125;, &#123;0, 0, -1&#125;, &#123;0, 1, 0&#125;, &#123;0, -1, 0&#125;, &#123;1, 0, 0&#125;, &#123; -1, 0, 0&#125; &#125;;bool CheckValid(const Node &amp;node)&#123; int l = node.l, r = node.r, c = node.c; if (l &gt;= 0 &amp;&amp; l &lt; layer &amp;&amp; r &gt;= 0 &amp;&amp; r &lt; row &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; col &amp;&amp; dic[l][r][c]) &#123; return true; &#125; return false;&#125;int TBFS()&#123; int i; queue&lt;Node&gt; q; q.push(start); flag[start.l][start.r][start.c] = 1; while (!q.empty()) &#123; Node tmp = q.front(); q.pop(); for (i = 0; i &lt; 6; ++i) &#123; Node node = tmp; node.l += steps[i][0]; node.r += steps[i][1]; node.c += steps[i][2]; if (CheckValid(node) &amp;&amp; !flag[node.l][node.r][node.c]) &#123; ++node.time; flag[node.l][node.r][node.c] = 1; q.push(node); if (node == end) &#123; return node.time; &#125; &#125; &#125; &#125; return 0;&#125;int main(int argc, char const *argv[])&#123; int i, j, k; char ch; while (1) &#123; Node tmp; scanf (&quot;%d %d %d%*c&quot;, &amp;layer, &amp;row, &amp;col); //注意这里的一个小小细节，%*c用来忽略输入后面的那个回车，学习了。 if (!layer &amp;&amp; !row &amp;&amp; !col) break; for (i = 0; i &lt; layer; ++i) &#123; for (j = 0; j &lt; row; ++j) &#123; for (k = 0; k &lt; col; ++k) &#123; ch = getchar(); if (ch == &apos;#&apos;) &#123; dic[i][j][k] = 0; &#125; else if (ch == &apos;.&apos;) &#123; dic[i][j][k] = 1; &#125; else if (ch == &apos;S&apos;) &#123; start.l = i; start.r = j; start.c = k; start.time = 0; dic[i][j][k] = 1; &#125; else if (ch == &apos;E&apos;) &#123; end.l = i; end.r = j; end.c = k; end.time = 0; dic[i][j][k] = 1; &#125; &#125; getchar (); &#125; getchar (); &#125; memset(flag, 0, sizeof(flag)); int ret = TBFS(); if (ret) &#123; printf (&quot;Escaped in %d minute(s).\\n&quot;, ret); &#125; else &#123; printf (&quot;Trapped!\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3982 序列","slug":"POJ-3982-Sequence","date":"2014-08-21T23:47:20.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3982-Sequence/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3982-Sequence/","excerpt":"题目源地址： http://poj.org/problem?id=3982 理解题意非常清晰，唯一的问题在于大数的实现。","text":"题目源地址： http://poj.org/problem?id=3982 理解题意非常清晰，唯一的问题在于大数的实现。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define TT 106int a[TT], b[TT], c[TT];void solve()&#123; int TIME = 99; while (TIME -- ) &#123; for (int i = 0; i &lt; TT; ++i) &#123; a[i] += b[i] + c[i]; if (a[i] &gt; 9) &#123; a[i + 1] += a[i] / 10; a[i] %= 10; &#125; &#125; for (int i = 0; i &lt; TT; ++i) &#123; int tmp = a[i]; a[i] = b[i]; b[i] = c[i]; c[i] = tmp; &#125; &#125; TIME = TT; while (!a[TIME--]); for (int i = TIME + 1; i &gt;= 0; --i) printf(&quot;%d&quot;, a[i]); printf(&quot;\\n&quot;);&#125;void init(int x, int y, int z)&#123; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); int i = 0; while (x &gt; 0) &#123; a[i++] = x % 10; x /= 10; &#125; i = 0; while (y &gt; 0) &#123; b[i++] = y % 10; y /= 10; &#125; i = 0; while (z &gt; 0) &#123; c[i++] = z % 10; z /= 10; &#125;&#125;int main(int argc, char const *argv[])&#123; int x, y, z; while (~scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z)) &#123; init(x, y, z); solve(); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3979 分数加减法","slug":"POJ-3979-Divides-Plus-and-Minus","date":"2014-08-21T23:37:02.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3979-Divides-Plus-and-Minus/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3979-Divides-Plus-and-Minus/","excerpt":"题目源地址： http://poj.org/problem?id=3979 理解简单的分数问题，注意上下约分。","text":"题目源地址： http://poj.org/problem?id=3979 理解简单的分数问题，注意上下约分。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int gcd(int a, int b)&#123; if (b == 0) return a; return gcd(b, a % b);&#125;int lcm(int a, int b)&#123; int c = gcd(a, b); return a * b / c;&#125;int main(int argc, char const *argv[])&#123; int a, b, c, d; char ch; while (scanf(&quot;%d/%d%c%d/%d&quot;, &amp;a, &amp;b, &amp;ch, &amp;c, &amp;d) != EOF) &#123; int m = lcm(b, d); int n; if (ch == &apos;+&apos;) n = a * (m / b) + c * (m / d); else n = a * (m / b) - c * (m / d); if (n == 0) printf(&quot;0\\n&quot;); else &#123; int t = gcd(m, n); n = n / t; m = m / t; if (m &lt; 0) m = -m, n = -n; if (m == 1) printf(&quot;%d\\n&quot;, n); else printf(&quot;%d/%d\\n&quot;, n, m); &#125; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3980 取模运算","slug":"POJ-3980-Mod","date":"2014-08-21T23:31:30.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3980-Mod/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3980-Mod/","excerpt":"题目源地址： http://poj.org/problem?id=3980 理解给定两个数，求他们的模。","text":"题目源地址： http://poj.org/problem?id=3980 理解给定两个数，求他们的模。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int mod(int n, int m)&#123; return n % m;&#125;int main(int argc, char const *argv[])&#123; int N, M; while ((scanf(&quot;%d%d&quot;, &amp;N, &amp;M)) != EOF) &#123; printf(&quot;%d\\n&quot;, mod(N, M)); &#125; //system(&quot;pause&quot;); return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3750 小孩报数问题","slug":"POJ-3750-Kid-Counting","date":"2014-08-21T22:26:15.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3750-Kid-Counting/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3750-Kid-Counting/","excerpt":"题目源地址： http://poj.org/problem?id=3750 理解中文题- -，用队列来搞定～","text":"题目源地址： http://poj.org/problem?id=3750 理解中文题- -，用队列来搞定～ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;queue&lt;string&gt;q;int main(int argc, char const *argv[])&#123; int a, b, n; scanf(&quot;%d&quot;, &amp;n); while (n--) &#123; string tmp; cin &gt;&gt; tmp; q.push(string(tmp)); &#125; scanf(&quot;%d,%d&quot;, &amp;a, &amp;b); for (int i = 1; i &lt; a; i++) &#123; q.push(q.front()); q.pop(); &#125; while (!q.empty()) &#123; for (int i = 1; i &lt; b; i++) &#123; q.push(q.front()); q.pop(); &#125; cout &lt;&lt; q.front() &lt;&lt; endl, q.pop(); &#125;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3749 破译密码","slug":"POJ-3749-Break-Password","date":"2014-08-21T22:08:38.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3749-Break-Password/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3749-Break-Password/","excerpt":"题目源地址： http://poj.org/problem?id=3749 理解将一个字符串按照一定的规则转化，中文题，不多说了。。","text":"题目源地址： http://poj.org/problem?id=3749 理解将一个字符串按照一定的规则转化，中文题，不多说了。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; char str[201]; char str2[7]; while (gets(str2), strcmp(str2, &quot;ENDOFINPUT&quot;) != 0) &#123; memset(str, &apos;\\0&apos;, sizeof(str)); gets(str); for (int i = 0; str[i] != &apos;\\0&apos;; i++) &#123; if (str[i] &gt;= &apos;F&apos; &amp;&amp; str[i] &lt;= &apos;Z&apos;) str[i] -= 5; else if (str[i] &gt;= &apos;A&apos; &amp;&amp; str[i] &lt; &apos;F&apos;) str[i] += 21; &#125; gets(str2); cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3673 Cow Multiplication","slug":"POJ-3673-Cow-Multiplication","date":"2014-08-21T21:59:04.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/21/POJ-3673-Cow-Multiplication/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3673-Cow-Multiplication/","excerpt":"题目源地址： http://poj.org/problem?id=3673 理解按照题意初始化，并运算即可。","text":"题目源地址： http://poj.org/problem?id=3673 理解按照题意初始化，并运算即可。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define MAX 300int main(int argc, char const *argv[])&#123; char input[MAX]; cin.getline(input, MAX); int count = 0; char *a , *b; a = strtok(input, &quot; &quot;); b = strtok(NULL, &quot; &quot;); for (int i = 0; i &lt; strlen(a); i++) &#123; for (int j = 0; j &lt; strlen(b); j++) &#123; count += (a[i] - &apos;0&apos;) * (b[j] - &apos;0&apos;); &#125; &#125; printf(&quot;%d\\n&quot;, count); return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3196 Babylonian Roulette","slug":"POJ-3196-Babylonian-Roulette","date":"2014-08-21T20:02:37.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3196-Babylonian-Roulette/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3196-Babylonian-Roulette/","excerpt":"题目源地址： http://poj.org/problem?id=3196 理解好长的题目- -，是一个关于赌博的问题。给你三个数pot，bet，fpot，分别代表初始金额，赌注金额，封盘金额，每次加钱可能是赌注的-1，-2，-3，1，2，3倍，求最少多少次可以到达封盘金额。","text":"题目源地址： http://poj.org/problem?id=3196 理解好长的题目- -，是一个关于赌博的问题。给你三个数pot，bet，fpot，分别代表初始金额，赌注金额，封盘金额，每次加钱可能是赌注的-1，-2，-3，1，2，3倍，求最少多少次可以到达封盘金额。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int pot; int bet; int fpot; while (scanf(&quot;%d%d%d&quot;, &amp;pot, &amp;bet, &amp;fpot) != -1, pot + bet + fpot) &#123; if (pot &gt; fpot)pot -= fpot; else pot = fpot - pot; if (pot % bet != 0) printf(&quot;No accounting tablet\\n&quot;); else &#123; pot = pot / bet; int ans; ans = 0; ans += pot / 3; pot %= 3; ans += pot / 2, pot %= 2; ans += pot; printf(&quot;%d\\n&quot;, ans); &#125; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3125 Printer Queue","slug":"POJ-3125-Printer-Queue","date":"2014-08-21T19:43:07.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3125-Printer-Queue/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3125-Printer-Queue/","excerpt":"题目源地址： http://poj.org/problem?id=3125 理解打印队列，看名字都感觉是队列的经典应用，不过没有使用STL，而是模拟了一个。","text":"题目源地址： http://poj.org/problem?id=3125 理解打印队列，看名字都感觉是队列的经典应用，不过没有使用STL，而是模拟了一个。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int a[10010]; int front, rear, i; int cases, n, d, time, ok; scanf(&quot;%d&quot;, &amp;cases); while (cases--) &#123; front = 0; rear = 0; time = 0; ok = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;d); for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); rear++; &#125; while (front &lt;= rear) &#123; for (i = front; i &lt; rear; i++) &#123; if (a[i] &gt; a[front]) &#123; a[rear++] = a[front]; break; &#125; &#125; if (i &gt;= rear) &#123; time += 1; if (front == d) &#123; printf(&quot;%d\\n&quot;, time); ok = 1; break; &#125; else front++; &#125; else if (front == d) &#123; d = rear - 1; &#125; else front++; if (ok) break; &#125; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3104 Drying","slug":"POJ-3104-Drying","date":"2014-08-21T19:23:22.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3104-Drying/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3104-Drying/","excerpt":"题目源地址： http://poj.org/problem?id=3104 理解感觉是一道模拟的题目，使用二分来优化时间。","text":"题目源地址： http://poj.org/problem?id=3104 理解感觉是一道模拟的题目，使用二分来优化时间。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int N = 100005;int n;int a[N];int k;bool check(int _value)&#123; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; if (a[i] &gt; _value) &#123; double kk = ((double)(a[i] - _value)) / (k - 1); cnt += (int)kk; if (kk - (int)kk &gt; 0) &#123; ++cnt; &#125; if (cnt &gt; _value) &#123; return false; &#125; &#125; &#125; return (cnt &lt;= _value);&#125;int BinarySearch(int _low, int _high)&#123; int left = _low; int right = _high; int mid; int ans = _high; while (left &lt;= right) &#123; mid = (left + (right - left) * 0.5); if (check(mid)) &#123; ans = mid; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return ans;&#125;void Test()&#123; int maxV = 0; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); if (maxV &lt; a[i]) &#123; maxV = a[i]; &#125; &#125; scanf(&quot;%d&quot;, &amp;k); if (k == 1) &#123; printf(&quot;%d\\n&quot;, maxV); &#125; else printf(&quot;%d\\n&quot;, BinarySearch(0, maxV));&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; Test(); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3157 Java vs C++","slug":"POJ-3157-Java-vs-C++","date":"2014-08-21T19:16:49.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3157-Java-vs-C++/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3157-Java-vs-C++/","excerpt":"题目源地址： http://poj.org/problem?id=3157 理解这是我们在周赛上面做过的题目，WA了无数发，深感自己智商不够——我把input和output里面的sample input #1也处理进去了，每个结果都跟一个sample output #1，能A就有鬼了。看了discuss之后，真恨不得抽自己嘴巴子。。","text":"题目源地址： http://poj.org/problem?id=3157 理解这是我们在周赛上面做过的题目，WA了无数发，深感自己智商不够——我把input和output里面的sample input #1也处理进去了，每个结果都跟一个sample output #1，能A就有鬼了。看了discuss之后，真恨不得抽自己嘴巴子。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int n, m, i, j, c, k, l, p;char a[110], b[110];int flag;int main(int argc, char const *argv[])&#123; while (~scanf(&quot;%s&quot;, a)) &#123; p = c = j = 0; k = 1; for (i = 0; i &lt; 110; i++) &#123; b[i] = &apos;\\0&apos;; &#125; if (a[0] &lt; &apos;a&apos; || a[0] &gt; &apos;z&apos;) &#123; p = 1; &#125; l = strlen(a); b[0] = a[0]; for (i = 1; i &lt; l; i++) &#123; if (a[i] &gt;= &apos;a&apos; &amp;&amp; a[i] &lt;= &apos;z&apos;) &#123; b[k] = a[i]; k++; &#125; else if (a[i] == &apos;_&apos;) &#123; if (j == 1) &#123; p = 1; break; &#125; if (a[i + 1] &gt;= &apos;a&apos; &amp;&amp; a[i + 1] &lt;= &apos;z&apos;) &#123; b[k] = a[i + 1] + &apos;A&apos; - &apos;a&apos;; i++; k++; &#125; else &#123; p = 1; break; &#125; c = 1; &#125; else if (a[i] &gt;= &apos;A&apos; &amp;&amp; a[i] &lt;= &apos;Z&apos;) &#123; if (c == 1) &#123; p = 1; break; &#125; b[k] = &apos;_&apos;; k++; b[k] = a[i] - (&apos;A&apos; - &apos;a&apos;); k++; j = 1; &#125; else &#123; p = 1; break; &#125; &#125; if (p == 1) &#123; printf(&quot;Error!\\n&quot;); &#125; else &#123; printf(&quot;%s\\n&quot;, b); &#125; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3117 World Cup","slug":"POJ-3117-World-Cup","date":"2014-08-21T18:47:38.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3117-World-Cup/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3117-World-Cup/","excerpt":"题目源地址： http://poj.org/problem?id=3117 理解如果所有的队伍作为一个整体，有胜负的比赛总分+3分，如果是平局总分+2分。所以平局数量是：所有比赛均有胜负的总分减去当前总分的分值，即：3 * N - SUM。","text":"题目源地址： http://poj.org/problem?id=3117 理解如果所有的队伍作为一个整体，有胜负的比赛总分+3分，如果是平局总分+2分。所以平局数量是：所有比赛均有胜负的总分减去当前总分的分值，即：3 * N - SUM。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int T, N; int i; char name[20]; int num, sum; while (scanf(&quot;%d%d&quot;, &amp;T, &amp;N), T != 0 || N != 0) &#123; getchar(); for (i = sum = 0; i &lt; T; i++) &#123; scanf(&quot;%s%d&quot;, name, &amp;num); getchar(); sum += num; &#125; printf(&quot;%d\\n&quot;, 3 * N - sum); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3173 Parkside's Triangle","slug":"POJ-3173-Parkside's-Triangle","date":"2014-08-21T18:40:11.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3173-Parkside's-Triangle/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3173-Parkside's-Triangle/","excerpt":"题目源地址： http://poj.org/problem?id=3173 理解生成这样一个表并不难，但是需要注意格式的控制。","text":"题目源地址： http://poj.org/problem?id=3173 理解生成这样一个表并不难，但是需要注意格式的控制。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int MAX = 25;int triangle[MAX][MAX];int main(int argc, char const *argv[])&#123; int n, s, i, j, k; bool flag = false; cin &gt;&gt; n &gt;&gt; s; for (i = 0; i &lt;= n; i++) &#123; for (j = 0; j &lt;= i; j++) &#123; triangle[j][i] = s; s++; if (s % 10 != 0) &#123; s %= 10; &#125; else (++s) %= 10; &#125; &#125; for (i = 0; i &lt; n; i++) &#123; flag = false; for (k = 0; k &lt; i; k++) &#123; cout &lt;&lt; &quot; &quot;; &#125; for (j = 0; j &lt; n; j++) &#123; if (triangle[i][j] != 0) &#123; if (flag) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; triangle[i][j]; flag = true; &#125; else &#123; cout &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3100 Root of the Problem","slug":"POJ-3100-Root-of-the-Problem","date":"2014-08-21T18:36:21.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3100-Root-of-the-Problem/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3100-Root-of-the-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=3100 理解给定B，N，求出，最接近B的N次方根的整数。","text":"题目源地址： http://poj.org/problem?id=3100 理解给定B，N，求出，最接近B的N次方根的整数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; double b, n, temp; while ( cin &gt;&gt; b &gt;&gt; n &amp;&amp; b &amp;&amp; n ) &#123; temp = pow(b, 1 / n); int x = (int)temp; int y = (int)(temp + 0.5); if ( b - pow(x, n) &gt; pow(y, n) - b ) cout &lt;&lt; y &lt;&lt; endl; else cout &lt;&lt; x &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3176 Cow Bowling","slug":"POJ-3176-Cow-Bowling","date":"2014-08-21T18:30:38.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3176-Cow-Bowling/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3176-Cow-Bowling/","excerpt":"题目源地址： http://poj.org/problem?id=3176 理解简单的DP，状态转移方程为：f[i][j]=w[i][j]+max(f[i+1][j],f[i+1][j+1]);","text":"题目源地址： http://poj.org/problem?id=3176 理解简单的DP，状态转移方程为：f[i][j]=w[i][j]+max(f[i+1][j],f[i+1][j+1]); 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char const *argv[])&#123; int i, j, n, w[355][355], f[355][355]; cin &gt;&gt; n; for (i = 0; i &lt; n; i++) &#123; for (j = 0; j &lt;= i; j++) cin &gt;&gt; w[i][j]; &#125; for (i = 0; i &lt; n; i++) f[n - 1][i] = w[n - 1][i]; for (i = n - 2; i &gt;= 0; i--) &#123; for (j = 0; j &lt;= i; j++) f[i][j] = w[i][j] + max(f[i + 1][j], f[i + 1][j + 1]); &#125; cout &lt;&lt; f[0][0] &lt;&lt; endl; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3085 Quick Change","slug":"POJ-3085-Quick-Change","date":"2014-08-21T18:28:06.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3085-Quick-Change/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3085-Quick-Change/","excerpt":"题目源地址： http://poj.org/problem?id=3085 理解找零钱，使用贪心来做～","text":"题目源地址： http://poj.org/problem?id=3085 理解找零钱，使用贪心来做～ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n; cin &gt;&gt; n; int i = 1; while (n--) &#123; int num1, num2, num3, num4; num1 = num2 = num3 = num4 = 0; int c; cin &gt;&gt; c; if (c &gt;= 25) &#123; num1 = c / 25; c = c % 25; &#125; if (c &gt;= 10 &amp;&amp; c &lt; 25) &#123; num2 = c / 10; c = c % 10; &#125; if (c &gt;= 5 &amp;&amp; c &lt; 10) &#123; num3 = c / 5; c = c % 5; &#125; if (c &lt; 5 &amp;&amp; c &gt; 0) num4 = c; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; num1 &lt;&lt; &quot; QUARTER(S), &quot; &lt;&lt; num2 &lt;&lt; &quot; DIME(S), &quot; &lt;&lt; num3 &lt;&lt; &quot; NICKEL(S), &quot; &lt;&lt; num4 &lt;&lt; &quot; PENNY(S)&quot; &lt;&lt; endl; i++; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3086 Triangular Sums","slug":"POJ-3086-Triangular-Sums","date":"2014-08-21T10:06:22.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3086-Triangular-Sums/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3086-Triangular-Sums/","excerpt":"题目源地址： http://poj.org/problem?id=3086 理解三角数求和，打表输出。","text":"题目源地址： http://poj.org/problem?id=3086 理解三角数求和，打表输出。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int T[310];int W[310];void init()&#123; int i, j; memset(W, 0, sizeof(W)); T[1] = 1; for (i = 2; i &lt;= 304; i++) &#123; T[i] = T[i - 1] + i; &#125; W[1] = T[2]; for (i = 2; i &lt;= 303; i++) &#123; W[i] = W[i - 1] + i * T[i + 1]; &#125;&#125;int main(int argc, char const *argv[])&#123; int ii, casenum; int n; init(); scanf(&quot;%d&quot;, &amp;casenum); for (ii = 1; ii &lt;= casenum; ii++) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%d %d %d\\n&quot;, ii, n, W[n]); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3062 Celebrity jeopardy","slug":"POJ-3062-Celebrity-jeopardy","date":"2014-08-21T10:00:09.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3062-Celebrity-jeopardy/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3062-Celebrity-jeopardy/","excerpt":"题目源地址： http://poj.org/problem?id=3062 理解我对这个充满恶意的世界感到了深深的绝望TnT。原样输出之。。。","text":"题目源地址： http://poj.org/problem?id=3062 理解我对这个充满恶意的世界感到了深深的绝望TnT。原样输出之。。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; char ch; while ((ch = getchar()) != EOF) &#123; putchar(ch); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3030 Nasty Hacks","slug":"POJ-3030-Nasty-Hacks","date":"2014-08-21T09:57:23.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3030-Nasty-Hacks/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3030-Nasty-Hacks/","excerpt":"题目源地址： http://poj.org/problem?id=3030 理解输入三个数，分别代表不做广告的效果、做广告的效果、做广告的花销，输出决定。","text":"题目源地址： http://poj.org/problem?id=3030 理解输入三个数，分别代表不做广告的效果、做广告的效果、做广告的花销，输出决定。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n, a, b, c; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a &gt; b - c)cout &lt;&lt; &quot;do not advertise&quot; &lt;&lt; endl; else if (a == b - c)cout &lt;&lt; &quot;does not matter&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;advertise&quot; &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3094 Quicksum","slug":"POJ-3094-Quicksum","date":"2014-08-21T09:54:26.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-3094-Quicksum/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-3094-Quicksum/","excerpt":"题目源地址： http://poj.org/problem?id=3094 理解对字母按照顺序求和，大水题，记得数组开大一点。","text":"题目源地址： http://poj.org/problem?id=3094 理解对字母按照顺序求和，大水题，记得数组开大一点。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; char data[300]; while (cin.getline(data, 300)) &#123; if (data[0] == &apos;#&apos;) break; int sum = 0; for (int i = 0; data[i] != &apos;\\0&apos;; i++) &#123; if (data[i] != &apos; &apos;) sum += (i + 1) * (data[i] - &apos;A&apos; + 1); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2992 Divisors","slug":"POJ-2992-Divisors","date":"2014-08-21T09:49:58.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-2992-Divisors/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-2992-Divisors/","excerpt":"题目源地址： http://poj.org/problem?id=2992 理解题目的意思还是比较简单的：输入C(n,k), 求该数的因数个数。然后我们又知道（谷歌又知道）：对于任意质数p, n!中有（n/p+n/p^2+n/p^3+…)个质因子p。","text":"题目源地址： http://poj.org/problem?id=2992 理解题目的意思还是比较简单的：输入C(n,k), 求该数的因数个数。然后我们又知道（谷歌又知道）：对于任意质数p, n!中有（n/p+n/p^2+n/p^3+…)个质因子p。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int MAX = 450;int a[MAX], p[MAX], pn;void prime ()&#123; pn = 0; memset(a, 0, sizeof(a)); int i, j; for ( i = 2; i &lt; MAX; i++ ) &#123; if ( a[i] == 0 ) p[pn++] = i; for ( j = 0; j &lt; pn &amp;&amp; i * p[j] &lt; MAX &amp;&amp; (p[j] &lt;= a[i] || a[i] == 0); j++ ) a[i * p[j]] = p[j]; &#125;&#125;int count ( int x, int pri )&#123; int ret = 0, tmp = pri; while ( x &gt;= tmp ) &#123; ret += x / tmp; tmp *= pri; &#125; return ret;&#125;int main(int argc, char const *argv[])&#123; int n, k; prime(); while ( scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF ) &#123; int a, b, c; long long int res = 1; for ( int i = 0; i &lt; pn &amp;&amp; p[i] &lt;= n; i++ ) &#123; a = count ( n, p[i] ); b = count ( k, p[i] ); c = count ( n - k, p[i] ); res *= ( a - b - c + 1 ); &#125; printf(&quot;%lld\\n&quot;, res ); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2904 Gauß in Elementary School","slug":"POJ-2904-Gauß-in-Elementary-School","date":"2014-08-21T09:43:27.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-2904-Gauß-in-Elementary-School/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-2904-Gauß-in-Elementary-School/","excerpt":"题目源地址： http://poj.org/problem?id=2904 理解求从n到m的所有元素之和。不过很多人都告诉我POJ上面交用到long long int的题必须使用I64d，变量类型也必须是__int64。但是我用long long int和%lld也能过啊，是因为POJ更新了么？","text":"题目源地址： http://poj.org/problem?id=2904 理解求从n到m的所有元素之和。不过很多人都告诉我POJ上面交用到long long int的题必须使用I64d，变量类型也必须是__int64。但是我用long long int和%lld也能过啊，是因为POJ更新了么？ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int ii, casenum; long long int n, m, i; long long int sum; scanf(&quot;%d&quot;, &amp;casenum); for (ii = 1; ii &lt;= casenum; ii++) &#123; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m); if (n &gt; m) &#123; i = m; m = n; n = i; &#125; sum = (n + m) * (m - n + 1) / 2; printf(&quot;Scenario #%d:\\n%lld\\n\\n&quot;, ii, sum); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2909 Goldbach's Conjecture","slug":"POJ-2909-Goldbach's-Conjecture","date":"2014-08-21T09:40:06.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/21/POJ-2909-Goldbach's-Conjecture/","link":"","permalink":"https://xuanwo.org/2014/08/21/POJ-2909-Goldbach's-Conjecture/","excerpt":"题目源地址： http://poj.org/problem?id=2909 理解筛法打素数表，用来验证哥德巴赫猜想。","text":"题目源地址： http://poj.org/problem?id=2909 理解筛法打素数表，用来验证哥德巴赫猜想。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;const int MAXP = 400000;bool isPrime[MAXP];int prime[MAXP];void primeList()&#123; memset(isPrime, true, sizeof(isPrime)); for (int i = 2; i &lt;= MAXP; ++i) &#123; if (isPrime[i]) prime[++prime[0]] = i; for (int j = 1, k; (k = i * prime[j]) &lt;= MAXP &amp;&amp; j &lt;= MAXP; ++j) &#123; isPrime[k] = false; if (i % prime[j] == 0) break; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; primeList(); int n, ans; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n != 0) &#123; ans = 0; for (int i = 1; prime[i] &lt;= n / 2; ++i) &#123; if (isPrime[n - prime[i]]) ++ans; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年08月21日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Gitbook——你自己的开源电子书","slug":"opensource-book","date":"2014-08-21T08:41:49.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/21/opensource-book/","link":"","permalink":"https://xuanwo.org/2014/08/21/opensource-book/","excerpt":"前言想自己写一本开源电子书，却被各种复杂的配置，环境所困扰？Readthedocs支持的语言用得不如Markdown爽？不想没更新一次都自己构建一遍？或者，你想成就一本辉煌的开源巨著躺着挣钱？Gitbook是你最好的选择——需要配置的项目少，使用Markdown标记语言，每次提交都自动进行构建，可以对自己的书进行定价（还能接受捐赠- -，国内就算了。。）。下面我就来稍微介绍一下Gitbook以及如何进行基本的配置。","text":"前言想自己写一本开源电子书，却被各种复杂的配置，环境所困扰？Readthedocs支持的语言用得不如Markdown爽？不想没更新一次都自己构建一遍？或者，你想成就一本辉煌的开源巨著躺着挣钱？Gitbook是你最好的选择——需要配置的项目少，使用Markdown标记语言，每次提交都自动进行构建，可以对自己的书进行定价（还能接受捐赠- -，国内就算了。。）。下面我就来稍微介绍一下Gitbook以及如何进行基本的配置。 介绍Gitbook项目官网：http://www.gitbook.io/GitBook Github地址：https://github.com/GitbookIO/gitbookGitbook本身是一个命令行工具（基于Node.js），因此我们可以在本地运行，并使用它来生成静态的网页。不过我们今天将要介绍的，是Gitbook所提供的网页服务——通过Github的Webhook功能实现的自动构建，免去了每次修改都需要自己构建的麻烦，而且也为多地协同，异地编辑提供了方便。Gitbook也提供了自己的一个编辑器，支持Markdown文件的实时渲染，和方便快捷的目录管理，需要的朋友可以自己去官网下载。这个下载是通过Github托管的，而Github又使用了亚马逊S3的云服务器，受到国情限制，下载异常艰难，我重试了N次才成功。因此我再提供一份自己的备份下载链接，给需要的朋友。 本地端配置最简单的一本Gitbook电子书包括两个文件：README.md和SUMMARY.md。 README.mdREADME.md控制了进入电子书页面的第一页，必须创建，否则会构建失败。内容可为空，一般用作写本书的简介。 SUMMARY.mdSUMMARY.md控制了本书的目录，Gitbook会根据这个文件的内容来搜寻并且创建页面，其格式如下： # Summary* [介绍](README.md)* [几何](geometry/geometry.md)* [组合](set/set.md)* [结构](structure/structure.md) * [树状数组(BinaryIndexedTree)](structure/binary-indexed-tree.md) 定义很简单，除去一行之外，下面通过* [章节名](此章节MD文件所在相对目录)这样的形式来定义。如果进行了缩进，说明此章节是上一个章节的子章节。比如上文中的结构是3，那树状数组的编号就是3.1。值得注意的是，逻辑上的结构跟存储结构是没有关联的，也就是说，你可以把所有MD文件放在同一个文件夹里面。但是如果MD文件很多，建议还是保持逻辑结构和实际存储结构的一致，方便管理。 网页端配置简单的注册之后，记得要和Github进行绑定，以便Gitbook能够取得POST的权限。然后在电子书的设置中制定项目库的位置，就会自动进行构建了。电子书的地址一般为http://yourname.gitbooks.io/yourbookname/这样的形式。 评价这样的方法构建出来电子书缺点在于可定制性不强，生成的PDF文件也是异常的丑= =，而且必须使用Gitbook的服务，在国内浏览速度不是很快。不过优点也蛮明显的：只要一个Git+一个可以编辑MD文档的编辑器就可以轻松地对文档进行编辑。最后，大家在新增章节之后千万不要忘记更新SUMMARY.md文件～ 更新日志 2014年08月21日 初步完成Gitbook介绍。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"POJ 3083 Children of the Candy Corn","slug":"POJ-3083-Children-of-the-Candy-Corn","date":"2014-08-19T16:58:57.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/19/POJ-3083-Children-of-the-Candy-Corn/","link":"","permalink":"https://xuanwo.org/2014/08/19/POJ-3083-Children-of-the-Candy-Corn/","excerpt":"题目源地址： http://poj.org/problem?id=3083 理解最开始的代码程序直接报错，反复调试之后，发现我陷入了无限的循环之中。因为先写的左转优先的代码，面对这样的数据时： #########......##.####.##.####.##.####.##.####.##...#..# //此行倒数第二和第三的`.`会使得左转优先策略陷入无限循环#S#E#### 因此，仅仅是写DFS是不够的，我还需要对当前的朝向再进行判断。除了这个之外，就是一个BFS了，最短路径用DFS不太合适。","text":"题目源地址： http://poj.org/problem?id=3083 理解最开始的代码程序直接报错，反复调试之后，发现我陷入了无限的循环之中。因为先写的左转优先的代码，面对这样的数据时： #########......##.####.##.####.##.####.##.####.##...#..# //此行倒数第二和第三的`.`会使得左转优先策略陷入无限循环#S#E#### 因此，仅仅是写DFS是不够的，我还需要对当前的朝向再进行判断。除了这个之外，就是一个BFS了，最短路径用DFS不太合适。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define MAXN 45using namespace std;#define see(x) cout&lt;&lt;#x&lt;&lt;&quot;:&quot;&lt;&lt;x&lt;&lt;endl;const int N = 50;char maze[N][N];typedef struct&#123; int x, y, dis;&#125; Node;const int move[4][4] = &#123; &#123;0, -1&#125;, &#123; -1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125; &#125;;bool vis[N][N] = &#123;0&#125;;int r, c;queue&lt;Node&gt; q;int bfs()&#123; int i; Node temp, temp1; int minn = inf; while (!q.empty()) &#123; temp = q.front(); q.pop(); if (maze[temp.x][temp.y] == &apos;E&apos;) &#123; if (temp.dis &lt; minn) &#123; minn = temp.dis; &#125; &#125; else &#123; for (i = 0; i &lt; 4; i++) &#123; temp1.x = temp.x + move[i][0]; temp1.y = temp.y + move[i][1]; temp1.dis = temp.dis + 1; if (temp1.x &gt;= 0 &amp;&amp; temp1.x &lt; r &amp;&amp; temp1.y &gt;= 0 &amp;&amp; temp1.y &lt; c &amp;&amp; maze[temp1.x][temp1.y] != &apos;#&apos; &amp;&amp; !vis[temp1.x][temp1.y]) &#123; vis[temp1.x][temp1.y] = 1; q.push(temp1); &#125; &#125; &#125; &#125; return minn;&#125;int dfs(int x, int y, int dir, char mark)&#123; int i, ndir, nx, ny; if (maze[x][y] == &apos;E&apos;) &#123; return 1; &#125; if (mark == &apos;l&apos;) &#123; for (i = dir - 1; i &lt; dir + 3; i++) &#123; nx = x + move[(i + 4) % 4][0]; ny = y + move[(i + 4) % 4][1]; ndir = (i + 4) % 4; if (nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c &amp;&amp; maze[nx][ny] != &apos;#&apos;) &#123; // cout&lt;&lt;&quot;nx: &quot;&lt;&lt;nx&lt;&lt;&quot; ny: &quot;&lt;&lt;ny&lt;&lt;&quot; &quot;; see(ndir) return dfs(nx, ny, ndir, mark) + 1; &#125; &#125; &#125; if (mark == &apos;r&apos;) &#123; for (i = dir + 1; i &gt; dir - 3; i--) &#123; nx = x + move[(i + 4) % 4][0]; ny = y + move[(i + 4) % 4][1]; ndir = (i + 4) % 4; if (nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c &amp;&amp; maze[nx][ny] != &apos;#&apos;) &#123; return dfs(nx, ny, ndir, mark) + 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; int t, lp, rp, sp; int i, j, k, dir; Node s; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;c, &amp;r); for (i = 0; i &lt; r; i++) scanf(&quot;%s&quot;, maze[i]); for (i = 0; i &lt; r; i++) &#123; for (j = 0; j &lt; c; j++) &#123; if (maze[i][j] == &apos;S&apos;) &#123; s.x = i; s.y = j; s.dis = 1; break; &#125; &#125; &#125; if (s.x == 0) &#123; dir = 3; &#125; else if (s.x == 1) &#123; dir = 1; &#125; else if (s.y == 0) &#123; dir = 2; &#125; else &#123; dir = 0; &#125; lp = dfs(s.x, s.y, dir, &apos;l&apos;); vis[s.x][s.y] = 1; rp = dfs(s.x, s.y, dir, &apos;r&apos;); memset(vis, 0, sizeof(vis)); vis[s.x][s.y] = 1; s.dis = 1; q.push(s); sp = bfs(); printf(&quot;%d %d %d\\n&quot;, lp, rp, sp); &#125; return 0;&#125; 更新日志 2014年08月19日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2876 Cantoring Along","slug":"POJ-2876-Cantoring-Along","date":"2014-08-18T23:19:45.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2876-Cantoring-Along/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2876-Cantoring-Along/","excerpt":"题目源地址： http://poj.org/problem?id=2876 理解按照指定格式输出字符串，递归求解。","text":"题目源地址： http://poj.org/problem?id=2876 理解按照指定格式输出字符串，递归求解。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int n;char str[600000];inline void solve(int x, int y)&#123; if (x == y) return; for (int i = x + (y - x + 1) / 3; i &lt;= x + (y - x + 1) / 3 * 2 - 1; i++) str[i] = &apos; &apos;; solve(x, x + (y - x + 1) / 3 - 1); solve(x + (y - x + 1) / 3 * 2, y);&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d&quot;, &amp;n) + 1) &#123; int res = 1; for (int i = 1; i &lt;= n; i++) res *= 3; n = res; for (int i = 1; i &lt;= n; i++) str[i] = &apos;-&apos;; solve(1, n); str[n + 1] = &apos;\\0&apos;; puts(str + 1); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2864 Pascal Library","slug":"POJ-2864-Pascal-Library","date":"2014-08-18T22:57:52.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2864-Pascal-Library/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2864-Pascal-Library/","excerpt":"题目源地址： http://poj.org/problem?id=2864 理解统计出现1的个数，如果个数等于列数，就输出yes，否则输出no。","text":"题目源地址： http://poj.org/problem?id=2864 理解统计出现1的个数，如果个数等于列数，就输出yes，否则输出no。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int grid[510][110];int main(int argc, char const *argv[])&#123; int n, d, i, j, ans, tmp; bool flag; while (cin &gt;&gt; n &gt;&gt; d) &#123; if (n == 0 &amp;&amp; d == 0) break; flag = false; for (i = 0; i &lt; d; i++) for (j = 0; j &lt; n; j++) cin &gt;&gt; grid[i][j]; for (i = 0; i &lt; n; i++) &#123; tmp = 0; for (j = 0; j &lt; d; j++) &#123; if (grid[j][i] == 1) tmp++; &#125; if (tmp == d) &#123; cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; flag = true; break; &#125; &#125; if (!flag) cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2853 Sequence Sum Possibilities","slug":"POJ-2853-Sequence-Sum-Possibilities","date":"2014-08-18T22:42:34.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2853-Sequence-Sum-Possibilities/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2853-Sequence-Sum-Possibilities/","excerpt":"题目源地址： http://poj.org/problem?id=2853 理解因式分解，输出能用题目中的要求输出的组合的数目。","text":"题目源地址： http://poj.org/problem?id=2853 理解因式分解，输出能用题目中的要求输出的组合的数目。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int i; int n; int cases; int num; int count; cin &gt;&gt; cases; while (cases--) &#123; cin &gt;&gt; num; cin &gt;&gt; n; i = 1; count = 0; while (n - i * (i + 1) / 2 &gt;= 0) &#123; if ((n - i * (i + 1) / 2) % i == 0) count++; i++; &#125; cout &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; count - 1 &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2871 A Simple Question of Chemistry","slug":"POJ-2871-A-Simple-Question-of-Chemistry","date":"2014-08-18T22:39:35.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2871-A-Simple-Question-of-Chemistry/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2871-A-Simple-Question-of-Chemistry/","excerpt":"题目源地址： http://poj.org/problem?id=2871 理解给一列数，从第二个数开始，输出其与上一个数字之差，输出取两位小数，输入以“999”数字结束。","text":"题目源地址： http://poj.org/problem?id=2871 理解给一列数，从第二个数开始，输出其与上一个数字之差，输出取两位小数，输入以“999”数字结束。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; float last = 0, now; scanf(&quot;%f&quot;, &amp;last); while (last != 999 &amp;&amp; scanf(&quot;%f&quot;, &amp;now), now != 999) &#123; printf(&quot;%.2f\\n&quot;, now - last); last = now; &#125; printf(&quot;End of Output\\n&quot;); return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2591 Set Definition","slug":"POJ-2591-Set-Definition","date":"2014-08-18T22:35:08.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2591-Set-Definition/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2591-Set-Definition/","excerpt":"题目源地址： http://poj.org/problem?id=2591 理解运用了递归的思想，不过没有另外使用函数来调用。","text":"题目源地址： http://poj.org/problem?id=2591 理解运用了递归的思想，不过没有另外使用函数来调用。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;#define SIZE 10000010#define MIN(a, b) (a &lt; b ? a : b)long a[SIZE];int main(int argc, char const *argv[])&#123; long i2, i3; i2 = i3 = 1; a[1] = 1; for (long i = 2; i &lt; SIZE; i++) &#123; a[i] = MIN(2 * a[i2] + 1, 3 * a[i3] + 1); if (a[i] == 2 * a[i2] + 1) i2++; if (a[i] == 3 * a[i3] + 1) i3++; &#125; long t; while (EOF != scanf(&quot;%ld&quot;, &amp;t)) printf(&quot;%ld\\n&quot;, a[t]); return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2593 Max Sequence","slug":"POJ-2593-Max-Sequence","date":"2014-08-18T22:30:24.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2593-Max-Sequence/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2593-Max-Sequence/","excerpt":"题目源地址： http://poj.org/problem?id=2593 理解贪心法求最大最序列和，但是注意下时间。","text":"题目源地址： http://poj.org/problem?id=2593 理解贪心法求最大最序列和，但是注意下时间。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int data[100000], dp[100000];int main(int argc, char const *argv[])&#123; int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; if (!n) break; int sum = 0, tmp = -999999999; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;data[i]); sum += data[i]; if (sum &gt; tmp) tmp = sum; dp[i] = tmp; if (sum &lt; 0) sum = 0; &#125; sum = 0; int ans = -999999999; for (int i = n - 1; i &gt; 0; i--) &#123; sum += data[i]; if (dp[i - 1] + sum &gt; ans) ans = dp[i - 1] + sum; if (sum &lt; 0) sum = 0; &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1700 Crossing River","slug":"POJ-1700-Crossing-River","date":"2014-08-18T22:27:39.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/18/POJ-1700-Crossing-River/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-1700-Crossing-River/","excerpt":"题目源地址： http://poj.org/problem?id=1700 理解 -，小学时候做的智力题啊，贪心法，","text":"题目源地址： http://poj.org/problem?id=1700 理解 -，小学时候做的智力题啊，贪心法， 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int p[1005], t, n; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; int i = 0; while (i &lt; n) cin &gt;&gt; p[i++]; sort(p, p + n); int sum = 0; while (n) &#123; if (n == 1) &#123; sum += p[0]; n = 0; &#125; else if (n == 2) &#123; sum += p[1]; n = 0; &#125; else if (n == 3) &#123; sum += (p[0] + p[1] + p[2]); n = 0; &#125; else if (n == 4) &#123; if (p[2] - 2 * p[1] + p[0] &lt;= 0) sum += (p[3] + p[2] + p[1] + 2 * p[0]); else sum += (p[3] + 3 * p[1] + p[0]); n = 0; &#125; else &#123; if (p[n - 2] - 2 * p[1] + p[0] &lt;= 0) sum += (p[n - 1] + p[n - 2] + 2 * p[0]); else sum += (p[n - 1] + 2 * p[1] + p[0]); n -= 2; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3720 Occurrence of Digits","slug":"POJ-3720-Occurrence-of-Digits","date":"2014-08-18T22:23:53.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/18/POJ-3720-Occurrence-of-Digits/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-3720-Occurrence-of-Digits/","excerpt":"题目源地址： http://poj.org/problem?id=3720 理解给定n，k，求出1/2 , 1/n之间所有分数的循环小数表达式中数字k的出现次数，简单的模拟就行了。","text":"题目源地址： http://poj.org/problem?id=3720 理解给定n，k，求出1/2 , 1/n之间所有分数的循环小数表达式中数字k的出现次数，简单的模拟就行了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int ans[101][10];bool re[200];int main(int argc, char const *argv[])&#123; memset(ans, 0, sizeof(ans)) ; for (int i = 2 ; i &lt;= 100 ; i++) &#123; for (int j = 0 ; j &lt; 10 ; j++) ans[i][j] = ans[i - 1][j] ; int num = 1, p = 0 ; memset(re, 0, sizeof(re)) ; re[1] = true ; while (num != 0) &#123; num *= 10 ; p = num / i ; ans[i][p]++ ; if (re[num % i]) break ; else &#123; re[num % i] = true ; num %= i ; &#125; &#125; &#125; int n, k ; while (cin &gt;&gt; n &gt;&gt; k) cout &lt;&lt; ans[n][k] &lt;&lt; endl ; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3219 二项式系数","slug":"POJ-3219-Binomial-Coefficient","date":"2014-08-18T22:18:58.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-3219-Binomial-Coefficient/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-3219-Binomial-Coefficient/","excerpt":"题目源地址： http://poj.org/problem?id=3219 理解跪拜大神的神思路，还有二进制的神奇用法。&gt;C(n,k)(k&lt;=n)的奇偶性取决于(n-k)与k的二进制表达式是否存在同一位上的两个数码均为1，若存在，则为偶数，反之为奇数。","text":"题目源地址： http://poj.org/problem?id=3219 理解跪拜大神的神思路，还有二进制的神奇用法。&gt;C(n,k)(k&lt;=n)的奇偶性取决于(n-k)与k的二进制表达式是否存在同一位上的两个数码均为1，若存在，则为偶数，反之为奇数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n, k; while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k)) &#123; printf(&quot;%d\\n&quot;, k &amp; (n - k) ? 0 : 1); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3224 Lab杯","slug":"POJ-3224-Lab-Cup","date":"2014-08-18T22:15:49.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-3224-Lab-Cup/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-3224-Lab-Cup/","excerpt":"题目源地址： http://poj.org/problem?id=3224 理解直接每行取分，如果是3分就+1，比较出获得3分最多的人，输出号码。","text":"题目源地址： http://poj.org/problem?id=3224 理解直接每行取分，如果是3分就+1，比较出获得3分最多的人，输出号码。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n; int max, maxi, sum, tmp; int i, j; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (i = 1, max = -1; i &lt;= n; i++) &#123; for (j = 1, sum = 0; j &lt;= n; j++) &#123; scanf(&quot;%d&quot;, &amp;tmp); if (tmp == 3) &#123; sum ++; &#125; &#125; if (sum &gt; max) &#123; max = sum; maxi = i; &#125; &#125; printf(&quot;%d\\n&quot;, maxi); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3737 UmBasketella","slug":"POJ-3737-UmBasketella","date":"2014-08-18T22:12:24.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/18/POJ-3737-UmBasketella/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-3737-UmBasketella/","excerpt":"题目源地址： http://poj.org/problem?id=3737 理解几何的题目，立体几何的公式用起来。","text":"题目源地址： http://poj.org/problem?id=3737 理解几何的题目，立体几何的公式用起来。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; double s, r, h, v; while (scanf(&quot;%lf&quot;, &amp;s) != EOF) &#123; r = sqrt(s / pi) / 2; h = sqrt((s * s) / (pi * pi * r * r) - 2 * s / pi); v = pi * r * r * h / 3; printf(&quot;%.2f\\n%.2f\\n%.2f\\n&quot;, v, h, r); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2840 Big Clock","slug":"POJ-2840-Big-Clock","date":"2014-08-18T22:08:11.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2840-Big-Clock/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2840-Big-Clock/","excerpt":"题目源地址： http://poj.org/problem?id=2840 理解很有意思的题目，求解大本钟敲几下的问题，按照规律来。","text":"题目源地址： http://poj.org/problem?id=2840 理解很有意思的题目，求解大本钟敲几下的问题，按照规律来。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int ii, casenum; int h, m; scanf(&quot;%d&quot;, &amp;casenum); for (ii = 0; ii &lt; casenum; ii++) &#123; scanf(&quot;%d:%d&quot;, &amp;h, &amp;m); if (m == 0) &#123; if (h == 12) &#123; printf(&quot;24\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, (12 + h) % 24); &#125; &#125; else &#123; printf(&quot;0\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2707 Copier Reduction","slug":"POJ-2707-Copier-Reduction","date":"2014-08-18T22:05:01.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2707-Copier-Reduction/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2707-Copier-Reduction/","excerpt":"题目源地址： http://poj.org/problem?id=2707 理解纯英文题，题目读懂就会做，注意int和float的区别。","text":"题目源地址： http://poj.org/problem?id=2707 理解纯英文题，题目读懂就会做，注意int和float的区别。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;void max(float &amp;a, float &amp;b)&#123; float t; if (a &lt; b) &#123; t = a; a = b; b = t; &#125;&#125;int main(int argc, char const *argv[])&#123; while (1) &#123; float a, b, c, d, i; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0 &amp;&amp; d == 0) return 0; else &#123; max(a, b); max(c, d); for ( i = 100; i &gt; 0; i--) &#123; if ((a * i / 100 &lt;= c) &amp;&amp; (b * i / 100 &lt;= d)) break ; &#125; cout &lt;&lt; i &lt;&lt; &quot;%&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2719 Faulty Odometer","slug":"POJ-2719-Faulty-Odometer","date":"2014-08-18T22:01:00.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-2719-Faulty-Odometer/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-2719-Faulty-Odometer/","excerpt":"题目源地址： http://poj.org/problem?id=2719 理解一语惊醒梦中人啊- -，九进制就OK。","text":"题目源地址： http://poj.org/problem?id=2719 理解一语惊醒梦中人啊- -，九进制就OK。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)using namespace std;int main(int argc, char const *argv[])&#123; int n, m, i, mul, a[9]; while (scanf(&quot;%d&quot;, &amp;n)) &#123; if (n == 0) break; m = n; memset(a, 0, sizeof(a)); for (i = 0; n; i++, n /= 10) &#123; a[i] = n % 10; if (a[i] &gt; 4) a[i]--; &#125; mul = a[--i]; for (; i &gt;= 1; i--) &#123; mul = mul * 9 + a[i - 1]; &#125; printf(&quot;%d: %d\\n&quot;, m, mul); &#125; return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3278 Catch That Cow","slug":"POJ-3278-Catch-That-Cow","date":"2014-08-18T17:00:55.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/18/POJ-3278-Catch-That-Cow/","link":"","permalink":"https://xuanwo.org/2014/08/18/POJ-3278-Catch-That-Cow/","excerpt":"题目源地址： http://poj.org/problem?id=3278 理解BFS最基础的应用，只有三个方向，一个是乘二，一个是加一，一个是减一。","text":"题目源地址： http://poj.org/problem?id=3278 理解BFS最基础的应用，只有三个方向，一个是乘二，一个是加一，一个是减一。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;28)#define MAXN 100010using namespace std;int n, k, tmp, res;int maze[MAXN];int vis[MAXN];void init()&#123; memset(maze, 0, sizeof(maze)); memset(vis, 0, sizeof(vis)); cin &gt;&gt; n &gt;&gt; k;&#125;int bfs()&#123; queue&lt;int&gt; que; int next; que.push(n); vis[n] = 1; while (que.size()) &#123; tmp = que.front(); que.pop(); for (int i = 0; i &lt;= 2; i++) &#123; if (i == 0) next = tmp * 2; else if (i == 1) next = tmp + 1; else next = tmp - 1; if (next &gt; MAXN || next &lt; 0 ) continue; if (!vis[next]) &#123; que.push(next); maze[next] = maze[tmp] + 1; vis[next] = 1; &#125; if (next == k) return maze[next]; &#125; &#125; return -1;&#125;int main(int argc, char const *argv[])&#123; init(); cout &lt;&lt; bfs(); return 0;&#125; 更新日志 2014年08月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2696 A Mysterious Function","slug":"POJ-2696-A-Mysterious-Function","date":"2014-08-17T23:52:44.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2696-A-Mysterious-Function/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2696-A-Mysterious-Function/","excerpt":"题目源地址： http://poj.org/problem?id=2696 理解套公式计算，水题，但是注意数组的大小。","text":"题目源地址： http://poj.org/problem?id=2696 理解套公式计算，水题，但是注意数组的大小。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int r[1005];int main(int argc, char const *argv[])&#123; int a, b, c, d, e, f, g, h, i; int j; int test; cin &gt;&gt; test; while (test--) &#123; scanf(&quot;%d%d%d%d%d%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g, &amp;h, &amp;i); r[0] = a; r[1] = b; r[2] = c; for (j = 3; j &lt;= i; j++) &#123; if (j % 2 == 1) &#123; r[j] = (d * r[j - 1] + e * r[j - 2] - f * r[j - 3]) % g; if (r[j] &lt; 0) r[j] += g; &#125; else &#123; r[j] = (f * r[j - 1] - d * r[j - 2] + e * r[j - 3]) % h; if (r[j] &lt; 0) r[j] += h; &#125; &#125; cout &lt;&lt; r[i] &lt;&lt; endl; &#125;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2601 Simple calculations","slug":"POJ-2601-Simple-calculations","date":"2014-08-17T23:49:14.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2601-Simple-calculations/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2601-Simple-calculations/","excerpt":"题目源地址： http://poj.org/problem?id=2601 理解推公式。满眼都是泪，不多说了= =。","text":"题目源地址： http://poj.org/problem?id=2601 理解推公式。满眼都是泪，不多说了= =。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int i, n; double x, y, c, sum; while (cin &gt;&gt; n) &#123; sum = 0; cin &gt;&gt; x &gt;&gt; y; for (i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; c; sum += 2 * (n + 1 - i) * c; &#125; sum = (n * x + y - sum) / (n + 1); printf(&quot;%.2f\\n&quot;, sum); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2665 Trees","slug":"POJ-2665-Trees","date":"2014-08-17T23:42:32.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2665-Trees/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2665-Trees/","excerpt":"题目源地址： http://poj.org/problem?id=2665 理解用一个unsigned int储存总数，然后每次对于区间减去需要移除的数量，最后求值。记得POJ上也有这道题，当年好象是用标记01的方法来做的。","text":"题目源地址： http://poj.org/problem?id=2665 理解用一个unsigned int储存总数，然后每次对于区间减去需要移除的数量，最后求值。记得POJ上也有这道题，当年好象是用标记01的方法来做的。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; unsigned int trees; int i, j; int M; unsigned int start, end; while (scanf(&quot;%u%d&quot;, &amp;trees, &amp;M), trees != 0 || M != 0) &#123; trees += 1; for (i = 0; i &lt; M ; i++) &#123; scanf(&quot;%u%u&quot;, &amp;start, &amp;end); trees -= end - start + 1; &#125; printf(&quot;%u\\n&quot;, trees); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2606 Rabbit hunt","slug":"POJ-2606-Rabbit-hunt","date":"2014-08-17T16:50:58.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2606-Rabbit-hunt/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2606-Rabbit-hunt/","excerpt":"题目源地址： http://poj.org/problem?id=2606 理解与之前做过的题目几乎一模一样，只是结束条件不同。同样是计算每一个点的斜率，存在数组中，再排序。","text":"题目源地址： http://poj.org/problem?id=2606 理解与之前做过的题目几乎一模一样，只是结束条件不同。同样是计算每一个点的斜率，存在数组中，再排序。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int aid[1000][2];float xielv[1000];int main(int argc, char const *argv[])&#123; int i, j, k; int max, tmp; int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; memset(aid, 0, sizeof(aid)); for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;aid[i][0], &amp;aid[i][1]); &#125; max = 2; for (i = 0; i &lt; n - 1; i++) &#123; for (j = i + 1, k = 0; j &lt; n; j++) &#123; if (aid[j][0] == aid[i][0]) &#123; xielv[k++] = 32767; &#125; else &#123; xielv[k++] = (float)(aid[j][1] - aid[i][1]) / (float)(aid[j][0] - aid[i][0]); &#125; &#125; sort(xielv, xielv + k); for (j = 1, tmp = 2; j &lt;= k; j++) &#123; if (xielv[j] == xielv[j - 1]) &#123; tmp ++; if (tmp &gt; max) &#123; max = tmp; &#125; &#125; else &#123; tmp = 2; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, max); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1118 Lining Up","slug":"POJ-1118-Lining-Up","date":"2014-08-17T16:47:52.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/17/POJ-1118-Lining-Up/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-1118-Lining-Up/","excerpt":"题目源地址： http://poj.org/problem?id=1118 理解暴力过，求出所有点的斜率并存在一个数组中，再进行比较。","text":"题目源地址： http://poj.org/problem?id=1118 理解暴力过，求出所有点的斜率并存在一个数组中，再进行比较。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int aid[1000][2];float xielv[1000];int main(int argc, char const *argv[])&#123; int i, j, k; int max, tmp; int n; while (scanf(&quot;%d&quot;, &amp;n), n != 0) &#123; memset(aid, 0, sizeof(aid)); for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;aid[i][0], &amp;aid[i][1]); &#125; max = 2; for (i = 0; i &lt; n - 1; i++) &#123; for (j = i + 1, k = 0; j &lt; n; j++) &#123; if (aid[j][0] == aid[i][0]) &#123; xielv[k++] = 32767; &#125; else &#123; xielv[k++] = (float)(aid[j][1] - aid[i][1]) / (float)(aid[j][0] - aid[i][0]); &#125; &#125; sort(xielv, xielv + k); for (j = 1, tmp = 2; j &lt;= k; j++) &#123; if (xielv[j] == xielv[j - 1]) &#123; tmp ++; if (tmp &gt; max) &#123; max = tmp; &#125; &#125; else &#123; tmp = 2; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, max); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2623 Sequence Median","slug":"POJ-2623-Sequence-Median","date":"2014-08-17T16:44:10.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2623-Sequence-Median/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2623-Sequence-Median/","excerpt":"题目源地址： http://poj.org/problem?id=2623 理解快速排序的简单应用，注意最后的输出格式。","text":"题目源地址： http://poj.org/problem?id=2623 理解快速排序的简单应用，注意最后的输出格式。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int comp(const void *a, const void *b)&#123; return (*(int *)a - * (int *)b);&#125;int main()&#123; int n, i; int a[250050]; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); qsort(a, n, sizeof(int), comp); if (n % 2 != 0) printf(&quot;%.1f\\n&quot;, (double)(a[(n + 1) / 2 - 1])); else printf(&quot;%.1f\\n&quot;, a[n / 2 - 1] / 2.0 + a[n / 2] / 2.0); return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2608 Soundex","slug":"POJ-2608-Soundex","date":"2014-08-17T16:36:16.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2608-Soundex/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2608-Soundex/","excerpt":"题目源地址： http://poj.org/problem?id=2608 理解输出字符串所对应的值，没有的话，就不输出。不过现在有点后悔，是不是用Map来做会更好一些。","text":"题目源地址： http://poj.org/problem?id=2608 理解输出字符串所对应的值，没有的话，就不输出。不过现在有点后悔，是不是用Map来做会更好一些。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char str[30];int arr[50];void init()&#123; arr[0] = 0; // A arr[1] = 1; // B arr[2] = 2; // C arr[3] = 3; // D arr[4] = 0; // E arr[5] = 1; // F arr[6] = 2; // G arr[7] = 0; // H arr[8] = 0; // I arr[9] = 2; // J arr[10] = 2; // K arr[11] = 4; // L arr[12] = 5; // M arr[13] = 5; // N arr[14] = 0; // O arr[15] = 1; // P arr[16] = 2; // Q arr[17] = 6; // R arr[18] = 2; // S arr[19] = 3; // T arr[20] = 0; // U arr[21] = 1; // V arr[22] = 0; // W arr[23] = 2; // X arr[24] = 0; // Y arr[25] = 2; // Z&#125;int main(int argc, char const *argv[])&#123; char last, tmp; int len, i; init(); while (scanf(&quot;%s&quot;, str) != EOF) &#123; len = strlen(str); last = 0; for (i = 0; i &lt; len ; i++) &#123; if (arr[str[i] - &apos;A&apos;] != 0 &amp;&amp; arr[str[i] - &apos;A&apos;] != last) &#123; printf(&quot;%d&quot;, (last = arr[str[i] - &apos;A&apos;])); &#125; else &#123; last = arr[str[i] - &apos;A&apos;]; &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2602 Superlong sums","slug":"POJ-2602-Superlong-sums","date":"2014-08-17T16:33:30.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2602-Superlong-sums/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2602-Superlong-sums/","excerpt":"题目源地址： http://poj.org/problem?id=2602 理解发现开辟一个字符数组，在输入的过程中处理数据。比较简单的大数加法，没有使用Java。","text":"题目源地址： http://poj.org/problem?id=2602 理解发现开辟一个字符数组，在输入的过程中处理数据。比较简单的大数加法，没有使用Java。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main()&#123; char a[1000002] = &#123;&apos;0&apos;&#125;; int n, i; int x, y; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); a[i] = x + y + &apos;0&apos;; &#125; for (i = n - 1; i &gt;= 0; i--) &#123; if (a[i] &gt; &apos;9&apos;) &#123; a[i] = a[i] - 10; a[i - 1] = a[i - 1] + 1; &#125; &#125; printf(&quot;%s\\n&quot;, a); return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2656 Unhappy Jinjin","slug":"POJ-2656-Unhappy-Jinjin","date":"2014-08-17T16:29:05.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2656-Unhappy-Jinjin/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2656-Unhappy-Jinjin/","excerpt":"题目源地址： http://poj.org/problem?id=2656 理解在我们学校自己的OJ好像做过一样的题目，恩，一道水题，求学习时间最长的一天。","text":"题目源地址： http://poj.org/problem?id=2656 理解在我们学校自己的OJ好像做过一样的题目，恩，一道水题，求学习时间最长的一天。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int i, days; int max; int first, second; int flag; while (scanf(&quot;%d&quot;, &amp;days), days != 0) &#123; max = -1; flag = 0; for (i = 0; i &lt; days; i++) &#123; scanf(&quot;%d%d&quot;, &amp;first, &amp;second); if (first + second &gt; 8 &amp;&amp; max &lt; first + second) &#123; flag = i + 1; max = first + second; &#125; &#125; printf(&quot;%d\\n&quot;, flag); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2578 Keep on Truckin'","slug":"POJ-2578-Keep-on-Truckin'","date":"2014-08-17T16:24:37.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2578-Keep-on-Truckin'/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2578-Keep-on-Truckin'/","excerpt":"题目源地址： http://poj.org/problem?id=2578 理解给三个数字，从左到右，看哪个数字先大于168，直到得到一个大于168的数，之前的数全都输出”Crash”。","text":"题目源地址： http://poj.org/problem?id=2578 理解给三个数字，从左到右，看哪个数字先大于168，直到得到一个大于168的数，之前的数全都输出”Crash”。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int a, b, c; while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) != EOF) &#123; if (a &lt;= 168) &#123; printf(&quot;CRASH %d\\n&quot;, a); &#125; else if (b &lt;= 168) &#123; printf(&quot;CRASH %d\\n&quot;, b); &#125; else if (c &lt;= 168) &#123; printf(&quot;CRASH %d\\n&quot;, c); &#125; else &#123; printf(&quot;NO CRASH\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2551 Ones","slug":"POJ-2551-Ones","date":"2014-08-17T16:17:59.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2551-Ones/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2551-Ones/","excerpt":"题目源地址： http://poj.org/problem?id=2551 理解将一个数取下来，然后从1对n本身取模（%），之后将取模之后的数字乘以10加1，再取模，直到取模为0。比如当n=3时，变化的情况是这样的：3-&gt;31(余1)-&gt;311(余1)-&gt;3111(整除)","text":"题目源地址： http://poj.org/problem?id=2551 理解将一个数取下来，然后从1对n本身取模（%），之后将取模之后的数字乘以10加1，再取模，直到取模为0。比如当n=3时，变化的情况是这样的：3-&gt;31(余1)-&gt;311(余1)-&gt;3111(整除) 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int num; int n; int i, j; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; num = i = 1; num %= n; for (; num; i++) &#123; num = num * 10 + 1; num %= n; &#125; printf(&quot;%d\\n&quot;, i); &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2521 How much did the businessman lose","slug":"POJ-2521-How-much-did-the-businessman-lose","date":"2014-08-17T16:14:20.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2521-How-much-did-the-businessman-lose/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2521-How-much-did-the-businessman-lose/","excerpt":"题目源地址： http://poj.org/problem?id=2521 理解小学的时候经常做的题目啊，只要保持头脑清醒，计算出交易过程中因为假币损失的钱。","text":"题目源地址： http://poj.org/problem?id=2521 理解小学的时候经常做的题目啊，只要保持头脑清醒，计算出交易过程中因为假币损失的钱。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int n, m, p, c; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; c &amp;&amp; n + m + p + c) &#123; cout &lt;&lt; p - (m - n) &lt;&lt; endl; &#125;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2509 Peter's smokes","slug":"POJ-2509-Peter's-smokes","date":"2014-08-17T16:08:27.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/17/POJ-2509-Peter's-smokes/","link":"","permalink":"https://xuanwo.org/2014/08/17/POJ-2509-Peter's-smokes/","excerpt":"题目源地址： http://poj.org/problem?id=2509 理解模拟每个人吸烟的过程即可。","text":"题目源地址： http://poj.org/problem?id=2509 理解模拟每个人吸烟的过程即可。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int n; int k; int sum = 0; while (cin &gt;&gt; n &gt;&gt; k) &#123; sum = n; while (n / k) &#123; sum += (n / k); n = n % k + n / k; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2503 Babelfish","slug":"POJ-2503-Babelfish","date":"2014-08-16T23:41:45.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/16/POJ-2503-Babelfish/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2503-Babelfish/","excerpt":"题目源地址： http://poj.org/problem?id=2503 理解STL里面Map的运用，分别建立映射就好，不难。","text":"题目源地址： http://poj.org/problem?id=2503 理解STL里面Map的运用，分别建立映射就好，不难。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; char str[20], s1[20], s2[20]; map&lt;string, string&gt;mymap; while (gets(str)) &#123; if (strlen(str) == 0) break; sscanf(str, &quot;%s %s&quot;, s1, s2); mymap[s2] = s1; &#125; while (gets(str)) &#123; if (mymap[str].length() == 0) puts(&quot;eh&quot;); else cout &lt;&lt; mymap[str] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2453 An Easy Problem","slug":"POJ-2453-An-Easy-Problem","date":"2014-08-16T23:36:24.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2453-An-Easy-Problem/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2453-An-Easy-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=2453 理解位运算碉堡了，着实强大。","text":"题目源地址： http://poj.org/problem?id=2453 理解位运算碉堡了，着实强大。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int n, x; while (scanf(&quot;%d&quot;, &amp;n), n) &#123; x = n &amp; -n; printf(&quot;%d\\n&quot;, n + x + (n ^ n + x) / x / 4); &#125;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2478 Farey Sequence","slug":"POJ-2478-Farey-Sequence","date":"2014-08-16T23:33:37.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2478-Farey-Sequence/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2478-Farey-Sequence/","excerpt":"题目源地址： http://poj.org/problem?id=2478 理解欧拉函数的运用，套用了模板。","text":"题目源地址： http://poj.org/problem?id=2478 理解欧拉函数的运用，套用了模板。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;#define M 1001000typedef long long LL;int vis[M] = &#123;0&#125;;int prime[M / 3], phi[M];LL sum[M];void PHI()&#123; int cnt = 0; for (int i = 2; i &lt; M; i++) &#123; if (vis[i] == 0) &#123; prime[cnt++] = i; phi[i] = i - 1; &#125; for (int j = 0; j &lt; cnt &amp;&amp; prime[j]*i &lt; M; j++) &#123; vis[i * prime[j]] = 1; if (i % prime[j] == 0) &#123; phi[i * prime[j]] = phi[i] * prime[j]; break; &#125; else phi[i * prime[j]] = phi[i] * phi[prime[j]]; &#125; &#125;&#125;int main()&#123; int n; PHI(); sum[2] = phi[2]; for (int i = 3; i &lt;= 1000000; i++) sum[i] = sum[i - 1] + phi[i]; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123; printf(&quot;%lld\\n&quot;, sum[n]); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2407 Relatives","slug":"POJ-2407-Relatives","date":"2014-08-16T22:04:50.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2407-Relatives/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2407-Relatives/","excerpt":"题目源地址： http://poj.org/problem?id=2407 理解套用欧拉公式，其实不懂= =。","text":"题目源地址： http://poj.org/problem?id=2407 理解套用欧拉公式，其实不懂= =。 新技能get欧拉函数：&gt;在数论，对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名，它又称为Euler’s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。 φ函数的值 通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn),其中p1,p2……pn为x的所有质因数，x是不为0的整数。φ(1)=1（唯一和1互质的数(小于等于1)就是1本身）。(注意：每种质因数只一个。比如12=223那么φ(12)=12(1-1/2)(1-1/3)=4） 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int Euler (int n)&#123; int i, res = n; for (i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) &#123; n /= i; res = res - res / i; while (n % i == 0) n /= i; &#125; &#125; if (n &gt; 1) res = res - res / n; return res;&#125;int main(int argc, char const *argv[])&#123; int n; while (scanf (&quot;%d&quot;, &amp;n), n) printf (&quot;%d\\n&quot;, Euler(n)); return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2498 StuPId","slug":"POJ-2498-StuPId","date":"2014-08-16T16:12:54.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/16/POJ-2498-StuPId/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2498-StuPId/","excerpt":"题目源地址： http://poj.org/problem?id=2498 理解英文题= =。按照{9,3,7}的顺序，从后往前乘，最后的乘积相加可以被十整除。但是有一个数字看不清了，要求计算出那个数字，并且输出整个数。","text":"题目源地址： http://poj.org/problem?id=2498 理解英文题= =。按照{9,3,7}的顺序，从后往前乘，最后的乘积相加可以被十整除。但是有一个数字看不清了，要求计算出那个数字，并且输出整个数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int t, testCase, i, v[3] = &#123;9, 3, 7&#125;; char num[10]; scanf(&quot;%d&quot;, &amp;testCase); for (t = 1; t &lt;= testCase; t ++) &#123; scanf(&quot;%s&quot;, num); int sum = 0, p = 0, w, k; for (i = strlen(num) - 1; i &gt;= 0; i --) &#123; if (num[i] == &apos;?&apos;) &#123; w = v[p]; k = i; &#125; else sum += (num[i] - &apos;0&apos;) * v[p]; p ++; if (p == 3) p = 0; &#125; for (i = 0; i &lt; 10; i ++) if ((sum + i * w) % 10 == 0) &#123; num[k] = &apos;0&apos; + i; printf(&quot;Scenario #%d:\\n%s\\n\\n&quot;, t, num); break; &#125; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2371 Questions and answers","slug":"POJ-2371-Questions-and-answers","date":"2014-08-16T15:35:31.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2371-Questions-and-answers/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2371-Questions-and-answers/","excerpt":"题目源地址： http://poj.org/problem?id=2371 理解排序题，输出制定的i-th的数。","text":"题目源地址： http://poj.org/problem?id=2371 理解排序题，输出制定的i-th的数。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;const int maxn = 100010;int a[maxn];int main(int argc, char const *argv[])&#123; int n, k; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; int i; for (i = 1 ; i &lt;= n ; ++i) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a + 1, a + 1 + n); char str[maxn]; scanf(&quot;%s&quot;, &amp;str); scanf(&quot;%d&quot;, &amp;k); for (i = 1 ; i &lt;= k ; ++i) &#123; int b; scanf(&quot;%d&quot;, &amp;b); printf(&quot;%d\\n&quot;, a[b]); &#125; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2350 Above Average","slug":"POJ-2350-Above-Average","date":"2014-08-16T15:23:55.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2350-Above-Average/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2350-Above-Average/","excerpt":"题目源地址： http://poj.org/problem?id=2350 理解成绩高于平均成绩的百分比，数据不大，直接暴力做。","text":"题目源地址： http://poj.org/problem?id=2350 理解成绩高于平均成绩的百分比，数据不大，直接暴力做。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int t, n, i, a[1000]; float sum, num; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; sum = 0; num = 0; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); sum += a[i]; &#125; sum /= n; for (i = 0; i &lt; n; i++) if (a[i] &gt; sum) num++; printf(&quot;%2.3f%%\\n&quot;, 100 * num / n); &#125;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2301 Beat the Spread!","slug":"POJ-2301-Beat-the-Spread!","date":"2014-08-16T15:19:47.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2301-Beat-the-Spread!/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2301-Beat-the-Spread!/","excerpt":"题目源地址： http://poj.org/problem?id=2301 理解给定两数之和以及两数之差，求解这两个数，并且要求大数先输出。","text":"题目源地址： http://poj.org/problem?id=2301 理解给定两数之和以及两数之差，求解这两个数，并且要求大数先输出。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int ii, casenum; int sum, substract; float one, two; scanf(&quot;%d&quot;, &amp;casenum); for (ii = 0; ii &lt; casenum; ii++) &#123; scanf(&quot;%d%d&quot;, &amp;sum, &amp;substract); one = (sum + substract) / 2.0; two = (sum - substract) / 2.0; if (one &gt;= 0 &amp;&amp; two &gt;= 0 &amp;&amp; one - (int)one == 0 &amp;&amp; two - (int)two == 0) &#123; printf(&quot;%d %d\\n&quot;, (int)one, (int)two); &#125; else &#123; printf(&quot;impossible\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2390 Bank Interest","slug":"POJ-2390-Bank-Interest","date":"2014-08-16T15:15:33.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2390-Bank-Interest/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2390-Bank-Interest/","excerpt":"题目源地址： http://poj.org/problem?id=2390 理解给定年利率，本金和存款年数，求解到期之后的本息和。找自信专用。","text":"题目源地址： http://poj.org/problem?id=2390 理解给定年利率，本金和存款年数，求解到期之后的本息和。找自信专用。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(void)&#123; int r, m, y; int i; double value, rate; while (scanf(&quot;%d%d%d&quot;, &amp;r, &amp;m , &amp;y) != EOF) &#123; rate = 1 + (double)r / 100.0; value = m; for (i = 0; i &lt; y; i++) &#123; value *= rate; &#125; printf(&quot;%d\\n&quot;, (int)value); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2388 Who's in the Middle","slug":"POJ-2388-Who's-in-the-Middle","date":"2014-08-16T15:12:33.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2388-Who's-in-the-Middle/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2388-Who's-in-the-Middle/","excerpt":"题目源地址： http://poj.org/problem?id=2388 理解纯排序题，直接用sort水过。","text":"题目源地址： http://poj.org/problem?id=2388 理解纯排序题，直接用sort水过。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int i, N; cin &gt;&gt; N; vector&lt;int&gt;arr(N); for (i + 0; i &lt; N; i++) cin &gt;&gt; arr[i]; sort(arr.begin(), arr.end()); cout &lt;&lt; arr[N / 2] &lt;&lt; endl; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2229 Sumsets","slug":"POJ-2229-Sumsets","date":"2014-08-16T15:05:56.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2229-Sumsets/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2229-Sumsets/","excerpt":"题目源地址： http://poj.org/problem?id=2229 理解比较简单的DP：当n为奇数时，有dp[n] = dp[n-1]当n为偶数时，可以根据1的存在与否分成两种情况： 有1，则有dp[n]的一部分是dp[n-2] 没有1，则有dp[n]的另一部分是d[n/2]","text":"题目源地址： http://poj.org/problem?id=2229 理解比较简单的DP：当n为奇数时，有dp[n] = dp[n-1]当n为偶数时，可以根据1的存在与否分成两种情况： 有1，则有dp[n]的一部分是dp[n-2] 没有1，则有dp[n]的另一部分是d[n/2] 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;const int M = 1000000000;const int MAXN = 1000010;int dp[MAXN];int main(int argc, char const *argv[])&#123; int n; scanf(&quot;%d&quot;, &amp;n); dp[0] = dp[1] = 1; for (int i = 2; i &lt;= n; ++i) if (i &amp; 0x01) dp[i] = dp[i - 1]; else dp[i] = (dp[i - 2] + dp[i &gt;&gt; 1]) % M; printf(&quot;%d\\n&quot;, dp[n]); return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2249 Binomial Showdown","slug":"POJ-2249-Binomial-Showdown","date":"2014-08-16T14:59:02.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2249-Binomial-Showdown/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2249-Binomial-Showdown/","excerpt":"题目源地址： http://poj.org/problem?id=2249 理解求二项式，直接使用二项式定理～","text":"题目源地址： http://poj.org/problem?id=2249 理解求二项式，直接使用二项式定理～ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; long long int n, k; while ( scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k) != EOF &amp;&amp; n ) &#123; long long int sum = 1; int x = 1; if ( k == 0 ) &#123; printf(&quot;1\\n&quot;); continue; &#125; if ( k &gt; n - k ) k = n - k; for (int i = n; i &gt; n - k; i--) &#123; sum *= i; sum /= x; x++; &#125; printf(&quot;%lld\\n&quot;, sum); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2231 Moo Volume","slug":"POJ-2231-Moo-Volume","date":"2014-08-16T14:52:02.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2231-Moo-Volume/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2231-Moo-Volume/","excerpt":"题目源地址： http://poj.org/problem?id=2231 理解打表找规律，排序之后发现： 1 2 3 4 50 1 2 3 41 0 1 2 32 1 0 1 23 2 1 0 14 3 2 1 0 把下面矩阵的所有数字相加就是所求的结果。","text":"题目源地址： http://poj.org/problem?id=2231 理解打表找规律，排序之后发现： 1 2 3 4 50 1 2 3 41 0 1 2 32 1 0 1 23 2 1 0 14 3 2 1 0 把下面矩阵的所有数字相加就是所求的结果。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main()&#123; long long int ans = 0, arr[10010]; int n, m; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr, arr + n); for (int i = 0; i &lt; n; ++i) &#123; ans += (n - 1 - i) * (arr[n - 1 - i] - arr[i]); &#125; cout &lt;&lt; ans * 2 &lt;&lt; endl; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2262 Goldbach's Conjecture","slug":"POJ-2262-Goldbach's-Conjecture","date":"2014-08-16T14:46:12.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2262-Goldbach's-Conjecture/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2262-Goldbach's-Conjecture/","excerpt":"题目源地址： http://poj.org/problem?id=2262 理解给定大于6的偶数X，求满足X=a+b且|a-b|最大的那对，直接暴力做，事实上，找到的第一对就是满足条件的那对。","text":"题目源地址： http://poj.org/problem?id=2262 理解给定大于6的偶数X，求满足X=a+b且|a-b|最大的那对，直接暴力做，事实上，找到的第一对就是满足条件的那对。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int s[500020];int flag[1000002] = &#123;0&#125;;void init()&#123; int k = 1; for (int i = 2; i &lt;= 1000000; i += 2) flag[k] = 1; for (int i = 3; i &lt;= 1000000; i += 2) &#123; if (!flag[i]) &#123; s[k++] = i; for (int j = 2 * i; j &lt;= 1000000; j += i) flag[j] = 1; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); long n, i; while (scanf(&quot;%ld&quot;, &amp;n), n) &#123; if (n % 2 == 1) continue; long long p = n / 2 + 1; for (i = 1; s[i] &lt;= p; i++) &#123; int k = n - s[i]; if (!flag[k]) &#123; printf(&quot;%ld = %d + %d\\n&quot;, n, s[i], k); break; &#125; &#125; if (i &gt; p) printf(&quot;Goldbach&apos;s conjecture is wrong.\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2196 Specialized Four-Digit Numbers","slug":"POJ-2196-Specialized-Four-Digit-Numbers","date":"2014-08-16T14:41:33.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2196-Specialized-Four-Digit-Numbers/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2196-Specialized-Four-Digit-Numbers/","excerpt":"题目源地址： http://poj.org/problem?id=2196 理解直接暴力做，逐个判断是不是符合条件。","text":"题目源地址： http://poj.org/problem?id=2196 理解直接暴力做，逐个判断是不是符合条件。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int n, a[17];void f(int x)&#123; int temp = n; while (temp != 0) &#123; a[x] += temp % x; temp /= x; &#125;&#125;int main()&#123; for (n = 2992; n &lt;= 9999; n++) &#123; a[16] = a[12] = a[10] = 0; f(12); f(16); f(10); if (a[16] == a[10] &amp;&amp; a[10] == a[12]) cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2192 Zipper","slug":"POJ-2192-Zipper","date":"2014-08-16T14:35:52.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2192-Zipper/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2192-Zipper/","excerpt":"题目源地址： http://poj.org/problem?id=2192 理解动态规划的核心方程：b.dp[i][j-1]==1&amp;&amp;str2[j-1]==str3[i+j-1]","text":"题目源地址： http://poj.org/problem?id=2192 理解动态规划的核心方程：b.dp[i][j-1]==1&amp;&amp;str2[j-1]==str3[i+j-1] 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char st1[205];char st2[205];char st3[410];int dp[205][205];int main(int argc, char const *argv[])&#123; int n; scanf(&quot;%d&quot;, &amp;n); int k = 0; while (n--) &#123; k++; scanf(&quot;%s %s %s&quot;, st1, st2, st3); getchar(); int k1 = strlen(st1); int k2 = strlen(st2); memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for (int i = 0; i &lt;= k1; i++) &#123; for (int j = 0; j &lt;= k2; j++) &#123; if (i &gt;= 1 &amp;&amp; dp[i - 1][j] == 1 &amp;&amp; st1[i - 1] == st3[i + j - 1]) dp[i][j] = 1; if (j &gt;= 1 &amp;&amp; dp[i][j - 1] == 1 &amp;&amp; st2[j - 1] == st3[i + j - 1]) dp[i][j] = 1; &#125; &#125; if (dp[k1][k2] == 1) printf(&quot;Data set %d: yes\\n&quot;, k); else printf(&quot;Data set %d: no\\n&quot;, k); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2190 ISBN","slug":"POJ-2190-ISBN","date":"2014-08-16T14:25:01.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2190-ISBN/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2190-ISBN/","excerpt":"题目源地址： http://poj.org/problem?id=2190 理解题目不难，只需求解给定一个数为ISBN数十，？上那个数字代表的是几。需要考虑的一些特殊情况： 无解的时候，输出-1 末尾数为10的时候，输出X 如果结果没有修改，要直接初始化为-1","text":"题目源地址： http://poj.org/problem?id=2190 理解题目不难，只需求解给定一个数为ISBN数十，？上那个数字代表的是几。需要考虑的一些特殊情况： 无解的时候，输出-1 末尾数为10的时候，输出X 如果结果没有修改，要直接初始化为-1 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char str[15];int main(int argc, char const *argv[])&#123; int at, end; int i, j; int sum, result; while (scanf(&quot;%s&quot;, str) != EOF) &#123; sum = 0; for (i = 0; i &lt; 10; i++) &#123; if (str[i] == &apos;?&apos;) &#123; at = 10 - i; &#125; else &#123; if (str[i] != &apos;X&apos;) &#123; sum += (str[i] - &apos;0&apos;) * (10 - i); &#125; else &#123; sum += 10; &#125; &#125; &#125; end = (at == 1 ? 10 : 9); result = -1; for (i = 0; i &lt;= end; i++) &#123; if ((sum + (i * at)) % 11 == 0) &#123; result = i; break; &#125; &#125; if (result != 10) &#123; printf(&quot;%d\\n&quot;, result); &#125; else if (result == 10 &amp;&amp; at == 1) &#123; printf(&quot;X\\n&quot;); &#125; else &#123; printf(&quot;-1\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2141 Message Decowding","slug":"POJ-2141-Message-Decowding","date":"2014-08-16T00:50:06.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2141-Message-Decowding/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2141-Message-Decowding/","excerpt":"题目源地址： http://poj.org/problem?id=2141 理解简单的密码转换，注意输出，要以大写字母输出。","text":"题目源地址： http://poj.org/problem?id=2141 理解简单的密码转换，注意输出，要以大写字母输出。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char keys[30];int main(int argc, char const *argv[])&#123; int i, j; char tmp; while (scanf(&quot;%s&quot;, keys) != EOF) &#123; getchar(); while ((tmp = getchar()) != &apos;\\n&apos;) &#123; if (tmp &gt;= &apos;a&apos; &amp;&amp; tmp &lt;= &apos;z&apos;) &#123; putchar(keys[tmp - &apos;a&apos;]); &#125; else if (tmp &gt;= &apos;A&apos; &amp;&amp; tmp &lt;= &apos;Z&apos;) &#123; putchar((keys[tmp - &apos;A&apos;] - 32)); &#125; else &#123; putchar(tmp); &#125; &#125; putchar(tmp); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2316 SPIN","slug":"POJ-2316-SPIN","date":"2014-08-16T00:40:30.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2316-SPIN/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2316-SPIN/","excerpt":"题目源地址： http://poj.org/problem?id=2316 理解所有数据相加，再对10取模，因为每个字符串的长度都是相同的～","text":"题目源地址： http://poj.org/problem?id=2316 理解所有数据相加，再对10取模，因为每个字符串的长度都是相同的～ 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int a[11] = &#123;0&#125;, i; char b[11]; while (cin &gt;&gt; b) &#123; for (i = 0; i &lt; strlen(b); i++) a[i] += b[i] - &apos;0&apos;; &#125; for (i = 0; i &lt; strlen(b); i++) &#123; a[i] %= 10; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2136 Vertical Histogram","slug":"POJ-2136-Vertical-Histogram","date":"2014-08-16T00:37:49.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2136-Vertical-Histogram/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2136-Vertical-Histogram/","excerpt":"题目源地址： http://poj.org/problem?id=2136 理解题目不难，但是最后的输出各种蛋疼，慢慢调试吧。。。。","text":"题目源地址： http://poj.org/problem?id=2136 理解题目不难，但是最后的输出各种蛋疼，慢慢调试吧。。。。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; char ch; int i, j; int a[27], b[300][27], m[300]; memset(a, 0, sizeof(a)); while (~scanf(&quot;%c&quot;, &amp;ch)) if (ch &lt;= &apos;Z&apos; &amp;&amp; ch &gt;= &apos;A&apos;) a[ch - &apos;A&apos;]++; int maxlen = 0; for (i = 0; i &lt; 26; i++) &#123; if (a[i] &gt; maxlen) maxlen = a[i]; &#125; for (i = 0; i &lt; 26; i++) for (j = a[i]; j &gt; 0; j--) b[j][i] = 1; for (i = maxlen; i &gt; 0; i--) for (j = 25; j &gt;= 0; j--) &#123; if (b[i][j] == 1) &#123; m[i] = j; break; &#125; &#125; for (i = maxlen; i &gt; 0; i--) &#123; for (j = 0; j &lt;= m[i]; j++) &#123; if (b[i][j] == 1) printf(&quot;*&quot;); else printf(&quot; &quot;); if (j == m[i]) printf(&quot;\\n&quot;); else printf(&quot; &quot;); &#125; &#125; for (i = 0; i &lt; 25; i++) printf(&quot;%c &quot;, (char)(i + &apos;A&apos;)); printf(&quot;%c\\n&quot;, (char)(i + &apos;A&apos;)); return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2140 Herd Sums","slug":"POJ-2140-Herd-Sums","date":"2014-08-16T00:28:06.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2140-Herd-Sums/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2140-Herd-Sums/","excerpt":"题目源地址： http://poj.org/problem?id=2140 理解很有意思的一道题，很显然，i不会超过n/2。如果是奇数，我只要考虑最中间的两个数；如果是奇数，我只要在上面计算的结果上再加1。","text":"题目源地址： http://poj.org/problem?id=2140 理解很有意思的一道题，很显然，i不会超过n/2。如果是奇数，我只要考虑最中间的两个数；如果是奇数，我只要在上面计算的结果上再加1。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int i, n; int counts = 0; scanf(&quot;%d&quot;, &amp;n); for (i = 1; i &lt;= n / 2; i += 2) if (n % i == 0) counts++; if (n % 2 != 0) counts++; printf(&quot;%d\\n&quot;, counts); return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2105 IP Address","slug":"POJ-2105-IP-Address","date":"2014-08-16T00:24:31.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2105-IP-Address/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2105-IP-Address/","excerpt":"题目源地址： http://poj.org/problem?id=2105 理解将表示IP地址的二位数转换成十进制并且分段，使用字符数组即可。","text":"题目源地址： http://poj.org/problem?id=2105 理解将表示IP地址的二位数转换成十进制并且分段，使用字符数组即可。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char str[50];int bin[10] = &#123;128, 64, 32, 16, 8, 4, 2, 1&#125;;int IPAddress(char str[])&#123; int sum = 0; int i; for (i = 0; i &lt; 8; i++) &#123; if (str[i] == &apos;1&apos;) &#123; sum += bin[i]; &#125; &#125; return sum;&#125;int main(int argc, char const *argv[])&#123; int casenum, ii; scanf(&quot;%d&quot;, &amp;casenum); getchar(); for (ii = 0; ii &lt; casenum ; ii++) &#123; gets(str); printf(&quot;%d.%d.%d.%d\\n&quot;, IPAddress(str), IPAddress(str + 8), IPAddress(str + 16), IPAddress(str + 24)); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2070 Filling Out the Team","slug":"POJ-2070-Filling-Out-the-Team","date":"2014-08-16T00:19:37.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2070-Filling-Out-the-Team/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2070-Filling-Out-the-Team/","excerpt":"题目源地址： http://poj.org/problem?id=2070 理解简单的计算题，理解题意之后，就是比较一下浮点数的值。","text":"题目源地址： http://poj.org/problem?id=2070 理解简单的计算题，理解题意之后，就是比较一下浮点数的值。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;char str[3][50] = &#123;&quot;Wide Receiver&quot;, &quot;Lineman&quot;, &quot;Quarterback&quot;&#125;;double speed[3] = &#123;4.5, 6.0, 5.0&#125;;int weight[3] = &#123;150, 300, 200&#125;;int strength[3] = &#123;200, 500, 300&#125;;int main(int argc, char const *argv[])&#123; double x; int y, z; int i, flag = 0; while (scanf(&quot;%lf%d%d&quot;, &amp;x, &amp;y, &amp;z), x != 0.0 || y != 0 || z != 0) &#123; flag = 0; for (i = 0; i &lt; 3; i++) &#123; if (speed[i] &gt;= x) &#123; if (weight[i] &lt;= y &amp;&amp; strength[i] &lt;= z) &#123; printf(&quot;%s &quot;, str[i]); flag = 1; &#125; &#125; &#125; if (flag == 0) &#123; printf(&quot;No positions&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2002 Squares","slug":"POJ-2002-Squares","date":"2014-08-16T00:15:45.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2002-Squares/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2002-Squares/","excerpt":"题目源地址： http://poj.org/problem?id=2002 理解排序之后使用二分搜索，用向量旋转的方法来确定是否可以构成正方形。","text":"题目源地址： http://poj.org/problem?id=2002 理解排序之后使用二分搜索，用向量旋转的方法来确定是否可以构成正方形。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)#define Max 2000using namespace std;struct data&#123; int x, y;&#125; node[Max];bool cmp(const data &amp;a, const data &amp;b)&#123; if (a.x == b.x) return a.y &lt; b.y; return a.x &lt; b.x;&#125;int main()&#123; int n, i, j; while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123; for (i = 0; i &lt; n; i ++) scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y); sort(node, node + n, cmp); int ans = 0; for (i = 0; i &lt; n; i ++) for (j = i + 1; j &lt; n; j ++) &#123; data tmp; tmp.x = node[i].x + node[i].y - node[j].y; tmp.y = node[i].y - node[i].x + node[j].x; if (!binary_search(node, node + n, tmp, cmp)) continue; tmp.x = node[j].x + node[i].y - node[j].y; tmp.y = node[j].y - node[i].x + node[j].x; if (!binary_search(node, node + n, tmp, cmp)) continue; ans ++; &#125; printf(&quot;%d\\n&quot;, ans / 2); &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2027 No Brainer","slug":"POJ-2027-No-Brainer","date":"2014-08-16T00:11:09.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/16/POJ-2027-No-Brainer/","link":"","permalink":"https://xuanwo.org/2014/08/16/POJ-2027-No-Brainer/","excerpt":"题目源地址： http://poj.org/problem?id=2027 理解超级大水题= =，比较一下X和Y的大小。","text":"题目源地址： http://poj.org/problem?id=2027 理解超级大水题= =，比较一下X和Y的大小。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int casenum, ii; int a, b; scanf(&quot;%d&quot;, &amp;casenum); for (ii = 0; ii &lt; casenum; ii++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); if (a &lt; b) &#123; printf(&quot;NO BRAINS\\n&quot;); &#125; else &#123; printf(&quot;MMM BRAINS\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1781 In Danger","slug":"POJ-1781-In-Danger","date":"2014-08-15T20:46:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/15/POJ-1781-In-Danger/","link":"","permalink":"https://xuanwo.org/2014/08/15/POJ-1781-In-Danger/","excerpt":"题目源地址： http://poj.org/problem?id=1781 理解同样的，打表找规律，发现当n是2的次方幂时，结果都是1；当n不是2的次方幂时，结果是与比n大的最小的2的次方幂的差值的两倍。","text":"题目源地址： http://poj.org/problem?id=1781 理解同样的，打表找规律，发现当n是2的次方幂时，结果都是1；当n不是2的次方幂时，结果是与比n大的最小的2的次方幂的差值的两倍。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int p[30];int main(int argc, char const *argv[])&#123; for (int i = 0; i &lt;= 27; i++) &#123; p[i] = 1 &lt;&lt; i; &#125; char s[10]; int i; while (~scanf(&quot;%s&quot;, s)) &#123; if (strcmp(s, &quot;00e0&quot;) == 0) break; int n; n = (s[0] - &apos;0&apos;) * 10 + s[1] - &apos;0&apos;; for (i = 1; i &lt;= s[3] - &apos;0&apos;; i++) n = n * 10; for (i = 0; i &lt;= 27; i++) if (p[i] &gt;= n) break; if (p[i] == n) printf(&quot;1\\n&quot;); else printf(&quot;%d\\n&quot;, (n - p[i - 1]) * 2 + 1); &#125; return 0;&#125; 更新日志 2014年08月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3372 Candy Distribution","slug":"POJ-3372-Candy-Distribution","date":"2014-08-15T20:41:15.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/15/POJ-3372-Candy-Distribution/","link":"","permalink":"https://xuanwo.org/2014/08/15/POJ-3372-Candy-Distribution/","excerpt":"题目源地址： http://poj.org/problem?id=3372 理解找规律的题目，照例打表，发现只有2的次方才符合规律。","text":"题目源地址： http://poj.org/problem?id=3372 理解找规律的题目，照例打表，发现只有2的次方才符合规律。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int n;int main(int argc, char const *argv[])&#123; while (~scanf(&quot;%d&quot;, &amp;n)) cout &lt;&lt; (n &amp; n - 1 ? &quot;NO&quot; : &quot;YES&quot;) &lt;&lt;endl; return 0;&#125; 更新日志 2014年08月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1969 Count on Canton","slug":"POJ-1969-Count-on-Canton","date":"2014-08-15T19:28:52.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/15/POJ-1969-Count-on-Canton/","link":"","permalink":"https://xuanwo.org/2014/08/15/POJ-1969-Count-on-Canton/","excerpt":"题目源地址： http://poj.org/problem?id=1969 理解一道找规律的题目，只要把奇偶分开处理，结果很快出来了。","text":"题目源地址： http://poj.org/problem?id=1969 理解一道找规律的题目，只要把奇偶分开处理，结果很快出来了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;int main(int argc, char const *argv[])&#123; int a, b; int temp_a, temp_b; int i, n; int num; while (cin &gt;&gt; num) &#123; temp_a = 0; temp_b = 0; for (n = 1 ; temp_a != num ; n ++) &#123; if (n % 2 == 0) for (i = 1 ; i &lt;= n &amp;&amp; temp_a != num ; i ++) &#123; a = i; temp_a ++; &#125; else for (i = n ; i &gt; 0 &amp;&amp; temp_a != num ; i --) &#123; a = i; temp_a ++; &#125; &#125; for (n = 1; temp_b != num ; n ++) &#123; if (n % 2 == 0) for (i = n; i &gt; 0 &amp;&amp; temp_b != num; i -- ) &#123; b = i; temp_b ++; &#125; else for (i = 1; i &lt;= n &amp;&amp; temp_b != num; i++) &#123; b = i; temp_b ++; &#125; &#125; cout &lt;&lt; &quot;TERM &quot; &lt;&lt; num &lt;&lt; &quot; IS &quot; &lt;&lt; a &lt;&lt; &quot;/&quot; &lt;&lt; b &lt;&lt; endl; &#125;&#125; 更新日志 2014年08月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"Hexo常见问题解决方案","slug":"hexo-usual-problem","date":"2014-08-14T05:20:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/08/14/hexo-usual-problem/","link":"","permalink":"https://xuanwo.org/2014/08/14/hexo-usual-problem/","excerpt":"介绍Hexo是一个非常好用的静态博客生成器，但是由于很多方面的原因，导致在使用过程中经常出现错误。这些错误中，有些是因为自己的设置不当，导致程序报错；有些是因为版本更迭，导致原有的设置失效；而有些，则是Hexo程序本身的BUG。本文旨在尽可能的解决前两类问题，缓解Hexo项目大量重复issues的现象。当然，我个人的力量是有限的，因此也希望使用Hexo的大家也能一起行动起来，通过提交PR，发布issues或者在下方评论等形式参与到本文档的编辑中来。同时，也希望有能力的人可以将本文档翻译成英文，以帮助到更多的人。浏览时，使用Ctrl+F搜索关键词或使用目录来定位问题。 本文欢迎转载，但是恳请保留贡献者信息，谢谢。","text":"介绍Hexo是一个非常好用的静态博客生成器，但是由于很多方面的原因，导致在使用过程中经常出现错误。这些错误中，有些是因为自己的设置不当，导致程序报错；有些是因为版本更迭，导致原有的设置失效；而有些，则是Hexo程序本身的BUG。本文旨在尽可能的解决前两类问题，缓解Hexo项目大量重复issues的现象。当然，我个人的力量是有限的，因此也希望使用Hexo的大家也能一起行动起来，通过提交PR，发布issues或者在下方评论等形式参与到本文档的编辑中来。同时，也希望有能力的人可以将本文档翻译成英文，以帮助到更多的人。浏览时，使用Ctrl+F搜索关键词或使用目录来定位问题。 本文欢迎转载，但是恳请保留贡献者信息，谢谢。 常见错误本地浏览没问题，Deploy报错Git环境配置错误问题描述： Windows系统出现报错信息如下 [info] Start deploying: git[info] Setting up Git deployment...[error] Error: spawn ENOENTError: spawn ENOENT at errnoException (child_process.js:1000:11) at Process.ChildProcess._handle.onexit (child_process.js:791:34)events.js:72 throw er; // Unhandled &apos;error&apos; event ^Error: spawn ENOENT at errnoException (child_process.js:1000:11) at Process.ChildProcess._handle.onexit (child_process.js:791:34) 解决方案： 检查Git的相关配置，将git所在目录添加到系统path中去。 Deploy设置错误问题描述： 输入hexo deploy后，出现错误信息： &apos;github&apos; does not appear to be a git repository 解决方案： 检查_config.yml中deploy设置。参见http://hexo.io/docs/deployment.html。 删除.deploy_git文件夹并且执行hexo clean后，重新hexo deploy。 Deploy之后，页面长时间404问题描述： 解决方案： 检查Github Pages类型个人主页 也就是库的名称为yourname.github.io的主页，页面文件应当在master分支下，文件结构可以参考我的主页，也就是应当以HTML文件为主，是没有Markdown文件的。 项目主页 也就是库名不是yourname.github.io的主页，页面文件应当在gh-pages分支下，文件结构与个人主页基本一致，同样没有Markdown文件。 检查Github验证邮件曾经出现过所有操作都没有问题但就是404的状况，新创建的用户最好都去看看是不是验证邮件没有通过。 注意库的名字现在大多改成.io结尾域名了，但是不确定是不是真的跟这个有关，最好改成.io。 自有域名二级目录无法访问问题描述参见issue820 问题分析 问题出在CNAME跳转，下面附上我的分析，如果不感兴趣可以直接翻到解决方案。 &gt;如果没有CNAME跳转，访问yourname.github.io/repo会自动地去访问gh-pages分支下的静态文件。但是一旦进行了CNAME跳转，访问yourname.github.io/repo就会自动跳转为yoursite.com/repo，显然在你的博客目录下是没有这个文件夹的，所以自然而然的会出现访问404错误。 解决方案 增加一个新的DNS记录 修改自己域名的DNS记录，增加一条记录（A记录或者CNAME都可以，指向github），内容是repo.yoursite.com，访问时通过repo.yoursite.com来访问。 将这个库移动到博客目录下 按照上述的分析，把这个库的repo移动至博客目录下即可。注意修改html以免被hexo再次渲染，还有如果是直接复制或者clone，注意删除隐藏的.git文件夹。 Hexo命令失效问题描述： 输入命令后出现如下信息： localhost:~ apple$ hexo new &quot;title&quot;Usage: hexoCommands:help Get help on a commandinit Create a new Hexo foldermigrate Migrate your site from other system to Hexoversion Display version informationGlobal Options:--debug Display all verbose messages in the terminal--safe Disable all plugins and scriptsFor more help, you can use hexo help [command] for the detailed informationor you can check the docs: http://zespia.tw/hexo/docs/ 解决方案： 检查_config.yml中的内容，特别注意:后面需要有一个空格。 检查`package.json’中的内容，注意添加hexo信息用来标识这是一个hexo目录： &#123; &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;&#125; 如果还是有问题，可以更新hexo之后，在新的文件夹中重新进行hexo init。 Hexo所有命令报错问题描述： 参见Issues报错信息如下： [error] &#123; name: &apos;HexoError&apos;, reason: &apos;end of the stream or a document separator is expected&apos;, mark: &#123; name: null, buffer: &apos;# Hexo Configuration\\n## Docs: http://hexo.io/docs/configuration.html\\n## Source: https://github.com/tommy351/hexo/\\n\\n# Site\\ntitle: 2hu\\nsubtitle:\\ndescription: 2hu\\nauthor: @2hu10n92hen9\\nemail:\\nlanguage:\\n\\n# URL\\n## If your site is put in a subdirectory, set url as \\&apos;http://yoursite.com/child\\&apos; and root as \\&apos;/child/\\&apos;\\nurl: http://2hu.me\\nroot: /\\npermalink: :year/:month/:day/:title/\\ntag_dir: tags\\narchive_dir: archives\\ncategory_dir: categories\\ncode_dir: downloads/code\\n\\n# Directory\\nsource_dir: source\\npublic_dir: public\\n\\n# Writing\\nnew_post_name: :year-:month-:day-:title.md # File name of new posts\\ndefault_layout: post\\nauto_spacing: false # Add spaces between asian characters and western characters\\ntitlecase: false # Transform title into titlecase\\nexternal_link: true # Open external links in new tab\\nmax_open_file: 100\\nmulti_thread: true\\nfilename_case: 0\\nrender_drafts: false\\npost_asset_folder: false\\nhighlight:\\n enable: true\\n line_number: true\\n tab_replace:\\n\\n# Category &amp; Tag\\ndefault_category: uncategorized\\ncategory_map:\\ntag_map:\\n\\n# Archives\\n## 2: Enable pagination\\n## 1: Disable pagination\\n## 0: Fully Disable\\narchive: 2\\ncategory: 2\\ntag: 2\\n\\n# Server\\n## Hexo uses Connect as a server\\n## You can customize the logger format as defined in\\n## http://www.senchalabs.org/connect/logger.html\\nport: 4000\\nserver_ip: 0.0.0.0\\nlogger: false\\nlogger_format:\\n\\n# Date / Time format\\n## Hexo uses Moment.js to parse and display date\\n## You can customize the date format as defined in\\n## http://momentjs.com/docs/#/displaying/format/\\ndate_format: MMM D YYYY\\ntime_format: H:mm:ss\\n\\n# Pagination\\n## Set per_page to 0 to disable pagination\\nper_page: 10\\npagination_dir: page\\n\\n# Disqus\\ndisqus_shortname: 2hu\\n\\n# Extensions\\n## Plugins: https://github.com/tommy351/hexo/wiki/Plugins\\n## Themes: https://github.com/tommy351/hexo/wiki/Themes\\ntheme: strict\\nexclude_generator:\\n\\n# Deployment\\n## Docs: http://hexo.io/docs/deployment.html\\ndeploy:\\n type: github\\n repository: https://github.com/zhulongzheng/zhulongzheng.github.io.git\\n branch: master\\n\\u0000&apos;, position: 168, line: 8, column: 8 &#125;, message: &apos;Config file load failed&apos;, domain: &#123; domain: null, _events: &#123; error: [Function] &#125;, _maxListeners: 10, members: [ [Object] ] &#125;, domainThrown: true, stack: undefined &#125; 解决方案：仔细检查_config.yml文件中所有冒号后面的空格，格式很严格，必须是只有一个，半角。不管是多了还是少了都会报错，这是yml解释器所定义的语法。如果不确定的话，将输入法调整到英文模式，删除所有冒号后面的空格重新输入，不要使用Tab。 更新至2.8.X版本后，构建失败问题描述：输入hexo g后，报错如下： [error] &#123; name: &apos;HexoError&apos;, reason: &apos;incomplete explicit mapping pair; a key node is missed&apos;, mark: &#123; name: null, buffer: &apos;categories: Categories\\nsearch: Search\\ntags: Tags\\ntagcloud: Tag Cloud\\ntweets: Tweets\\nprev: Prev\\nnext: Next\\ncomment: Comments\\narchive_a: Archives\\narchive_b: Archives: %s\\npage: Page %d\\nrecent_posts: Recent Posts\\ndescription: Description\\nread_more: Read More\\n\\u0000&apos;, position: 163, line: 9, column: 19 &#125;, message: &apos;Process failed: languages/default.yml&apos;, domain: &#123; domain: null, _events: &#123; error: [Function] &#125;, _maxListeners: 10, members: [ [Object] ] &#125;, domainThrown: true, stack: undefined &#125; 解决方案： 主题目录下所有yml文件中所有有空格的字段都用双引号括起来，尤其注意languages下面的yml文件。感谢@dukewan提供的截图 修改主题文件之后，网页不更新问题描述： 在修改主题文件之后，页面的文件依然没有更新。 解决方案： hexo clean并且删除.deploy_git文件夹之后，hexo d -g。为了强制浏览器更新资源文件，可以采用’Ctrl+F5’来刷新。 页面没有渲染（partial转义失败）问题描述： 参见Issues看不到渲染后的页面，只能看到类似如下信息： &lt;%- partial(&apos;_partial/head&apos;) %&gt;&lt;%- partial(&apos;_partial/header&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt;&lt;%- body %&gt;&lt;% if (theme.sidebar &amp;&amp; theme.sidebar !== &apos;bottom&apos;)&#123; %&gt; &lt;%- partial(&apos;_partial/sidebar&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;% &#125; %&gt;&lt;%- partial(&apos;_partial/footer&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt;&lt;%- partial(&apos;_partial/mobile-nav&apos;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;%- partial(&apos;_partial/after-footer&apos;) %&gt; 解决方案： 在博客所在目录下执行’npm install’用以安装插件。 感谢@tommy351提供的解决方案 更新至3.0.0版本后，文件渲染时卡死问题描述： 参见Issues表现为文件不多，但是渲染非常缓慢，超过半个小时。 问题分析： 问题出在Highlight.js在判断语言类型时，会因为-这个符号导致卡死。 解决方案： 在使用代码块时，明确使用类型，或者全部使用plain类型，如下： undefined 升级至Hexo 3.0版本后，deploy报错问题描述： 参见Issues升级之后，本来可以deploy的设置出现报错，内容为： ERROR Deployer not found: github 问题分析： Hexo3.0与以往版本最大的改变在于，更多的模块都从主程序中剥离了出来，其中就包括deploy的相关模块。 解决方案： 首先需要安装对应的deploy模块，目前Hexo支持以下服务器的一键部署： githerokursyncopenshift 安装命令为： npm install hexo-deployer-git --save //将git替换为别的名字就可以安装对应模块 然后对_config.yml做如下设置： deploy: type: git //非git请参考官方文档中的设置 repo: &lt;repository url&gt; branch: [branch] message: [message] Mac OS安装Hexo出错问题描述： 参见Issues命令行返回ERROR： &#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; 解决方案： 使用命令npm install hexo --no-optional 常见问题如何在不同电脑（系统）上使用Hexo使用Git来管理自己的Blog文件夹，需要注意一下几点。 如果主题是通过git管理的，需要将主题文件夹下的.git文件夹删除或者使用git submodule的形式进行管理，才能同步Blog文件夹。 Blog目录下自带的.gitignore文件，node_modules文件夹是不会同步的，所以同步之后需要自己再次进行npm install，但是注意，不要进行hexo init了，否则_config.yml会被覆盖。 然后看一下同步之后的目录结构：https://github.com/Xuanwo/xuanwo.github.io/tree/blog 使用git submodule来管理主题Todo 在主目录下添加README.md文件或者html文件Hexo3.0以下使用感谢@TimNew提供的思路 正如大家所知道的，在source文件夹下的所有md文件都会被hexo渲染成html文件，导致README.md文件不能好好的放在里面了，即使是添加了layout: false依然没有用。 不过现在有一个另外的好办法，那就是利用主题的source目录，也就是themes/themes-name/source。因为这个文件夹里面的所有文件都会被复制到网站的根目录中去，也就是说，如果在里面放上README，就可以正常的存在于网站的主目录了。 同样的，对于一些需要在网站下添加html文件的需求也可以这样来达成。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个html文件。同样的，只要把这个文件放在themes/themes-name/source就可以搞定了。 Hexo3.0以上支持使用_config.yml下的skip_render参数。 skip_render使用了minimatch，开始匹配的位置是基于你的source_dir的，一般来说，是你的source文件夹下。下面我分别列举几种常见的情况进行说明： 请注意yml中的文件格式，输入单个数据请注意空格，输入数组请进行缩进 单个文件夹下全部文件：skip_render: test/* 单个文件夹下指定类型文件：skip_render: test/*.md 单个文件夹下全部文件以及子目录:skip_render: test/** 多个文件夹以及各种复杂情况： skip_render: - `test1/*.html` - `test2/**` Hexo版本回退有时候更新之后发现新版本的Hexo不能按照预期的方式工作，这时候就需要使用版本回退功能。打开命令行，输入npm install -g hexo@版本号就可以回退到没有出现问题的版本上来。 这个命令适用于所有Node.js模块 少数情况下会出现Node.js版本问题，可以使用nvm install 版本号来安装报错信息中需要的版本。 推荐使用nvm来管理Node.js版本 如何为站点添加社会化评论使用DisqueHexo默认支持Disque，打开_config.yml，在disqus_shortname:后面输入自己的Disque账号。保存，重新渲染，清除缓存之后就能看到自己的评论窗口。 使用Duoshuo部分主题添加了对多说的支持，只要输入Duoshuo账号，就可以看到效果了。如果主题不支持的话，就需要自己添加。需要对自己的主题结构有一定的了解，不是每一个主题都会有一样的文件，找不到同样的文件也正常，但是都会存在相同功能的区块，自己去定位即可。如果没把握的话，最后做好备份。 在after_footer.ejs模块中输入如下代码： &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type=&quot;text/javascript&quot;&gt;var duoshuoQuery = &#123;short_name:&quot;yourshortname&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt; 在article.ejs模块中输入如下代码： &lt;% if (page.comments)&#123; %&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%- page.path %&gt;&quot; data-title=&lt;%- page.title %&gt; data-url=&lt;%- page.permalink %&gt;&gt;&lt;% &#125; %&gt; 如何避免在Deploy时输入密码使用Github客户端安装好Github客户端之后，使用Github客户端内置的Git Shell进行hexo的部署操作。 自行生成SSH key使用Github客户端可以免去输入密码操作的原因就是客户端在本地生成了一个SSH key并且添加到了Github网站中。不喜欢使用Github客户端的童鞋可以参考下面的流程自行生成SSH key。使用Github SSH Key以免去Hexo部署时输入密码 多git部署参考hexo-deployer-git插件README进行配置： deploy: type: git message: [message] repo: github: &lt;repository url&gt;,[branch] gitcafe: &lt;repository url&gt;,[branch] 请注意每一个冒号后面的空格，如果丢失会导致yml文件读取错误。 开启全站httpsTodo 贡献者 @Xuanwo @TimNew @tommy351 更新日志 2014年08月14日 完成大体框架，内容慢慢填充 2014年08月23日 补充404问题，以及如何在不同电脑（系统）上使用Hexo 2014年09月06日 新增自有域名二级目录无法访问，在主目录下添加md文件 2014年09月09日 新增Hexo版本回退，Hexo所有命令报错。 2014年09月23日 新增Partial没有转义 2014年09月24日 新增添加社会化评论 2015年02月06日 新增本地添加SSH key，修复部分笔误 2015年02月07日 SSH key生成独立成篇 2015年04月01日 添加了部分Hexo3.0带来的问题，新增了skip_render参数设置 2015年04月03日 添加了Hexo3.0中deploy设置 2015年08月09日 添加了多git部署，Mac OS安装出错，更新了skip_render参数设置以及部分文本说明 2015年09月05日 添加了开启全站https以及主题管理，修复了代码显示BUG，删除了部分口水话","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://xuanwo.org/tags/Hexo/"},{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"POJ 1953 World Cup Noise","slug":"POJ-1953-World-Cup-Noise","date":"2014-08-12T05:19:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/12/POJ-1953-World-Cup-Noise/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1953-World-Cup-Noise/","excerpt":"题目源地址： http://poj.org/problem?id=1953 理解稍微推了几个，发现是斐波那契数列，水之。","text":"题目源地址： http://poj.org/problem?id=1953 理解稍微推了几个，发现是斐波那契数列，水之。 代码#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; __int64 x[46] = &#123;0, 2, 3, 5, 8,&#125;; int T, i, ans, a, c = 1; scanf(&quot;%d&quot;, &amp;T); for (i = 5 ; i &lt; 46; ++i) x[i] = x[i - 1] + x[i - 2]; do &#123; scanf(&quot;%d&quot;, &amp;a); printf(&quot;Scenario #%d:\\n&quot;, c++); printf(&quot;%I64d\\n\\n&quot;, x[a]); &#125; while (--T); return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1833 排列","slug":"POJ-1833-Permutation","date":"2014-08-12T05:12:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/12/POJ-1833-Permutation/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1833-Permutation/","excerpt":"题目源地址： http://poj.org/problem?id=1833 理解再次使用next_permutation水题。不过G++会超时，C++400ms+。","text":"题目源地址： http://poj.org/problem?id=1833 理解再次使用next_permutation水题。不过G++会超时，C++400ms+。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;#define MAX 1034int ans[MAX];int main(int argc, char const *argv[])&#123; int nCases; int num, k, i, j; scanf(&quot;%d&quot;, &amp;nCases); while (nCases--) &#123; scanf(&quot;%d %d&quot;, &amp;num, &amp;k); for (i = 1; i &lt;= num; ++i) scanf(&quot;%d&quot;, &amp;ans[i]); for (i = 0; i &lt; k; ++i) next_permutation(ans + 1, ans + num + 1); for (j = 1; j &lt;= num; ++j) printf(&quot;%d &quot;, ans[j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1611 The Suspects","slug":"POJ-1611-The-Suspects","date":"2014-08-12T05:03:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/12/POJ-1611-The-Suspects/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1611-The-Suspects/","excerpt":"题目源地址： http://poj.org/problem?id=1611 理解比较简单的并查集，照着模板敲。","text":"题目源地址： http://poj.org/problem?id=1611 理解比较简单的并查集，照着模板敲。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;const int N = 30005;int n, m, f[N], s[N];int getfar(int x)&#123; return x == f[x] ? x : f[x] = getfar(f[x]);&#125;void init ()&#123; for (int i = 0; i &lt;= n; i++) &#123; f[i] = i; s[i] = 1; &#125; int k, a, b; for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;k); if (k == 0) continue; scanf(&quot;%d&quot;, &amp;a); int p = getfar(a); for (int j = 1; j &lt; k; j++) &#123; scanf(&quot;%d&quot;, &amp;b); int q = getfar(b); if (p != q) &#123; f[q] = p; s[p] += s[q]; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2 &amp;&amp; n + m) &#123; init (); printf(&quot;%d\\n&quot;, s[getfar(0)]); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1562 Oil Deposits","slug":"POJ-1562-Oil-Deposits","date":"2014-08-12T04:58:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/12/POJ-1562-Oil-Deposits/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1562-Oil-Deposits/","excerpt":"题目源地址： http://poj.org/problem?id=1562 理解使用DFS搜索石油所在的区块。","text":"题目源地址： http://poj.org/problem?id=1562 理解使用DFS搜索石油所在的区块。 代码#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;string.h&gt;using namespace std;char map[100][100];int vis[100][100];int m, n;int op[8][2] = &#123; &#123; -1, -1&#125;, &#123; -1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;1, 1&#125;, &#123; -1, 1&#125;, &#123;1, -1&#125;, &#123;0, -1&#125; &#125;;void search(int x, int y)&#123; vis[x][y] = -1; for (int i = 0; i &lt; 8; i++) if ((x + op[i][0] &gt;= 0) &amp;&amp; (x + op[i][0] &lt; m) &amp;&amp; (y + op[i][1] &gt;= 0) &amp;&amp; (y + op[i][1] &lt; n) &amp;&amp; (vis[x + op[i][0]][y + op[i][1]] != -1) &amp;&amp; map[x + op[i][0]][y + op[i][1]] == &apos;@&apos;) search(x + op[i][0], y + op[i][1]);&#125;int main(int argc, char const *argv[])&#123; int i, j, sum; while (scanf(&quot;%d %d&quot;, &amp;m, &amp;n) &amp;&amp; m) &#123; sum = 0; for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) cin &gt;&gt; map[i][j]; memset(vis, 0, sizeof(vis)); for (i = 0; i &lt; m; i++) for (j = 0; j &lt; n; j++) if (vis[i][j] != -1 &amp;&amp; map[i][j] == &apos;@&apos;) &#123; sum++; search(i, j); &#125; printf(&quot;%d\\n&quot;, sum); &#125; system(&quot;pause&quot;); return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1411 Calling Extraterrestrial Intelligence Again","slug":"POJ-1411-Calling-Extraterrestrial-Intelligence-Again","date":"2014-08-12T04:54:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1411-Calling-Extraterrestrial-Intelligence-Again/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1411-Calling-Extraterrestrial-Intelligence-Again/","excerpt":"题目源地址： http://poj.org/problem?id=1411 理解打表暴力水过，估计是因为数据弱= =。","text":"题目源地址： http://poj.org/problem?id=1411 理解打表暴力水过，估计是因为数据弱= =。 代码#include&lt;cstdio&gt;int m, a, b;bool ok[100010];int prime[100000], cnt, ansx, ansy, ans;void init()&#123; for (int i = 2; i &lt;= 100000; i++) if (!ok[i]) &#123; for (int j = i; j &lt;= 100000 / i; j++) ok[i * j] = 1; prime[++cnt] = i; &#125;&#125;int main(int argc, char const *argv[])&#123; init(); while (scanf(&quot;%d%d%d&quot;, &amp;m, &amp;a, &amp;b), m || a || b) &#123; ans = 0; for (int i = 1; i &lt;= cnt; i++) for (int j = 1; j &lt;= i; j++) if (prime[i]*prime[j] &gt; m) break; else if (prime[j]*b &gt;= prime[i]*a &amp;&amp; ans &lt; prime[i]*prime[j]) &#123; ans = prime[i] * prime[j]; ansx = prime[j]; ansy = prime[i]; &#125; printf(&quot;%d %d\\n&quot;, ansx, ansy); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1488 TEX Quotes","slug":"POJ-1488-TEX-Quotes","date":"2014-08-12T04:51:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1488-TEX-Quotes/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1488-TEX-Quotes/","excerpt":"题目源地址： http://poj.org/problem?id=1488 理解字符串处理- -，慢慢坑就是了。。注意输入方式，有空格的时候要用getline。","text":"题目源地址： http://poj.org/problem?id=1488 理解字符串处理- -，慢慢坑就是了。。注意输入方式，有空格的时候要用getline。 代码#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(int argc, char const *argv[])&#123; string a ; int count = 0; while (getline(cin, a)) &#123; for (int i = 0; i &lt; a.length(); i++) &#123; if (a[i] == &apos;\\&quot;&apos;) &#123; if (count == 0) &#123; cout &lt;&lt; &quot;``&quot;; count = 1; &#125; else &#123; count = 0; cout &lt;&lt; &quot;&apos;&apos;&quot;; &#125; &#125; else cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl; &#125;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1455 Crazy tea party","slug":"POJ-1455-Crazy-tea-party","date":"2014-08-12T04:37:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1455-Crazy-tea-party/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1455-Crazy-tea-party/","excerpt":"题目源地址： http://poj.org/problem?id=1455 理解把n分成两部分，分别排序。唉= =，不机智了。。","text":"题目源地址： http://poj.org/problem?id=1455 理解把n分成两部分，分别排序。唉= =，不机智了。。 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int ncases, n, times; cin &gt;&gt; ncases; while ( ncases-- ) &#123; cin &gt;&gt; n; times = n / 2 * (n / 2 - 1) / 2 + (n - n / 2) * (n - n / 2 - 1) / 2; cout &lt;&lt; times; if ( ncases ) cout &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1477 Box of Bricks","slug":"POJ-1477-Box-of-Bricks","date":"2014-08-12T04:32:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1477-Box-of-Bricks/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1477-Box-of-Bricks/","excerpt":"题目源地址： http://poj.org/problem?id=1477 理解只有比平均数还要大的柱子需要移动，而移动的具体方式不需要考虑，明白了这一点就是水题了。","text":"题目源地址： http://poj.org/problem?id=1477 理解只有比平均数还要大的柱子需要移动，而移动的具体方式不需要考虑，明白了这一点就是水题了。 代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n, i, sum, ave, j, ans, t = 1; int e[51]; while (scanf(&quot;%d&quot;, &amp;n) == 1 &amp;&amp; n) &#123; ave = sum = 0; for (i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;e[i]); sum += e[i]; &#125; ave = sum / n; ans = 0; for (i = 1; i &lt;= n; i++) &#123; if (e[i] &gt; ave) &#123; ans += e[i] - ave; &#125; &#125; cout &lt;&lt; &quot;Set #&quot; &lt;&lt; t++ &lt;&lt; &quot;\\nThe minimum number of moves is &quot; &lt;&lt; ans &lt;&lt; &quot;.&quot; &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1426 Find The Multiple","slug":"POJ-1426-Find-The-Multiple","date":"2014-08-12T04:27:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1426-Find-The-Multiple/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1426-Find-The-Multiple/","excerpt":"题目源地址： http://poj.org/problem?id=1426 理解使用了BFS来搜索满足条件的数，注意必须使用long long，否则数据不够。","text":"题目源地址： http://poj.org/problem?id=1426 理解使用了BFS来搜索满足条件的数，注意必须使用long long，否则数据不够。 代码#include &lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;iomanip&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;long long a;void bfs()&#123; queue&lt;long long&gt;q; int i, j; long long x = 1, pos; q.push(x); while (!q.empty()) &#123; pos = q.front(); q.pop(); for (i = 0; i &lt; 2; i++) &#123; x = pos * 10 + i; if (x % a == 0) &#123; cout &lt;&lt; x &lt;&lt; endl; return; &#125; q.push(x); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; int i, j; while (cin &gt;&gt; a &amp;&amp; a) &#123; if (a == 1) &#123; cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; continue; &#125; bfs(); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1458 Common Subsequence","slug":"POJ-1458-Common-Subsequence","date":"2014-08-12T04:23:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1458-Common-Subsequence/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1458-Common-Subsequence/","excerpt":"题目源地址： http://poj.org/problem?id=1458 理解DP的基础题，求最长子序列（LCS）。状态转移方程伪代码如下： if (i == 0 || j == 0) dp[i,j] = 0else if (X[i] == Y[j]) dp[i,j] = dp[i-1,j-1] + 1else dp[i,j] = max(dp[i-1,j], dp[i,j-1])","text":"题目源地址： http://poj.org/problem?id=1458 理解DP的基础题，求最长子序列（LCS）。状态转移方程伪代码如下： if (i == 0 || j == 0) dp[i,j] = 0else if (X[i] == Y[j]) dp[i,j] = dp[i-1,j-1] + 1else dp[i,j] = max(dp[i-1,j], dp[i,j-1]) 代码#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int SIZE = 999;int dp[SIZE][SIZE] = &#123;0&#125;;int max(int x, int y)&#123; return x &gt; y ? x : y;&#125;int main(int argc, char const *argv[])&#123; int len1, len2; string str1, str2; while (cin &gt;&gt; str1 &gt;&gt; str2) &#123; len1 = str1.length(); len2 = str2.length(); for (int i = 1; i &lt;= len1; i++) &#123; for (int j = 1; j &lt;= len2; j++) &#123; if (str1[i - 1] == str2[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125; &#125; cout &lt;&lt; dp[len1][len2] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1323 Game Prediction","slug":"POJ-1323-Game-Prediction","date":"2014-08-12T04:19:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1323-Game-Prediction/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1323-Game-Prediction/","excerpt":"题目源地址： http://poj.org/problem?id=1323 理解最优的方法是出一张比你出的牌大的牌中最小的牌，不过没有严格证明= =。","text":"题目源地址： http://poj.org/problem?id=1323 理解最优的方法是出一张比你出的牌大的牌中最小的牌，不过没有严格证明= =。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;const int maxn = 1001;int vis[maxn], a[maxn];int n, m;int main(int argc, char const *argv[])&#123; int t = 0; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (m == 0 &amp;&amp; n == 0) break; t++; memset(vis, 0, sizeof(vis)); for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a[i]; vis[a[i]] = 1; &#125; sort(a + 1, a + m + 1); bool flag; int j = 1; int amount = 0; for (int i = 1; i &lt;= m; i++) &#123; flag = false; for (; j &lt;= n * m; j++) &#123; if (!vis[j] &amp;&amp; j &gt; a[i]) &#123; flag = true; j++; break; &#125; &#125; if (flag) amount++; &#125; printf(&quot;Case %d: %d\\n&quot;, t, m - amount); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1338 Ugly Numbers","slug":"POJ-1338-Ugly-Numbers","date":"2014-08-12T04:11:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1338-Ugly-Numbers/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1338-Ugly-Numbers/","excerpt":"题目源地址： http://poj.org/problem?id=1338 理解本来貌似是一道很难的题目，不过因为数据比较弱，打表水过。","text":"题目源地址： http://poj.org/problem?id=1338 理解本来貌似是一道很难的题目，不过因为数据比较弱，打表水过。 代码#include &lt;iostream&gt;using namespace std;const int MAX_POS = 1500;int myMin(int a, int b, int c)&#123; int min; min = a &lt; b ? a : b; min = min &lt; c ? min : c; return min;&#125;int main(int argc, char const *argv[])&#123; int ugly[MAX_POS + 1]; ugly[1] = 1; int p2, p3, p5; p2 = p3 = p5 = 1; for (int i = 2; i &lt;= MAX_POS; i++) &#123; int value2 = ugly[p2] * 2; int value3 = ugly[p3] * 3; int value5 = ugly[p5] * 5; ugly[i] = myMin(value2, value3, value5); if (ugly[i] == value2) p2++; if (ugly[i] == value3) p3++; if (ugly[i] == value5) p5++; &#125; int n; while (cin &gt;&gt; n, n != 0) &#123; cout &lt;&lt; ugly[n] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1363 Rails","slug":"POJ-1363-Rails","date":"2014-08-12T04:07:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1363-Rails/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1363-Rails/","excerpt":"题目源地址： http://poj.org/problem?id=1363 理解一列火车，每个车厢都有编号，都可以单独行使，然后有一个火车站，进去之后，头变成尾，尾变成头，问能不能以输入的顺序出站。使用了STL栈。","text":"题目源地址： http://poj.org/problem?id=1363 理解一列火车，每个车厢都有编号，都可以单独行使，然后有一个火车站，进去之后，头变成尾，尾变成头，问能不能以输入的顺序出站。使用了STL栈。 代码#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int maxn=1000+5;int a[maxn];int main(int argc, char const *argv[])&#123; int n,i,k; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; stack&lt;int&gt;s; while(scanf(&quot;%d&quot;,&amp;a[0])&amp;&amp;a[0]) &#123; for(i=1;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(i=1,k=0;i&lt;=n;i++) &#123; s.push(i); while(s.top()==a[k]) &#123; if(!s.empty()) s.pop(); k++; if(s.empty()) break; &#125; &#125; if(k==n) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1269 Intersecting Lines","slug":"POJ-1269-Intersecting-Lines","date":"2014-08-12T01:12:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1269-Intersecting-Lines/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1269-Intersecting-Lines/","excerpt":"题目源地址： http://poj.org/problem?id=1269 理解几何题= =，各种直线方程用起来，代码量有点大。","text":"题目源地址： http://poj.org/problem?id=1269 理解几何题= =，各种直线方程用起来，代码量有点大。 代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;functional&gt;using namespace std;#define eps 1e-8double sqr(double x)&#123; return x * x;&#125;struct P&#123; double x, y; P(double _x, double _y): x(_x), y(_y) &#123;&#125; P() &#123;&#125; double dis() &#123; return sqrt(sqr(x) + sqr(y)); &#125;&#125;;struct V&#123; double x, y; V(double _x, double _y): x(_x), y(_y) &#123;&#125; V(P a, P b): x(b.x - a.x), y(b.y - a.y) &#123;&#125; V() &#123;&#125; const double dis() &#123; return sqrt(sqr(x) + sqr(y)); &#125;&#125;;P operator+(const P a, const V b)&#123; return P(a.x + b.x, a.y + b.y);&#125;V operator*(const double a, const V b)&#123; return V(a * b.x, a * b.y);&#125;double operator*(const V a, const V b)&#123; return a.x * b.y - b.x * a.y;&#125;P jiao_dian(const V a, V b, const V c, const V CD, const P C)&#123; double d; d = b.dis(); double s1 = a * b, s2 = b * c; double k = s1 / (s1 + s2); return C + k * CD;&#125;bool equal(const double a, const double b)&#123; if (abs(a - b) &lt; eps) return 1; return 0;&#125;int n;int main()&#123; cout &lt;&lt; &quot;INTERSECTING LINES OUTPUT&quot; &lt;&lt; endl; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; double x1, y1, x2, y2, x3, y3, x4, y4; scanf(&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;x4, &amp;y4); P A = P(x1, y1), B = P(x2, y2), C = P(x3, y3), D = P(x4, y4); V AB = V(A, B), AC = V(A, C), AD = V(A, D), CD = V(C, D); if (equal((AB * CD), 0)) &#123; if (equal((AC * AD), 0)) cout &lt;&lt; &quot;LINE\\n&quot;; else cout &lt;&lt; &quot;NONE\\n&quot;; &#125; else &#123; P p = jiao_dian(AC, AB, AD, CD, C); cout.setf(ios::fixed); cout.precision(2); cout &lt;&lt; &quot;POINT &quot; &lt;&lt; p.x &lt;&lt; &apos; &apos; &lt;&lt; p.y &lt;&lt; endl; &#125; &#125; cout &lt;&lt; &quot;END OF OUTPUT&quot; &lt;&lt; endl; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1183 反正切函数的应用","slug":"POJ-1183-Arctan","date":"2014-08-12T01:01:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1183-Arctan/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1183-Arctan/","excerpt":"题目源地址： http://poj.org/problem?id=1183 理解题目不难，但是被数据类型坑了= =。int不够，long long超时，使用unsigned int过了= =，感谢大神，坑了这么久。。","text":"题目源地址： http://poj.org/problem?id=1183 理解题目不难，但是被数据类型坑了= =。int不够，long long超时，使用unsigned int过了= =，感谢大神，坑了这么久。。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(int argc, char const *argv[])&#123; unsigned int m, n, a, sum; while (scanf(&quot;%d&quot;, &amp;a) != EOF) &#123; for (m = a; ; m++) if ((a * a + 1) % m == 0) break; n = (a * a + 1) / m; sum = 2 * a + m + n; printf(&quot;%d\\n&quot;, sum); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1157 LITTLE SHOP OF FLOWERS","slug":"POJ-1157-LITTLE-SHOP-OF-FLOWERS","date":"2014-08-12T00:55:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1157-LITTLE-SHOP-OF-FLOWERS/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1157-LITTLE-SHOP-OF-FLOWERS/","excerpt":"题目源地址： http://poj.org/problem?id=1157 理解满足的递推方程：dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+map[i][j])","text":"题目源地址： http://poj.org/problem?id=1157 理解满足的递推方程：dp[i][j]=max(dp[i][j-1],dp[i-1][j-1]+map[i][j]) 代码#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define INF 10000int dp[110][110];int map[110][110];int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;int main(int argc, char const *argv[])&#123; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) &#123; scanf(&quot;%d&quot;, &amp;map[i][j]); &#125; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt; i; j++) dp[i][j] = -INF; for (int j = 1; j &lt;= m; j++) for (int i = 1; i &lt;= -max(-n, -j); i++) &#123; dp[i][j] = max(dp[i][j - 1], dp[i - 1][j - 1] + map[i][j]); &#125; printf(&quot;%d\\n&quot;, dp[n][m]);&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1160 Post Office","slug":"POJ-1160-Post-Office","date":"2014-08-12T00:45:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1160-Post-Office/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1160-Post-Office/","excerpt":"题目源地址： http://poj.org/problem?id=1160 理解很经典的邮局送信的DP问题。不过提交的时候发现CE，error: call of overloaded &#39;abs(int)&#39; is ambiguous，修改cmath为math.h之后，发现本机编译失败，添加了cstdlib之后，顺利AC。这中间存在两个问题：第一，不是每一个X.h的库都跟cX命名的库一模一样；第二本地缺少的库可以通过编译，但是OJ不一定能通过。","text":"题目源地址： http://poj.org/problem?id=1160 理解很经典的邮局送信的DP问题。不过提交的时候发现CE，error: call of overloaded &#39;abs(int)&#39; is ambiguous，修改cmath为math.h之后，发现本机编译失败，添加了cstdlib之后，顺利AC。这中间存在两个问题：第一，不是每一个X.h的库都跟cX命名的库一模一样；第二本地缺少的库可以通过编译，但是OJ不一定能通过。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;math.h&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#define INF 1000000000using namespace std;int d[305];int dp[35][305], dis[305][305];int n, m;void init()&#123; memset(dis, 0, sizeof(dis)); for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) &#123; int mid = (i + j) &gt;&gt; 1; for (int k = i; k &lt;= j; ++k) dis[i][j] += abs(d[k] - d[mid]); &#125;&#125;void DP()&#123; for (int i = 1; i &lt;= n; ++i) dp[1][i] = dis[1][i]; for (int i = 2; i &lt;= m; ++i) for (int j = 1; j &lt;= n; ++j) dp[i][j] = INF; for (int i = 2; i &lt;= m; i++) for (int j = i; j &lt;= n; ++j) for (int k = 1; k &lt;= j; ++k) &#123; if (dp[i][j] &gt; dp[i - 1][k] + dis[k + 1][j]) dp[i][j] = dp[i - 1][k] + dis[k + 1][j]; &#125; printf(&quot;%d\\n&quot;, dp[m][n]);&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;d[i]); init(); DP(); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1159 Palindrome","slug":"POJ-1159-Palindrome","date":"2014-08-12T00:38:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1159-Palindrome/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1159-Palindrome/","excerpt":"题目源地址： http://poj.org/problem?id=1159 理解最关键的公式是： if (str[i] == str[j]) DP[k][j] = DP[1 - k][j - 1];else DP[k][j] = min(DP[1 - k][j], DP[k][j - 1]) + 1; 注意到k空间的循环利用，节省了空间，感谢大牛提供的思路。","text":"题目源地址： http://poj.org/problem?id=1159 理解最关键的公式是： if (str[i] == str[j]) DP[k][j] = DP[1 - k][j - 1];else DP[k][j] = min(DP[1 - k][j], DP[k][j - 1]) + 1; 注意到k空间的循环利用，节省了空间，感谢大牛提供的思路。 代码#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int DP[2][5003];int main(int argc, char const *argv[])&#123; int n; string str; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; cin &gt;&gt; str; memset(DP, 0, sizeof(DP)); int k = 0; for (int i = n - 2; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; if (str[i] == str[j]) DP[k][j] = DP[1 - k][j - 1]; else DP[k][j] = min(DP[1 - k][j], DP[k][j - 1]) + 1; &#125; for (int j = 0; j &lt; n; j++) DP[1 - k][j] = 0; k = 1 - k; &#125; printf(&quot;%d\\n&quot;, DP[1 - k][n - 1]); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1051 P,MTHBGWB","slug":"POJ-1051-P-MTHBGWB","date":"2014-08-12T00:31:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/12/POJ-1051-P-MTHBGWB/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-1051-P-MTHBGWB/","excerpt":"题目源地址： http://poj.org/problem?id=1051 理解简单的字符串转换，要有耐心= =，debug出翔。","text":"题目源地址： http://poj.org/problem?id=1051 理解简单的字符串转换，要有耐心= =，debug出翔。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX 102char str[MAX];char code[4*MAX];int code_len[MAX];int cnt;int read_cnt;int len;const char * dic[]=&#123;&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;,&quot;..--&quot;,&quot;---.&quot;,&quot;.-.-&quot;,&quot;----&quot;&#125;;int len_of_code(char ch)&#123; if(ch-&apos;A&apos;&lt;26&amp;&amp;ch-&apos;A&apos;&gt;=0) return strlen(dic[ch-&apos;A&apos;]); else return 4;&#125;void addcode(char ch)&#123; int _i; char cache[5]; if(ch-&apos;A&apos;&gt;=0&amp;&amp;ch-&apos;A&apos;&lt;26) strcpy(cache,dic[ch-&apos;A&apos;]); else if(ch==&apos;_&apos;) strcpy(cache,dic[26]); else if(ch==&apos;.&apos;) strcpy(cache,dic[27]); else if(ch==&apos;,&apos;) strcpy(cache,dic[28]); else if(ch==&apos;?&apos;) strcpy(cache,dic[29]); for(_i=0;cache[_i]!=&apos;\\0&apos;;_i++) &#123; code[cnt++]=cache[_i]; &#125;&#125;void readcode()&#123; char cache[5]; int _cnt; int _i,_j; for(_i=len-1;_i&gt;=0;_i--) &#123; _cnt=0; for(_j=0;_j&lt;code_len[_i];_j++) cache[_cnt++]=code[read_cnt++]; cache[_cnt]=&apos;\\0&apos;; for(_j=0;_j&lt;30;_j++) if(strcmp(cache,dic[_j])==0) &#123; if(_j&lt;26) printf(&quot;%c&quot;,_j+&apos;A&apos;); else if(_j==26) printf(&quot;_&quot;); else if(_j==27) printf(&quot;.&quot;); else if(_j==28) printf(&quot;,&quot;); else printf(&quot;?&quot;); &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; int n; int i,j; scanf(&quot;%d&quot;,&amp;n); for(i=0;i&lt;n;i++) &#123; cnt=0;read_cnt=0; scanf(&quot;%s&quot;,str); len=strlen(str); for(j=0;j&lt;len;j++) &#123; code_len[j]=len_of_code(str[j]); addcode(str[j]); &#125; printf(&quot;%d: &quot;,i+1); readcode(); printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3751 时间日期格式转换","slug":"POJ-3751-Date-Transfer","date":"2014-08-12T00:19:00.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/12/POJ-3751-Date-Transfer/","link":"","permalink":"https://xuanwo.org/2014/08/12/POJ-3751-Date-Transfer/","excerpt":"题目源地址： http://poj.org/problem?id=3751 理解通过标记来判断正午和午夜，水题。","text":"题目源地址： http://poj.org/problem?id=3751 理解通过标记来判断正午和午夜，水题。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int t, y, mm, d, h, m, s, tag;char ch[2][3] = &#123;&quot;am&quot;, &quot;pm&quot;&#125;;int main(int argc, char const *argv[])&#123; cin &gt;&gt; t; while (t--) &#123; scanf(&quot;%d/%d/%d-%d:%d:%d&quot;, &amp;y, &amp;mm, &amp;d, &amp;h, &amp;m, &amp;s); if (h &lt; 12) tag = 0, h = (h == 0) ? 12 : h; else tag = 1, h = (h == 12) ? 12 : h - 12; printf(&quot;%02d/%02d/%04d-%02d:%02d:%02d%s\\n&quot;, mm, d, y, h, m, s, ch[tag]); &#125; return 0;&#125; 更新日志 2014年08月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"强大且配置项丰富的在线IDE应用——Cloud9","slug":"Cloud9","date":"2014-08-07T13:31:00.000Z","updated":"2016-08-03T04:19:54.398Z","comments":true,"path":"2014/08/07/Cloud9/","link":"","permalink":"https://xuanwo.org/2014/08/07/Cloud9/","excerpt":"废话先不说，首先来一张大图秀一下编辑状态下的页面：","text":"废话先不说，首先来一张大图秀一下编辑状态下的页面： 下面转入正题，来介绍一下这个基于Node,JavaScript以及HTML5的在线IDE。 介绍Cloud9是一个托管在Github下的开源项目，开源许可是GPL v3。根据官方的文档来看，C9既可以通过 https://c9.io/ 运行，也可以安装在本地（支持Windows和Linux，理论上来说，Mac也是可以的）。当然啦，运行C9的浏览器推荐Chrome，其他的浏览器并没有测试（如果有朋友测试过了，可以反馈给我，我补充进来）。这个项目相当活跃，有能力的朋友也可以加入到开发中去。恩，简单的介绍就到这里，下面来讲一下基本的用法。 用法本地端没有测试，直接使用 https://c9.io/ 运行。 注册进入主页，大大的SIGN UP，直接点进去，进入到注册页面，右边介绍了一下免费版和专业版（也就是收费版）之间的区别。免费版拥有： 1 Private Workspace 1 FTP Workspace Full Shell Access and Terminal Unlimited Public Workspaces Unlimited Collaborators 专业版除了完全拥有免费版的功能之外，还有： 6 Private Workspaces Connect to your own VM Unlimited FTP Workspaces 看起来公司很厚道，免费版完全够用，尤其是还提供了完全的Shell权限，这一点非常重要，后面会详细讲，现在先直接Github登录。值得一提的是，Github登录之后，C9会添加一个SSH key到Github中，并且会同步你拥有的所有库，以后可以很方便的直接添加到Workplace中，而且操作都会同步，非常赞。除了Github之外，还支持另一个使用广泛的开源平台——Bitbucket。 使用注册成功后会进入Dashboard，左边是你拥有的Workplace，中间是一个简单的使用教程，最近的动态，已经绑定的服务（Github），最右边是账户设置。下面创建一个demo-project，点击start editing，会打开一个新的编辑页面，可以自由选择想要的界面，因为之前就一直使用Sublime，所以这次也直接选择Sublime。C9支持很多语言，默认支持的就有Node.js，Python，Ruby，PHP，Go，更逆天的是，他还支持数据库，包括MySQL，MongoDB，Redis，SQLite。不过，作为ACMer，更加常用的语言是C/C++，C9虽然可以识别，但是不能直接通过RUN来运行。是不是C9就不能当作一个C/C++的IDE来用呢？非也非也，这时候，C9真正的强大之处就体现出来了。其实，C9不仅仅是一个IDE，而是一个已经配置好了的虚拟机，顺便透露一下系统环境是Ubuntu 14.04 LTS，而且支持sudo命令。所以，如果想要编译并且运行C/C++的代码，只需要在Shell中输入g++ test.cpp -o test，然后再./test运行可执行文件，就OK啦～（其实在RUN的窗口下，还支持环境的修改，不过还没有仔细研究，下次再作介绍吧。貌似有很多方式可以修改，包括修改build system，修改runner，修改系统环境，有空的时候再研究一下） 发现搜罗了一些Ubuntu下显示硬件配置的命令，逐个试了一下，感觉挺有意思的，结果如下 硬盘空间Bash中输入命令df查看磁盘空间，结果如下 Size Used Avail Use%1.5G 165M 1.2G 13% C9真心厚道，每个人给了1.5G的空间，已经够用了。&gt;偷偷的曝光一件我做的不地道的事情，我单开了一个叫做test的workplace，输入命令 sudo apt-get updatesudo apt-get install ubuntu-desktop 经过漫长的等待之后- -，果然，空间不足了，哈哈哈。其实我蛮好奇要是安装成功了会是什么样的，难道真的会有一个桌面跳出来？我可以再试试别的轻量一点的桌面，恩。 CPU配置Bash中输入命令cat /proc/cpuinfo查看CPU配置,结果如下 processor : 0 //核心数从0到7，其他的全都一样vendor_id : GenuineIntelcpu family : 6model : 45model name : Intel(R) Xeon(R) CPU @ 2.60GHzstepping : 7microcode : 0x1cpu MHz : 2599.998cache size : 20480 KBphysical id : 0siblings : 8core id : 0cpu cores : 8apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc nopl xtopology eagerfpu pni pclmulqdq ssse3 cx16 sse4_1 sse4_2 x2apic popcnt aes xsave avx hypervisor lahf_lm xsaveoptbogomips : 5199.99clflush size : 64cache_alignment : 64address sizes : 46 bits physical, 48 bits virtualpower management: 我了个擦，着实有点羡慕，八核的至强处理器。不过我猜应该是亚马逊或者Google的云服务器吧，而且我在用的时候没觉得有多快啊= =。 系统版本Bash中输入命令sudo lsb_release -a查看系统版本,结果如下 No LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 14.04 LTSRelease: 14.04Codename: trusty 果然是最新版，不知道会不会同步更新，应该是不带桌面的server版本。 应用场景虽然Cloud9宣传的时候还是以在线的IDE为主，但是在试用的过程中，我发现C9在一些应用场景下，有着绝妙的用处。 配合Hexo和Git，用于管理和生成博客Hexo一类的静态博客生成器有一个很大的问题就是，它的配置不能进行同步，以至于更换一台电脑或者电脑出了意外，基本上就要重头再来。虽然将Blog本身使用Git管理可以部分解决这个问题，但是同样要面临nodejs和git的环境配置，十分麻烦。在有了Cloud9之后，这些问题都迎刃而解了。在C9上安装hexo（C9已经将nodejs和git配置好了，无需重新安装），配置完毕后，即可进行在线编辑。常用的电脑上，可以进行环境配置，本地编辑，deply上传，没有区别；在临时电脑上，直接登录C9，进行在线编辑即可～ 在线的Ubuntu虚拟机第一次玩Linux没有经验？怕把电脑弄坏？想试试某个软件或者某个命令，却不敢在本地尝试？快来C9吧，弄坏了只要把那个Workplace删掉就好，也就是说，你拥有了无限个1.5G的在线Ubuntu虚拟机！这还不够赞？ 免费的Web服务器自带了一个服务器的功能，可用于Demo预览，支持直接从外界进行访问。不过不建议真的把自己的应用放在那个上面，首先速度太慢了- -，其次心里过意不去。 配置TODO（配置项比较多，默认的就很OK，有空的时候再研究。） 更新日志 2014年08月07日 完成C9的介绍和简单的用法说明，配置部分有待完成。 2014年08月10日 完成发现和应用场景模块，配置部分暂缓更新，等待C9官方issus的回复。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://xuanwo.org/tags/Web/"}]},{"title":"POJ 1251 Jungle Roads","slug":"POJ-1251-Jungle-Roads","date":"2014-08-06T22:52:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/06/POJ-1251-Jungle-Roads/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-1251-Jungle-Roads/","excerpt":"题目源地址： http://poj.org/problem?id=1251 理解同样是练习题，使用了Kruskal算法，对着模板敲的，理解的还不是很透彻。 补充一个Prim算法的代码，神模板好评，自己对最小生成树的理解有了很大提高。在凌晨时分debug了半天，通过逐行打印，最终确认我错误的原因，没有进行初始化。虽然有点哭笑不得，但是感觉自己花了这三个小时是值得的。以后要避免这样的错误。","text":"题目源地址： http://poj.org/problem?id=1251 理解同样是练习题，使用了Kruskal算法，对着模板敲的，理解的还不是很透彻。 补充一个Prim算法的代码，神模板好评，自己对最小生成树的理解有了很大提高。在凌晨时分debug了半天，通过逐行打印，最终确认我错误的原因，没有进行初始化。虽然有点哭笑不得，但是感觉自己花了这三个小时是值得的。以后要避免这样的错误。 代码Kruskal算法#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 26typedef struct&#123; int x, y; int w;&#125; edge;edge e[MAX *MAX];int rank[MAX];int father[MAX];int sum;bool cmp(const edge a, const edge b)&#123; return a.w &lt; b.w;&#125;void Make_Set(int x)&#123; father[x] = x; rank[x] = 0;&#125;int Find_Set(int x)&#123; if (x != father[x]) &#123; father[x] = Find_Set(father[x]); &#125; return father[x];&#125;void Union(int x, int y, int w)&#123; if (x == y) return; if (rank[x] &gt; rank[y]) &#123; father[y] = x; &#125; else &#123; if (rank[x] == rank[y]) &#123; rank[y]++; &#125; father[x] = y; &#125; sum += w;&#125;int main()&#123; int i, j, k, m, n, t; char ch; while (cin &gt;&gt; m &amp;&amp; m != 0) &#123; k = 0; for (i = 0; i &lt; m; i++) Make_Set(i); for (i = 0; i &lt; m - 1; i++) &#123; cin &gt;&gt; ch &gt;&gt; n; for (j = 0; j &lt; n; j++) &#123; cin &gt;&gt; ch &gt;&gt; e[k].w; e[k].x = i; e[k].y = ch - &apos;A&apos;; k++; &#125; &#125; sort(e, e + k, cmp); sum = 0; for (i = 0; i &lt; k; i++) &#123; Union(Find_Set(e[i].x), Find_Set(e[i].y), e[i].w); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; Prim算法#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string.h&gt;using namespace std;#define MAXN 200#define inf 1000000000typedef int elem_t;elem_t prim(int n, elem_t mat[][MAXN], int *pre)&#123; elem_t min[MAXN], ret = 0; int v[MAXN], i, j, k; for (i = 0; i &lt; n; i++) min[i] = inf, v[i] = 0, pre[i] = -1; for (min[j = 0] = 0; j &lt; n; j++) &#123; for (k = -1, i = 0; i &lt; n; i++) if (!v[i] &amp;&amp; (k == -1 || min[i] &lt; min[k])) k = i; for (v[k] = 1, ret += min[k], i = 0; i &lt; n; i++) if (!v[i] &amp;&amp; mat[k][i] &lt; min[i]) min[i] = mat[pre[i] = k][i]; &#125; return ret;&#125;int main(int argc, char const *argv[])&#123; int n, i, j, k, cnt, x, sum; char ch; int pre[MAXN]; elem_t mat[MAXN][MAXN]; while (cin &gt;&gt; n &amp;&amp; n) &#123; for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) &#123; mat[i][j] = inf; if(i==j) mat[i][j]=0; &#125; for (i = 0; i &lt; n - 1; i++) &#123; cin &gt;&gt; ch &gt;&gt; cnt; for (j = 0, k = int(ch - &apos;A&apos;); j &lt;= cnt - 1; j++) &#123; cin &gt;&gt; ch &gt;&gt; x; mat[k][int(ch - &apos;A&apos;)] = x; mat[int(ch - &apos;A&apos;)][k] = x; &#125; &#125; sum = prim(n, mat, pre); cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2485 Highways","slug":"POJ-2485-Highways","date":"2014-08-06T22:47:00.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/06/POJ-2485-Highways/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2485-Highways/","excerpt":"题目源地址： http://poj.org/problem?id=2485 理解拖了很久的最小生成树练习题，对着模板想了很久。","text":"题目源地址： http://poj.org/problem?id=2485 理解拖了很久的最小生成树练习题，对着模板想了很久。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX 501#define INF 0x3f3f3f3fusing namespace std;int t, n, near[MAX], edge[MAX][MAX];int Prim(int v0)&#123; int i, k, temp, v, dist[MAX] = &#123;0&#125;; for (i = 0; i &lt; n; i++) &#123; near[i] = edge[v0][i]; &#125; near[v0] = 0; dist[v0] = 1; for (k = 0; k &lt; n - 1; k++) &#123; v = -1; temp = INF; for (i = 0; i &lt; n; i++) &#123; if (!dist[i] &amp;&amp; temp &gt; near[i]) &#123; temp = near[i]; v = i; &#125; &#125; dist[v] = 1; for (i = 0; i &lt; n; i++) &#123; if (!dist[i] &amp;&amp; i != v &amp;&amp; edge[v][i] != 0 &amp;&amp; edge[v][i] &lt; near[i]) &#123; near[i] = edge[v][i]; &#125; &#125; &#125; temp = 0; for (i = 0; i &lt; n; i++) &#123; if (temp &lt; near[i]) temp = near[i]; &#125; return temp;&#125;int main(int argc, char const *argv[])&#123; int i, j; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt; n; j++) scanf(&quot;%d&quot;, &amp;edge[i][j]); printf(&quot;%d\\n&quot;, Prim(0)); &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3981 字符串替换","slug":"POJ-3981-String-Swap","date":"2014-08-06T16:00:00.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/08/06/POJ-3981-String-Swap/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-3981-String-Swap/","excerpt":"题目源地址： http://poj.org/problem?id=3981 理解大水题一道，字符串函数的简单运用","text":"题目源地址： http://poj.org/problem?id=3981 理解大水题一道，字符串函数的简单运用 代码#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(int argc, char const *argv[])&#123; string str; while(getline(cin, str)) &#123; int start = str.find(&quot;you&quot;); while(start != string::npos) &#123; str.replace(start, 3, &quot;we&quot;); start = str.find(&quot;you&quot;, start+2); &#125; cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2586 Y2K Accounting Bug","slug":"POJ-2586-Y2K-Accounting-Bug","date":"2014-08-06T15:23:00.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/08/06/POJ-2586-Y2K-Accounting-Bug/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2586-Y2K-Accounting-Bug/","excerpt":"题目源地址： http://poj.org/problem?id=2586 理解总共有五种情况：1、若SSSSD亏空，那么全年可能最大盈利情况为: SSSSDSSSSDSS2、若SSSDD亏空，那么全年可能最大盈利情况为：SSSDDSSSDDSS3、若SSDDD亏空，那么全年可能最大盈利情况为: SSDDDSSDDDSS4、若SDDDD亏空，那么全年可能最大盈利情况为: SDDDDSDDDDSD5、若DDDDD亏空，那么全年可能最大盈利情况为: DDDDDDDDDDDD","text":"题目源地址： http://poj.org/problem?id=2586 理解总共有五种情况：1、若SSSSD亏空，那么全年可能最大盈利情况为: SSSSDSSSSDSS2、若SSSDD亏空，那么全年可能最大盈利情况为：SSSDDSSSDDSS3、若SSDDD亏空，那么全年可能最大盈利情况为: SSDDDSSDDDSS4、若SDDDD亏空，那么全年可能最大盈利情况为: SDDDDSDDDDSD5、若DDDDD亏空，那么全年可能最大盈利情况为: DDDDDDDDDDDD 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(int argc, char const *argv[])&#123; int sur, def; while (scanf(&quot;%d%d&quot;, &amp;sur, &amp;def) != EOF) &#123; int val; if (def &gt; 4 * sur) val = 10 * sur - 2 * def; else if (2 * def &gt; 3 * sur) val = 8 * sur - 4 * def; else if (3 * def &gt; 2 * sur) val = 6 * sur - 6 * def; else if (4 * def &gt; sur) val = 3 * sur - 9 * def; else val = -12 * def; if (val &lt;= 0) cout &lt;&lt; &quot;Deficit&quot; &lt;&lt; endl; else cout &lt;&lt; val &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2389 Bull Math","slug":"POJ-2389-Bull-Math","date":"2014-08-06T15:03:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2389-Bull-Math/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2389-Bull-Math/","excerpt":"题目源地址： http://poj.org/problem?id=2389 理解没什么好说的，java大数模板水之。","text":"题目源地址： http://poj.org/problem?id=2389 理解没什么好说的，java大数模板水之。 代码import java.math.BigDecimal;import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner in=new Scanner (System.in); while(in.hasNext())&#123; BigDecimal a=in.nextBigDecimal(); BigDecimal b=in.nextBigDecimal(); System.out.println(a.multiply(b)); &#125; &#125;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2080 Calendar","slug":"POJ-2080-Calendar","date":"2014-08-06T14:44:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2080-Calendar/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2080-Calendar/","excerpt":"题目源地址： http://poj.org/problem?id=2080 理解完全的模拟题。将给定的天数转化为年月日，注意闰年，大小月。","text":"题目源地址： http://poj.org/problem?id=2080 理解完全的模拟题。将给定的天数转化为年月日，注意闰年，大小月。 代码#include &lt;stdio.h&gt;using namespace std;char week[7][10] = &#123;&quot;Saturday&quot;, &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;&#125;;int year[2] = &#123;365, 366&#125;;int month[2][12] = &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;int type(int m)&#123; if ((m % 4 == 0 &amp;&amp; m % 100 != 0) || (m % 400 == 0))return 1; else return 0;&#125;int main(int argc, char const *argv[])&#123; int days, dayofweek; int i = 0, j = 0; while (scanf(&quot;%d&quot;, &amp;days) &amp;&amp; days != -1) &#123; dayofweek = days % 7; for (i = 2000; days &gt;= year[type(i)]; i++) days -= year[type(i)]; for (j = 0; days &gt;= month[type(i)][j]; j++) days -= month[type(i)][j]; printf(&quot;%d-%02d-%02d %s\\n&quot;, i, j + 1, days + 1, week[dayofweek]); &#125;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2039 To and Fro","slug":"POJ-2039-To-and-Fro","date":"2014-08-06T14:33:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2039-To-and-Fro/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2039-To-and-Fro/","excerpt":"题目源地址： http://poj.org/problem?id=2039 理解找规律的题目。首先看一下加密的方式：原文为theresonoplacelikehomeonasnowynightx，分成N列来写，没有写满的用x填充，写成如下队列： t o i o yh p k n ne l e a ir a h s ge c o n hs e m o tn l e w x 对于奇数行，从左向后书写，对于偶数行，从右向左书写，得到密文：toioynnkpheleaigshareconhtomesnlewx显然，解密的方式就是原样还原回去。一共进行N次读入，对于第i次读取，用j定位行数。如果j为偶数，输出N*j+i；如果j为奇数，输出N*(j+1)-1-i。","text":"题目源地址： http://poj.org/problem?id=2039 理解找规律的题目。首先看一下加密的方式：原文为theresonoplacelikehomeonasnowynightx，分成N列来写，没有写满的用x填充，写成如下队列： t o i o yh p k n ne l e a ir a h s ge c o n hs e m o tn l e w x 对于奇数行，从左向后书写，对于偶数行，从右向左书写，得到密文：toioynnkpheleaigshareconhtomesnlewx显然，解密的方式就是原样还原回去。一共进行N次读入，对于第i次读取，用j定位行数。如果j为偶数，输出N*j+i；如果j为奇数，输出N*(j+1)-1-i。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;char str[210];int N;int i, j;int len, M;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d&quot;, &amp;N), N != 0) &#123; getchar(); gets(str); len = strlen(str); M = (int)((double)N / (double)len + 0.999999); for (i = 0; i &lt; N; i++) &#123; for (j = 0; j * N &lt; len; j++) &#123; if (j % 2 == 0) &#123; printf(&quot;%c&quot;, str[N * j + i]); &#125; else if (j % 2 == 1) &#123; printf(&quot;%c&quot;, str[N * (j + 1) - 1 - i]); &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2019 Cornfields","slug":"POJ-2019-Cornfields","date":"2014-08-06T14:20:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2019-Cornfields/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2019-Cornfields/","excerpt":"题目源地址： http://poj.org/problem?id=2019 理解暴力水过的= =，大牛说是RMQ的题目，要是POJ数据强的话，估计就超时了。","text":"题目源地址： http://poj.org/problem?id=2019 理解暴力水过的= =，大牛说是RMQ的题目，要是POJ数据强的话，估计就超时了。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int field[300][300];int N, B, K;int X, Y;int i, j;int min, max, tmp;int main(int argc, char const *argv[])&#123; scanf(&quot;%d%d%d&quot;, &amp;N, &amp;B, &amp;K); for (i = 1; i &lt;= N; i++) &#123; for (j = 1; j &lt;= N; j++) &#123; scanf(&quot;%d&quot;, &amp;field[i][j]); &#125; &#125; while (K --) &#123; scanf(&quot;%d%d&quot;, &amp;X, &amp;Y); min = max = field[X][Y]; for (i = X; i &lt; X + B; i++) &#123; for (j = Y; j &lt; Y + B; j++) &#123; if (min &gt; field[i][j]) &#123; min = field[i][j]; &#125; if (max &lt; field[i][j]) &#123; max = field[i][j]; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, max - min); &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2028 When Can We Meet?","slug":"POJ-2028-When-Can-We-Meet","date":"2014-08-06T14:13:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2028-When-Can-We-Meet/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2028-When-Can-We-Meet/","excerpt":"题目源地址： http://poj.org/problem?id=2028 理解一边输入一边记录开会最多且最近的那天。","text":"题目源地址： http://poj.org/problem?id=2028 理解一边输入一边记录开会最多且最近的那天。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;int a[110];int N, Q;int day, days, i, j;int min, max;int flag = 0;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d&quot;, &amp;N, &amp;Q), Q != 0 || N != 0) &#123; flag = 0; memset(a, 0, sizeof(a)); min = 10000; max = -1; for (i = 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;day); for (j = 0; j &lt; day; j++) &#123; scanf(&quot;%d&quot;, &amp;days); a[days] ++; if (a[days] &gt;= Q) &#123; flag = 1; if (max &lt; a[days]) &#123; max = a[days]; min = days; &#125; if (a[days] == max &amp;&amp; min &gt; days) &#123; min = days; max = a[days]; &#125; &#125; &#125; &#125; if (flag == 1) &#123; printf(&quot;%d\\n&quot;, min); &#125; else &#123; printf(&quot;0\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2017 Speed Limit","slug":"POJ-2017-Speed-Limit","date":"2014-08-06T14:06:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/06/POJ-2017-Speed-Limit/","link":"","permalink":"https://xuanwo.org/2014/08/06/POJ-2017-Speed-Limit/","excerpt":"题目源地址： http://poj.org/problem?id=2017 理解一道比较简单的模拟，跨项累加。","text":"题目源地址： http://poj.org/problem?id=2017 理解一道比较简单的模拟，跨项累加。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF, n != -1) &#123; int t1 = 0, t2 = 0, v = 0; int sumLen = 0; int i; for (i = 0; i &lt; n; ++i) &#123; t1 = t2; scanf(&quot;%d%d&quot;, &amp;v, &amp;t2); sumLen += (t2 - t1) * v; &#125; printf(&quot;%d miles\\n&quot;, sumLen); &#125; return 0;&#125; 更新日志 2014年08月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"30天，用为知笔记共创京城最好玩的运动场馆地图","slug":"wiz-sport-map-book","date":"2014-08-06T13:13:00.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2014/08/06/wiz-sport-map-book/","link":"","permalink":"https://xuanwo.org/2014/08/06/wiz-sport-map-book/","excerpt":"30名编辑，99名围观，正在招募，等你来报！","text":"30名编辑，99名围观，正在招募，等你来报！ 一起创作的这本书，名叫《北京热活地图》 啥是热活？就是热爱生活，热情活力……其实就像你一样，无论从事什么样的工作，过什么样的生活，都能留一点儿时间和空间给自己，在运动中找到纯粹的快乐，流一流汗就很爽，身上和心里都觉得有劲儿！ 所以，如果你也喜欢运动，喜欢体验各种各样的运动场馆，甚至已经是某个场馆的大牛级人物，来吧，我们一起创作一本普通人给普通人的书！ 在为知笔记上共同创作，介绍 150 个北京富有特色的运动场馆，攀岩、射箭、瑜伽、剑道、卡丁车…… 只需要跟大家讲述你在运动场馆里的故事，体验、感受、见闻，给想运动但还没有相关运动经验的朋友支个招，我们希望找到真实的你，聊一聊你最爱的运动场馆，以及在这个馆里，如何轻松开始尝试运动的Tips 不用焦虑，你不是一个人，每项运动我们都会形成一个小组，有四位编辑负责协同，大家一起讨论、一起创作、一起分享你在运动中最快乐的故事 我们对所有感兴趣和有参与热情的人敞开怀抱，除了以上招募的30名编辑外，还有99个围观名额等着你，你可以为内容出谋划策，评价讨论，一起让这本书变得更加有魅力！ 成书发行后，所有参与编辑和围观的为知客都将获赠新书，同时，还将为本书的版税设立总额为2万元的热活基金，用于帮助贫困大学生初入职场时，有更多的机会尝试运动体验，为公益，贡献热活力量 也许你是程序员、是律师、或者在搞科研、金融、电商……你的生活永远不会跟出书相关，但一次简单的描述和分享，会在《北京热活地图》，用油墨，印上你的名字30天，在为知笔记上创作一本书，将成为一段你生命中最美好的体验，如果你愿意分享、愿意参与、愿意见证京城最好玩儿的150个运动场馆，就赶快报名吧！ 参与流程第一步：点击这里填写报名信息第二步：工作人员将根据场馆情况进行初步筛选，通过者将受到邀约，加入我们的创作团队 时间安排8月：招募报名：推荐你常去的运动场馆审核通过：确定代言人和场馆名单，编辑协调每位代言人在为知笔记上进行协同创作文稿撰写、编辑完毕 9月：《北京热活地图》编辑团队全程组织协调，成书印刷，制作完成 《北京热活地图》主编：庞涛 时尚网主编十年媒体从业经历，混迹时尚江湖数载，热爱时尚、运动。 更新日志 2014年08月06日 转载自为知官方博客。","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Sports","slug":"Sports","permalink":"https://xuanwo.org/tags/Sports/"}]},{"title":"POJ 2013 Symmetric Order","slug":"POJ-2013-Symmetric-Order","date":"2014-08-05T21:40:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-2013-Symmetric-Order/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-2013-Symmetric-Order/","excerpt":"题目源地址： http://poj.org/problem?id=2013 理解一组字符串，从短到长再到短排列，相同长短的字符串按照字母表顺序排列。","text":"题目源地址： http://poj.org/problem?id=2013 理解一组字符串，从短到长再到短排列，相同长短的字符串按照字母表顺序排列。 代码#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int i, n, sum = 0; char a[30][30]; while (scanf(&quot;%d&quot;, &amp;n) != EOF, n) &#123; for (i = 0; i &lt; n; i++) scanf(&quot;%s&quot;, a[i]); printf(&quot;SET %d\\n&quot;, ++sum); for (i = 0; i &lt; n; i++) &#123; if (i % 2 == 0) &#123; printf(&quot;%s\\n&quot;, a[i]); &#125; &#125; for (i = n - 1; i &gt;= 0; i--) &#123; if (i % 2 != 0) &#123; printf(&quot;%s\\n&quot;, a[i]); &#125; &#125; &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2000 Gold Coins","slug":"POJ-2000-Gold-Coins","date":"2014-08-05T21:02:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-2000-Gold-Coins/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-2000-Gold-Coins/","excerpt":"题目源地址： http://poj.org/problem?id=2000 理解求N天得到多少个金币，第一天得到1个，第二、三天得到2个，第四、五、六天得到3个。","text":"题目源地址： http://poj.org/problem?id=2000 理解求N天得到多少个金币，第一天得到1个，第二、三天得到2个，第四、五、六天得到3个。 代码#include &lt;iostream&gt;using namespace std;int i;int day, day1 = 0, coin = 0;int main(int argc, char const *argv[])&#123; cin &gt;&gt; day; while (day) &#123; coin = 0; day1 = 0; i = 0; do &#123; i++; day1 += i; coin += i * i; &#125; while (day1 &lt; day); if (day1 &gt; day) coin -= (day1 - day) * i; cout &lt;&lt; day &lt;&lt; &apos; &apos; &lt;&lt; coin &lt;&lt; endl; cin &gt;&gt; day; &#125;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1939 Diplomatic License","slug":"POJ-1939-Diplomatic-License","date":"2014-08-05T20:51:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1939-Diplomatic-License/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1939-Diplomatic-License/","excerpt":"题目源地址： http://poj.org/problem?id=1939 理解求多边形相邻两个点的中点= =，这是英语题吧。。。","text":"题目源地址： http://poj.org/problem?id=1939 理解求多边形相邻两个点的中点= =，这是英语题吧。。。 代码#include &lt;stdio.h&gt;double cor[2][30000];int main()&#123; int n, i; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; for (i = 0; i &lt; n; i++) scanf(&quot;%lf%lf&quot;, &amp;cor[0][i], &amp;cor[1][i]); printf(&quot;%d&quot;, n); for (i = 0; i &lt; n; i++) printf(&quot; %lf %lf&quot;, (cor[0][i] + cor[0][(i + 1) % n]) / 2, (cor[1][i] + cor[1][(i + 1) % n]) / 2); putchar(&apos;\\n&apos;); &#125; return 0;&#125; 更新日志 2014年08月05日 已AC，C提交过了，G++直接超时两发。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1936 All in All","slug":"POJ-1936-All-in-All","date":"2014-08-05T20:41:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1936-All-in-All/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1936-All-in-All/","excerpt":"题目源地址： http://poj.org/problem?id=1936 理解字符串的题目。因为数据水所以这是一道水题，要是数据再强一点估计就TLE了。","text":"题目源地址： http://poj.org/problem?id=1936 理解字符串的题目。因为数据水所以这是一道水题，要是数据再强一点估计就TLE了。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define N 100001using namespace std;char s[N], t[N];int slen, tlen, i, j, tag;int main()&#123; while ( scanf(&quot;%s %s&quot;, s, t) != EOF ) &#123; slen = strlen(s); tlen = strlen(t); for (i = 0 , j = 0; i &lt; tlen &amp;&amp; j &lt; slen; ++i) if (s[j] == t[i]) ++j; if (j == slen) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1922 Ride to School","slug":"POJ-1922-Ride-to-School","date":"2014-08-05T20:36:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1922-Ride-to-School/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1922-Ride-to-School/","excerpt":"题目源地址： http://poj.org/problem?id=1922 理解第一眼感觉就是贪心，只要选择最快的单车就好，不用考虑中间的过程。","text":"题目源地址： http://poj.org/problem?id=1922 理解第一眼感觉就是贪心，只要选择最快的单车就好，不用考虑中间的过程。 代码#include &lt;stdio.h&gt;using namespace std;int n;double m = 999999.0;double s, t;int main()&#123; scanf(&quot;%d&quot;, &amp;n); while (n != 0) &#123; while (n--) &#123; scanf(&quot;%lf%lf&quot;, &amp;s, &amp;t); if (t &gt;= 0) &#123; t += 4500.0 / (s / 3.6); if (t &lt; m) m = t; &#125; &#125; printf(&quot;%d\\n&quot;, (int)(m + 0.999999)); m = 999999.0; scanf(&quot;%d&quot;, &amp;n); &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1862 Stripies","slug":"POJ-1862-Stripies","date":"2014-08-05T20:31:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1862-Stripies/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1862-Stripies/","excerpt":"题目源地址： http://poj.org/problem?id=1862 理解原先质量越大的，如果越先被计算，那么开根号的次数就会越多，相比之下，最终结果就会越小。最后再排一下序就好。","text":"题目源地址： http://poj.org/problem?id=1862 理解原先质量越大的，如果越先被计算，那么开根号的次数就会越多，相比之下，最终结果就会越小。最后再排一下序就好。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int a[110];bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main(int argc, char const *argv[])&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); sort(a, a + n, cmp); double ans = a[0]; for (int i = 1; i &lt; n; i++) &#123; ans = 2 * sqrt(ans * a[i]); &#125; printf(&quot;%.3f\\n&quot;, ans); return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1844 Sum","slug":"POJ-1844-Sum","date":"2014-08-05T17:09:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1844-Sum/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1844-Sum/","excerpt":"题目源地址： http://poj.org/problem?id=1844 理解有这样两种情况： Sum(i) == S ，那么很明显 i 就是答案,直接输出即可。 Sum(i) &gt; S , 从 i 开始,依次往后面 +1 枚举 ，只要遇到 (Sum(i) - S) % 2 == 0 输出答案就可以了。","text":"题目源地址： http://poj.org/problem?id=1844 理解有这样两种情况： Sum(i) == S ，那么很明显 i 就是答案,直接输出即可。 Sum(i) &gt; S , 从 i 开始,依次往后面 +1 枚举 ，只要遇到 (Sum(i) - S) % 2 == 0 输出答案就可以了。 代码#include&lt;stdio.h&gt;const int maxn = 100000;int main(int argc, char const *argv[])&#123; int s; while (scanf(&quot;%d&quot;, &amp;s) != EOF) &#123; int sum = 0; int i; for (i = 1; i &lt; maxn; i++) &#123; sum = (1 + i) * i / 2; if (sum &gt;= s) break; &#125; int index = i; for (;;) &#123; sum = (1 + index) * index / 2; if ((sum - s) % 2 == 0) &#123; printf(&quot;%d\\n&quot;, index); break; &#125; index++; &#125; &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1799 Yeehaa!","slug":"POJ-1799-Yeehaa!","date":"2014-08-05T16:13:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1799-Yeehaa!/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1799-Yeehaa!/","excerpt":"题目源地址： http://poj.org/problem?id=1799 理解借用某大神图：","text":"题目源地址： http://poj.org/problem?id=1799 理解借用某大神图： 代码#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;const double pi = acos(-1.0);int main(int argc, char const *argv[])&#123; int t; double R; int n, cas = 1; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; R &gt;&gt; n; double m = sin(pi / (double)n); printf(&quot;Scenario #%d:\\n%.3f\\n&quot;, cas++, m * R / (m + 1)); if (t) cout &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1731 Orders","slug":"POJ-1731-Orders","date":"2014-08-05T15:57:00.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1731-Orders/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1731-Orders/","excerpt":"题目源地址： http://poj.org/problem?id=1731 理解全排列的简单运用","text":"题目源地址： http://poj.org/problem?id=1731 理解全排列的简单运用 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int main(int argc, char const *argv[])&#123; string str; while (cin &gt;&gt; str) &#123; sort(str.begin(), str.end()); cout &lt;&lt; str &lt;&lt; endl; while (next_permutation(str.begin(), str.end())) &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1664 放苹果","slug":"POJ-1664-Devide-Apples","date":"2014-08-05T15:47:50.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/05/POJ-1664-Devide-Apples/","link":"","permalink":"https://xuanwo.org/2014/08/05/POJ-1664-Devide-Apples/","excerpt":"题目源地址： http://poj.org/problem?id=1664 理解有两种情况： 至少空出一个盘子不放（相对于目前），则转化为在(n-1)个盘子里放m个苹果，在剩下的盘子里放入0个苹果，即apple(m,n-1)； 所有盘子至少放入一个。先在每个盘子里都放入1个苹果，剩下m-n个苹果，再在n个盘子里进行放置。即apple(m-n,n)。然后是结束的条件，有三种。 当m==0时，苹果已经放完，只有一种情况，即不放置，返回1； 当n==1时，只有一个盘子可以放置，返回1； 当m&lt;n时，苹果数小于盘子数，和将m个苹果放入m个盘子情况相同。","text":"题目源地址： http://poj.org/problem?id=1664 理解有两种情况： 至少空出一个盘子不放（相对于目前），则转化为在(n-1)个盘子里放m个苹果，在剩下的盘子里放入0个苹果，即apple(m,n-1)； 所有盘子至少放入一个。先在每个盘子里都放入1个苹果，剩下m-n个苹果，再在n个盘子里进行放置。即apple(m-n,n)。然后是结束的条件，有三种。 当m==0时，苹果已经放完，只有一种情况，即不放置，返回1； 当n==1时，只有一个盘子可以放置，返回1； 当m&lt;n时，苹果数小于盘子数，和将m个苹果放入m个盘子情况相同。 代码#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int apple(int m, int n )&#123; if (m == 0 || n == 1) return 1; if (m &lt; n) return apple(m, m); return apple(m - n, n) + apple(m, n - 1);&#125;int main(int argc, char const *argv[])&#123; int t, m, n; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); printf(&quot;%d\\n&quot;, apple(m, n)); &#125; return 0;&#125; 更新日志 2014年08月05日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1663 Max Factor","slug":"POJ-1663-Number-Steps","date":"2014-08-03T12:27:41.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1663-Number-Steps/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1663-Number-Steps/","excerpt":"题目源地址： http://poj.org/problem?id=1663 理解发现奇偶之间的规律之后，这也就是一道水题。","text":"题目源地址： http://poj.org/problem?id=1663 理解发现奇偶之间的规律之后，这也就是一道水题。 代码#include &lt;stdio.h&gt;using namespace std;int main(int argc, char const *argv[])&#123; int N, x, y; scanf(&quot;%d&quot;, &amp;N); while (N--) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (x &lt; 0 || y &lt; 0) printf(&quot;No Number\\n&quot;); else if (x == y || x == y + 2) printf(&quot;%d\\n&quot;, x % 2 ? (x + y - 1) : (x + y) ); else printf(&quot;No Number\\n&quot;); &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1658 Eva's Problem","slug":"POJ-1658-Eva's-Problem","date":"2014-08-03T12:19:40.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1658-Eva's-Problem/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1658-Eva's-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=1658 理解额，水题一枚，直接算就好","text":"题目源地址： http://poj.org/problem?id=1658 理解额，水题一枚，直接算就好 代码#include &lt;cstdio&gt;using namespace std;int main(int argc, char const *argv[])&#123; int nCase; scanf(&quot;%d&quot;, &amp;nCase); while (nCase--) &#123; int a, b, c, d, e; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); if (b - a == c - b &amp;&amp; c - b == d - c)e = d + d - c; else e = d * d / c; printf(&quot;%d %d %d %d %d\\n&quot;, a, b, c, d, e); &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1604 Just the Facts","slug":"POJ-1604-Just-the-Facts","date":"2014-08-03T12:16:39.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1604-Just-the-Facts/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1604-Just-the-Facts/","excerpt":"题目源地址： http://poj.org/problem?id=1604 理解只需要截取后面五位，避免超过int的范围","text":"题目源地址： http://poj.org/problem?id=1604 理解只需要截取后面五位，避免超过int的范围 代码#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int s[10005];int n;void multiply()&#123; int i , j; memset(s, 0, sizeof(s)); s[1] = 1; j = 1; for (i = 2; i &lt;= 10000; i++) &#123; j *= i; while (j % 10 == 0) j /= 10; j %= 100000; s[i] = j % 10; &#125;&#125;int main(int argc, char const *argv[])&#123; multiply(); while (cin &gt;&gt; n) &#123; printf(&quot;%5d&quot;, n); cout &lt;&lt; &quot; -&gt; &quot; &lt;&lt; s[n] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1579 Function Run Fun","slug":"POJ-1579-Function-Run-Fun","date":"2014-08-03T12:00:24.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1579-Function-Run-Fun/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1579-Function-Run-Fun/","excerpt":"题目源地址： http://poj.org/problem?id=1579 理解题目很简单，就是递归。但是直接递归会导致超时，这里直接处理一下，超过20全都当作20来计算。","text":"题目源地址： http://poj.org/problem?id=1579 理解题目很简单，就是递归。但是直接递归会导致超时，这里直接处理一下，超过20全都当作20来计算。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int maxn = 55;int f[maxn][maxn][maxn];int w(int a, int b, int c)&#123; if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) &#123; return 1; &#125; if (a &gt; 20 || b &gt; 20 || c &gt; 20) &#123; return w(20, 20, 20); &#125; if (f[a][b][c]) &#123; return f[a][b][c]; &#125; if (a &lt; b &amp;&amp; b &lt; c) &#123; return f[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c); &#125; return f[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);&#125;int main(int argc, char const *argv[])&#123; int a, b, c; while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) != EOF) &#123; if (a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) &#123; return 0; &#125; int res = w(a, b, c); printf(&quot;w(%d, %d, %d) = %d\\n&quot;, a, b, c, res); &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1575 Easier Done Than Said?","slug":"POJ-1575-Easier-Done-Than-Said","date":"2014-08-03T11:54:33.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1575-Easier-Done-Than-Said/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1575-Easier-Done-Than-Said/","excerpt":"题目源地址： http://poj.org/problem?id=1575 理解运用三种标记，分别标记三种情况。对每一次字符读入均进行判断，一旦遇到不符合条件的，就直接退出循环。","text":"题目源地址： http://poj.org/problem?id=1575 理解运用三种标记，分别标记三种情况。对每一次字符读入均进行判断，一旦遇到不符合条件的，就直接退出循环。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;char availdou[5] = &quot;eo&quot;;char str[30];int words[26];int main(int argc, char const *argv[])&#123; int vowelflag = 0; int douflag; char douch; int tripleflag; int len, i; for (i = 0; i &lt; 26; i++) &#123; if (&apos;a&apos; + i == &apos;a&apos; || &apos;a&apos; + i == &apos;e&apos; || &apos;a&apos; + i == &apos;i&apos; || &apos;a&apos; + i == &apos;o&apos; || &apos;a&apos; + i == &apos;u&apos;) &#123; words[i] = 1; &#125; else &#123; words[i] = 0; &#125; &#125; while (scanf(&quot;%s&quot;, str), strcmp(str, &quot;end&quot;) != 0) &#123; vowelflag = 1; douflag = tripleflag = 0; douch = &apos;\\0&apos;; len = strlen(str); for (i = 0; i &lt; len; i++) &#123; if (words[str[i] - &apos;a&apos;] == 1) &#123; vowelflag = 0; if (tripleflag &lt;= 0) &#123; tripleflag = 1; &#125; else if (tripleflag &lt;= 2) &#123; tripleflag ++; &#125; //printf(&quot;%d: triple1:%d\\n&quot;, i, tripleflag); if (tripleflag == 3) &#123; break; &#125; if (douch == str[i]) &#123; if (!(douch == &apos;e&apos; || douch == &apos;o&apos;)) &#123; douflag = 1; break; &#125; &#125; douch = str[i]; &#125; else if (words[str[i] - &apos;a&apos;] == 0) &#123; if (tripleflag &gt;= 0) &#123; tripleflag = -1; &#125; else if (tripleflag &gt;= -2) &#123; tripleflag --; &#125; if (tripleflag == -3) &#123; break; &#125; if (douch == str[i]) &#123; douflag = 1; break; &#125; douch = str[i]; &#125; &#125; if (tripleflag == 3 || tripleflag == -3 || douflag || vowelflag) &#123; printf(&quot;&lt;%s&gt; is not acceptable.\\n&quot;, str); &#125; else &#123; printf(&quot;&lt;%s&gt; is acceptable.\\n&quot;, str); &#125; &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1565 Skew数","slug":"POJ-1565-Skew-Number","date":"2014-08-03T11:43:36.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/03/POJ-1565-Skew-Number/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1565-Skew-Number/","excerpt":"题目源地址： http://poj.org/problem?id=1565 理解不难，按照规则计算即可，注意大数的处理。","text":"题目源地址： http://poj.org/problem?id=1565 理解不难，按照规则计算即可，注意大数的处理。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main(int argc, char const *argv[])&#123; char num[35]; while (cin &gt;&gt; num &amp;&amp; num[0] != &apos;0&apos;) &#123; unsigned int pow = 1, sum = 0; for (int i = strlen(num) - 1; i &gt;= 0; i --) &#123; pow *= 2; sum += (num[i] - &apos;0&apos;) * (pow - 1); &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1552 Doubles","slug":"POJ-1552-Doubles","date":"2014-08-03T11:40:11.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/03/POJ-1552-Doubles/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1552-Doubles/","excerpt":"题目源地址： http://poj.org/problem?id=1552 理解直接开一个数组，两个循环判断后一个数是不是前一个数的两倍。暴力做的，没有超时。","text":"题目源地址： http://poj.org/problem?id=1552 理解直接开一个数组，两个循环判断后一个数是不是前一个数的两倍。暴力做的，没有超时。 代码#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int list[25];int main(int argc, char const *argv[])&#123; int i, j, len; int sum; int num; while (scanf(&quot;%d&quot;, &amp;num), num != -1) &#123; for (i = 0; num != 0; i++) &#123; list[i] = num; scanf(&quot;%d&quot;, &amp;num); &#125; len = i; sort(list, list + len); for (i = sum = 0; i &lt; len; i++) &#123; for (j = i; j &lt; len; j++) &#123; if (list[i] * 2 == list[j]) &#123; sum++; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, sum); &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1543 Perfect Cubes","slug":"POJ-1543-Perfect-Cubes","date":"2014-08-03T11:36:27.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/03/POJ-1543-Perfect-Cubes/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1543-Perfect-Cubes/","excerpt":"题目源地址： http://poj.org/problem?id=1543 理解暴力提交过了= =，怪我喽？","text":"题目源地址： http://poj.org/problem?id=1543 理解暴力提交过了= =，怪我喽？ 代码#include &lt;cstdio&gt;using namespace std;int main(int argc, char const *argv[])&#123; int a, b, c, d, n; scanf(&quot;%d&quot;, &amp;n); for (a = 6; a &lt;= n; a++) for (b = 2;; b++) &#123; if (a * a * a &lt;= b * b * b) break; for (c = b + 1;; c++) &#123; if (a * a * a &lt;= b * b * b + c * c * c) break; for (d = c + 1;; d++) &#123; if (a * a * a &lt; b * b * b + c * c * c + d * d * d) break; if (a * a * a == b * b * b + c * c * c + d * d * d) printf(&quot;Cube = %d, Triple = (%d,%d,%d)\\n&quot;, a, b, c, d); &#125; &#125; &#125; return 0;&#125; 更新日志 2014年08月03日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1405 Heritage","slug":"POJ-1405-Heritage","date":"2014-08-03T11:25:44.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/08/03/POJ-1405-Heritage/","link":"","permalink":"https://xuanwo.org/2014/08/03/POJ-1405-Heritage/","excerpt":"题目源地址： http://poj.org/problem?id=1405 理解可以得出递推关系X(n+1) = Xn * X(n-1) + 1，考虑到数据较大，使用Java大数类A掉","text":"题目源地址： http://poj.org/problem?id=1405 理解可以得出递推关系X(n+1) = Xn * X(n-1) + 1，考虑到数据较大，使用Java大数类A掉 代码import java.io.*;import java.math.*;import java.util.*;import java.text.*;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int i, id; BigInteger one, ans; one = BigInteger.valueOf(1); ans = BigInteger.valueOf(2); id = cin.nextInt(); for(i = 1; i &lt;= id; i ++)&#123; System.out.println(ans); ans = ans.multiply(ans.subtract(one)).add(one); &#125; System.exit(0); &#125;&#125; 更新日志 2014年08月02日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1979 Red and Black","slug":"POJ-1979-Red-and-Black","date":"2014-08-02T15:37:31.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/08/02/POJ-1979-Red-and-Black/","link":"","permalink":"https://xuanwo.org/2014/08/02/POJ-1979-Red-and-Black/","excerpt":"题目源地址： http://poj.org/problem?id=1979 理解一个比较简单的DFS练习题","text":"题目源地址： http://poj.org/problem?id=1979 理解一个比较简单的DFS练习题 代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define MAX 25char tiles[MAX][MAX];int used[MAX][MAX];int count, w, h;void dfs(int i, int j)&#123; count++; if (i &gt; 1 &amp;&amp; used[i - 1][j] == 0) &#123; used[i - 1][j] = 1; dfs(i - 1, j); &#125; if (i &lt; h &amp;&amp; used[i + 1][j] == 0) &#123; used[i + 1][j] = 1; dfs(i + 1, j); &#125; if (j &gt; 0 &amp;&amp; used[i][j - 1] == 0) &#123; used[i][j - 1] = 1; dfs(i, j - 1); &#125; if (j &lt; w - 1 &amp;&amp; used[i][j + 1] == 0) &#123; used[i][j + 1] = 1; dfs(i, j + 1); &#125;&#125;int main(int argc, char const *argv[])&#123; int starti, startj; while (scanf(&quot;%d %d&quot;, &amp;w, &amp;h) &amp;&amp; w != 0 &amp;&amp; h != 0) &#123; if (w == 0 || h == 0) break; count = 0; memset(used, 0, sizeof(used)); for (int i = 1; i &lt;= h; i++) &#123; scanf(&quot;%s&quot;, tiles[i]); &#125; for (int i = 1; i &lt;= h; i++) &#123; for (int j = 0; j &lt; w; j++) &#123; if (tiles[i][j] == &apos;#&apos;) used[i][j] = 1; else if (tiles[i][j] == &apos;@&apos;) &#123; used[i][j] = 1; startj = j; starti = i; &#125; &#125; &#125; dfs(starti, startj); printf(&quot;%d\\n&quot;, count); &#125; return 0;&#125; 更新日志 2014年08月02日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1528 Perfection","slug":"POJ-1528-Perfection","date":"2014-07-25T04:34:58.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/25/POJ-1528-Perfection/","link":"","permalink":"https://xuanwo.org/2014/07/25/POJ-1528-Perfection/","excerpt":"题目源地址： http://poj.org/problem?id=1528 理解 一个数n的正因数之和等于n则输出PERFECT 大于n，输出ABUNDANT 小于n，输出DEFICIENT 注意：因数不包括它本身","text":"题目源地址： http://poj.org/problem?id=1528 理解 一个数n的正因数之和等于n则输出PERFECT 大于n，输出ABUNDANT 小于n，输出DEFICIENT 注意：因数不包括它本身 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define MAX 60001int num[MAX];int n,k=0;void fun()&#123; int i, j; memset(num, 0, sizeof(num)); for (i = 1; i &lt; MAX; i++) &#123; for (j = i + i; j &lt; MAX; j += i) &#123; num[j] += i; &#125; &#125;&#125;int main()&#123; fun(); while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; k++; if (k == 1) printf(&quot;PERFECTION OUTPUT\\n&quot;); if (n == 0) &#123; printf(&quot;END OF OUTPUT\\n&quot;); break; &#125; if (n / 10 == 0) printf(&quot; %d&quot;, n); else if (n / 100 == 0) printf(&quot; %d&quot;, n); else if (n / 1000 == 0) printf(&quot; %d&quot;, n); else if (n / 10000 == 0) printf(&quot; %d&quot;, n); else printf(&quot;%d&quot;, n); if (num[n] == n) &#123; printf(&quot; PERFECT\\n&quot;); &#125; else if (num[n] &lt; n) &#123; printf(&quot; DEFICIENT\\n&quot;); &#125; else printf(&quot; ABUNDANT\\n&quot;); &#125; return 0;&#125; 更新日志 2014年07月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1519 Digital Roots","slug":"POJ-1519-Digital-Roots","date":"2014-07-25T04:29:15.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/25/POJ-1519-Digital-Roots/","link":"","permalink":"https://xuanwo.org/2014/07/25/POJ-1519-Digital-Roots/","excerpt":"题目源地址： http://poj.org/problem?id=1519 理解这不就是弃九法么。把每个位置上数字相加迭代即可，但是多次WA，看了discuss才知道原来数据到了2000位的，只能用数组模拟。","text":"题目源地址： http://poj.org/problem?id=1519 理解这不就是弃九法么。把每个位置上数字相加迭代即可，但是多次WA，看了discuss才知道原来数据到了2000位的，只能用数组模拟。 代码#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int root;string n;int main(int argc, char const *argv[])&#123; while (cin&gt;&gt;n&amp;&amp;n!=&quot;0&quot;) &#123; root = 0; for (int i = 0; i &lt; n.length(); i++) &#123; root += n[i] - &apos;0&apos;; &#125; root %= 9; cout &lt;&lt; (root == 0 ? 9 : root) &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1517 u Calculate e","slug":"POJ-1517-u-Calculate-e","date":"2014-07-25T04:00:19.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/25/POJ-1517-u-Calculate-e/","link":"","permalink":"https://xuanwo.org/2014/07/25/POJ-1517-u-Calculate-e/","excerpt":"题目源地址： http://poj.org/problem?id=1517 理解计算e的值。太自信，没有用打表，结果WA了两发，蛋疼。","text":"题目源地址： http://poj.org/problem?id=1517 理解计算e的值。太自信，没有用打表，结果WA了两发，蛋疼。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;double ans = 2.5;double mulit = 1;int main(int argc, char const *argv[])&#123; printf(&quot;n e\\n&quot;); printf(&quot;- -----------\\n&quot;); printf(&quot;0 1\\n&quot;); printf(&quot;1 2\\n&quot;); printf(&quot;2 2.5\\n&quot;); for (int i = 3; i &lt; 10; i++) &#123; mulit = 1; for (double j = 1; j &lt;= i; j++) &#123; mulit *= j; &#125; ans += 1 / mulit; printf(&quot;%d %.9lf\\n&quot;, i , ans); &#125; return 0;&#125; 更新日志 2014年07月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1504 Adding Reversed Numbers","slug":"POJ-1504-Adding-Reversed-Numbers","date":"2014-07-25T03:40:50.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/25/POJ-1504-Adding-Reversed-Numbers/","link":"","permalink":"https://xuanwo.org/2014/07/25/POJ-1504-Adding-Reversed-Numbers/","excerpt":"题目源地址： http://poj.org/problem?id=1504 理解同样是长长的题目，其实是要求把数字从左到右相加，本质是要用字符数组模拟加法。当然，用java会更快一点，不过这次选择了用C++来写。姿势不是很优美，代码太丑陋了，应该有更优美的写法。","text":"题目源地址： http://poj.org/problem?id=1504 理解同样是长长的题目，其实是要求把数字从左到右相加，本质是要用字符数组模拟加法。当然，用java会更快一点，不过这次选择了用C++来写。姿势不是很优美，代码太丑陋了，应该有更优美的写法。 代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;int n;string a, b;char c[100];int i;int ans;int main(int argc, char const *argv[])&#123; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; a &gt;&gt; b; if (a.length() &lt; b.length()) a.swap(b); for (i = 0; i &lt; a.length() + 1; i++) c[i] = &apos;0&apos;; ans = 0; for (i = 0; i &lt; b.length(); i++) &#123; c[i] += a[i] + b[i] - 3 * &apos;0&apos;; if (c[i] &gt;= 10) &#123; c[i + 1]++; c[i] = c[i] - 10 + &apos;0&apos;; &#125; else c[i] = c[i] + &apos;0&apos;; &#125; for (i = b.length(); i &lt; a.length(); i++) &#123; c[i] += a[i] - 2 * &apos;0&apos;; if (c[i] &gt;= 10) &#123; c[i + 1]++; c[i] = c[i] - 10 + &apos;0&apos;; &#125; else c[i] = c[i] + &apos;0&apos;; &#125; for (i = 0; i &lt;= a.length(); i++) &#123; ans = ans * 10 + c[i] - &apos;0&apos;; &#125; if (ans % 10 == 0) ans /= 10; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; 更新日志 2014年07月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1493 Machined Surfaces","slug":"POJ-1493-Machined-Surfaces","date":"2014-07-25T02:59:11.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/25/POJ-1493-Machined-Surfaces/","link":"","permalink":"https://xuanwo.org/2014/07/25/POJ-1493-Machined-Surfaces/","excerpt":"题目源地址： http://poj.org/problem?id=1493 理解题目虽然这么长，但是意思很简单，就是求左右合并之后中间剩下的空格数量。分别求出每行的空格数，排序，跟最小真相减之后叠加即可。","text":"题目源地址： http://poj.org/problem?id=1493 理解题目虽然这么长，但是意思很简单，就是求左右合并之后中间剩下的空格数量。分别求出每行的空格数，排序，跟最小真相减之后叠加即可。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;#define MAX 100char tmp[30];int n;int space[MAX];int ans;int main(int argc, char const *argv[])&#123; while (cin &gt;&gt; n &amp;&amp; n != 0) &#123; memset(space, 0, sizeof(space)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; 25; j++) &#123; scanf(&quot;%c&quot;, &amp;tmp[j]); if (tmp[j] == &apos; &apos;) space[i]++; &#125; getchar(); &#125; sort(space, space + n); ans = 0; for (int i = 0; i &lt; n; i++) ans += space[i] - space[0]; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月25日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2891 Strange Way to Express Integers","slug":"POJ-2891-Strange-Way-to-Express-Integers","date":"2014-07-24T01:57:51.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/24/POJ-2891-Strange-Way-to-Express-Integers/","link":"","permalink":"https://xuanwo.org/2014/07/24/POJ-2891-Strange-Way-to-Express-Integers/","excerpt":"题目源地址： http://poj.org/problem?id=2891 理解做的第一道关于扩展欧几里德方程的题目，还不够。","text":"题目源地址： http://poj.org/problem?id=2891 理解做的第一道关于扩展欧几里德方程的题目，还不够。 代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long int big;big egcd(big a, big b, big &amp;x, big &amp;y )&#123; big t, ret; if (!b) &#123; x = 1; y = 0; return a; &#125; ret = egcd(b, a % b, x, y); t = x, x = y, y = t - a / b * y; return ret;&#125;int main()&#123; int k; big a1, r1, a2, r2; big d, x, y; while (scanf(&quot;%d&quot;, &amp;k) != EOF) &#123; bool flag = false; scanf(&quot;%I64d%I64d&quot;, &amp;a1, &amp;r1); for (int i = 2; i &lt;= k; ++i) &#123; scanf(&quot;%I64d%I64d&quot;, &amp;a2, &amp;r2); if (flag) continue; d = egcd(a1, a2, x, y); if ((r2 - r1) % d) flag = true; a2 = a2 / d; r1 = ((x * ((r2 - r1) / d) % a2 + a2) % a2) * a1 + r1; a1 = a2 * a1; &#125; if (flag) printf(&quot;-1\\n&quot;); else printf(&quot;%I64d\\n&quot;, r1 % a1); &#125; return 0;&#125; 更新日志 2014年07月24日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3518 Prime Gap","slug":"POJ-3518-Prime-Gap","date":"2014-07-23T23:50:16.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/07/23/POJ-3518-Prime-Gap/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-3518-Prime-Gap/","excerpt":"题目源地址： http://poj.org/problem?id=3518 理解虽然看起来并没有二分计算的代码，但是应用了二分的思想。设两个端点，分别向两个方向扩展，最后的结果就是两个端点的差值。","text":"题目源地址： http://poj.org/problem?id=3518 理解虽然看起来并没有二分计算的代码，但是应用了二分的思想。设两个端点，分别向两个方向扩展，最后的结果就是两个端点的差值。 代码#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;bool isPrime(int n)&#123; for(int i=2;i&lt;=sqrt((double)n);i++) &#123; if(n%i==0) return false; &#125; return true;&#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; if(isPrime(n)) &#123; cout&lt;&lt;0&lt;&lt;endl; &#125; else &#123; int x=n-1; int y=n+1; while(!isPrime(x)) x--; while(!isPrime(y)) y++; cout&lt;&lt;y-x&lt;&lt;endl; &#125; &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3122 Pie","slug":"POJ-3122-Pie","date":"2014-07-23T23:47:09.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/23/POJ-3122-Pie/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-3122-Pie/","excerpt":"题目源地址： http://poj.org/problem?id=3122 理解这也是一道水题，二分切之。","text":"题目源地址： http://poj.org/problem?id=3122 理解这也是一道水题，二分切之。 代码#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;int N, F;double pi = acos(-1.0);double pie[10032];double sum, maxp;int main()&#123; double l, r, m; int i, t, c; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; scanf(&quot;%d%d&quot;, &amp;N, &amp;F); F++; maxp = sum = 0; for (i = 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;c); pie[i] = c * c * pi; maxp = max(maxp, pie[i]); sum += pie[i]; &#125; l = maxp / F; r = sum / F; while (l + 0.00001 &lt; r) &#123; m = (l + r) / 2; c = 0; for (i = 0; i &lt; N; i++) c += floor(pie[i] / m); if (c &lt; F) r = m; else l = m; &#125; printf(&quot;%.4lf\\n&quot;, l); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3273 Monthly Expense","slug":"POJ-3273-Monthly-Expense","date":"2014-07-23T23:44:01.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/23/POJ-3273-Monthly-Expense/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-3273-Monthly-Expense/","excerpt":"题目源地址： http://poj.org/problem?id=3273 理解也是很久之前的一道题目，简单的二分。","text":"题目源地址： http://poj.org/problem?id=3273 理解也是很久之前的一道题目，简单的二分。 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int f[101000];int main()&#123; int n, m, i; int mid, _max, _min; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); _min = 0; _max = 0; for (i = 0; i &lt; m; i++) &#123; scanf(&quot;%d&quot;, &amp;f[i]); _max += f[i]; if (f[i] &gt; _min) &#123; _min = f[i]; &#125; &#125; while (_min &lt; _max) &#123; mid = (_min + _max) / 2; int sum = 0, count = 0; for (i = 0; i &lt; m; i++) &#123; sum += f[i]; if (sum &gt; mid) &#123; count++; sum = f[i]; &#125; &#125; if (count &lt; n) &#123; _max = mid; &#125; else &#123; _min = mid + 1; &#125; &#125; printf(&quot;%d\\n&quot;, _min); return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1905 Expanding Rods","slug":"POJ-1905-Expanding-Rods","date":"2014-07-23T23:40:45.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/23/POJ-1905-Expanding-Rods/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1905-Expanding-Rods/","excerpt":"题目源地址： http://poj.org/problem?id=1905 理解很久以前做的题目，是二分法最基础的运用。","text":"题目源地址： http://poj.org/problem?id=1905 理解很久以前做的题目，是二分法最基础的运用。 代码#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;double esp = 1e-5;int main()&#123; double L, n, C; while (scanf(&quot;%lf%lf%lf&quot;, &amp;L, &amp;n, &amp;C) != EOF) &#123; if (L &lt; 0 &amp;&amp; n &lt; 0 &amp;&amp; C &lt; 0) break; double LL; LL = (1 + n * C) * L; double low, high; double R, mid; low = 0; high = L / 2; while (high - low &gt; esp) &#123; mid = (high + low) / 2; R = ((mid * mid * 4) + (L * L)) / (8 * mid); if ((2 * R * asin(L / (2 * R))) &lt; LL) low = mid; else high = mid; &#125; printf(&quot;%.3f\\n&quot;, mid); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2965 The Pilots Brothers' refrigerator","slug":"POJ-2965-The-Pilots-Brothers'-refrigerator","date":"2014-07-23T23:31:18.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/23/POJ-2965-The-Pilots-Brothers'-refrigerator/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-2965-The-Pilots-Brothers'-refrigerator/","excerpt":"题目源地址： http://poj.org/problem?id=2965 理解参考的某神牛的解法：&gt;证明: 要使一个为’+’的符号变为’-‘,必须其相应的行和列的操作数为奇数;可以证明,如果’+’位置对应的行和列上每一个位置都进行一次操作,则整个图只有这一’+’位置的符号改变,其余都不会改变. 设置一个4*4的整型数组,初值为零,用于记录每个点的操作数,那么在每个’+’上的行和列的的位置都加1,得到结果模2(因为一个点进行偶数次操作的效果和没进行操作一样),然后计算整型数组中一的 个数即为操作数,’-‘的位置为要操作的位置(其他原来操作数为偶数的因为操作并不发生效果,因此不进行操作) 只适用于这一道题，POJ上那道棋盘翻转貌似不能通用。","text":"题目源地址： http://poj.org/problem?id=2965 理解参考的某神牛的解法：&gt;证明: 要使一个为’+’的符号变为’-‘,必须其相应的行和列的操作数为奇数;可以证明,如果’+’位置对应的行和列上每一个位置都进行一次操作,则整个图只有这一’+’位置的符号改变,其余都不会改变. 设置一个4*4的整型数组,初值为零,用于记录每个点的操作数,那么在每个’+’上的行和列的的位置都加1,得到结果模2(因为一个点进行偶数次操作的效果和没进行操作一样),然后计算整型数组中一的 个数即为操作数,’-‘的位置为要操作的位置(其他原来操作数为偶数的因为操作并不发生效果,因此不进行操作) 只适用于这一道题，POJ上那道棋盘翻转貌似不能通用。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool mark[4][4];char s[4][4];int i, j, k;int ci[16], cj[16];int nas = 0;int main(int argc, char const *argv[])&#123; memset(mark, 0, sizeof(mark)); for (i = 0; i &lt; 4; i++) cin &gt;&gt; s[i]; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) &#123; char c = s[i][j]; if (c == &apos;+&apos;) &#123; mark[i][j] = !mark[i][j]; for (k = 0; k &lt; 4; k++) &#123; mark[i][k] = !mark[i][k]; mark[k][j] = !mark[k][j]; &#125; &#125; &#125; for (i = 0; i &lt; 4; i++) for (j = 0; j &lt; 4; j++) if (mark[i][j] == true) &#123; ci[nas] = i + 1; cj[nas] = j + 1; nas ++; &#125; printf(&quot;%d\\n&quot;, nas); for (i = 0; i &lt; nas; i++) &#123; printf(&quot;%d %d\\n&quot;, ci[i], cj[i]); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1423 Big Number","slug":"POJ-1423-Big-Number","date":"2014-07-23T23:26:52.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1423-Big-Number/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1423-Big-Number/","excerpt":"题目源地址： http://poj.org/problem?id=1423 理解又是大数据的题目，果断用Java来做，不过还是用到了取对数得操作。","text":"题目源地址： http://poj.org/problem?id=1423 理解又是大数据的题目，果断用Java来做，不过还是用到了取对数得操作。 代码import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); int n = cin.nextInt(); while (n &gt; 0) &#123; int test = cin.nextInt(); if (test &lt;= 3) System.out.println(1); else &#123; double result = 0.5 * Math.log10(2 * test * Math.PI) + test * Math.log10(test / Math.E) + 1;; System.out.println((int)(result)); &#125; n--; &#125; &#125;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1401 Factorial","slug":"POJ-1401-Factorial","date":"2014-07-23T14:48:05.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1401-Factorial/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1401-Factorial/","excerpt":"题目源地址： http://poj.org/problem?id=1401 理解一开始惊讶地发现，每个数除以4之后都跟答案比较接近，然后打算开始偷鸡，结果失败了= =。实际上，是每一个数不停地除以5，寻找10的因子的过程。","text":"题目源地址： http://poj.org/problem?id=1401 理解一开始惊讶地发现，每个数除以4之后都跟答案比较接近，然后打算开始偷鸡，结果失败了= =。实际上，是每一个数不停地除以5，寻找10的因子的过程。 代码#include &lt;iostream&gt;using namespace std;int main()&#123; int T; cin &gt;&gt; T; long long int N; for (int i = 0; i &lt; T; i++) &#123; cin &gt;&gt; N; int ret = 0; while (N) &#123; ret = ret + N / 5; N = N / 5; &#125; cout &lt;&lt; ret &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1326 Mileage Bank","slug":"POJ-1326-Mileage-Bank","date":"2014-07-23T14:10:08.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1326-Mileage-Bank/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1326-Mileage-Bank/","excerpt":"题目源地址： http://poj.org/problem?id=1326 理解题目倒是不难，但是这个输入真的是。。。。","text":"题目源地址： http://poj.org/problem?id=1326 理解题目倒是不难，但是这个输入真的是。。。。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;char temp1[100], temp2[100], a[2];int s, sum;int main(int argc, char const *argv[])&#123; while (1) &#123; sum = 0; while (1) &#123; scanf(&quot;%s&quot;, temp1); if (temp1[0] == &apos;0&apos;) break; if (temp1[0] == &apos;#&apos;) return 0; scanf(&quot;%s%d%s&quot;, temp2, &amp;s, a); if (a[0] == &apos;F&apos;) sum += s * 2; else if (a[0] == &apos;Y&apos;) &#123; if (s &lt;= 500) sum += 500; else sum += s; &#125; else if (a[0] == &apos;B&apos;) sum += s * 1.5 + 0.5; &#125; cout &lt;&lt; sum &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1061 青蛙的约会","slug":"POJ-1061-Date-of-Frogs","date":"2014-07-23T13:49:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1061-Date-of-Frogs/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1061-Date-of-Frogs/","excerpt":"题目源地址： http://poj.org/problem?id=1061 理解扩展欧几里德方程的模板体。当初没有做出来，现在好像明白一点了。","text":"题目源地址： http://poj.org/problem?id=1061 理解扩展欧几里德方程的模板体。当初没有做出来，现在好像明白一点了。 新技能get扩展欧几里德方程解法&gt;设标准方程式为： ax +by =d (a,b已知) 首先求出gcd(a,b) ，然后化简方程，使得a/=gcd(a,b); b/=gcd(a,b); d/=gcd(a,b); 先求出 ax+by=gcd(a,b) 的一组特解，也就是方程 ax+by=1 的一个特解。然后将特解（x0, y0） 代入方程，并变形： a x0 d + b y0 d= d 根据解系的 公式： x =x1 + b t ; y =y1 - a t; 我们首先假设他最小的解x=0 ，然后求出 此时的 t=-x1/b; 然后带入求最小的解x=x1+bt=x1 - bt ;因为此时的t为 负数， 减去他的 负数，就是等于加上他。 代码#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;using namespace std;long long x, y, m, n, l;long long a, b, d, k, s, t;long long gcd(long long a, long long b)&#123; long long c; if (a &lt; b) &#123; c = a; a = b; b = c; &#125; while (b) &#123; c = b; b = a % b; a = c; &#125; return a;&#125;long long extended_gcd(long long a, long long b, long long &amp;x, long long &amp;y)&#123; long long ans, t; if (b == 0) &#123; x = 1; y = 0; return a; &#125; else &#123; ans = extended_gcd(b, a % b, x, y); t = x; x = y; y = t - (a / b) * y; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l) != EOF) &#123; a = n - m; b = l; d = x - y; long long r = gcd(a, b); if (d % r != 0) &#123; printf(&quot;Impossible\\n&quot;); continue; &#125; a /= r; b /= r; d /= r; extended_gcd(a, b, s, k); s = s * d; k = k * d; t = s / b; s = s - t * b; if (s &lt; 0) s += b; printf(&quot;%lld\\n&quot;, s); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1318 Word Amalgamation","slug":"POJ-1318-Word-Amalgamation","date":"2014-07-23T13:38:41.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1318-Word-Amalgamation/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1318-Word-Amalgamation/","excerpt":"题目源地址： http://poj.org/problem?id=1318 理解一开始的思路有点偏，想要单纯的使用string类的compare函数来解决问题。但是稍微考虑一下之后发现，复杂度有点高。事实上，我根本就不需要知道它们是不是匹配，只要排序之后匹配即可。","text":"题目源地址： http://poj.org/problem?id=1318 理解一开始的思路有点偏，想要单纯的使用string类的compare函数来解决问题。但是稍微考虑一下之后发现，复杂度有点高。事实上，我根本就不需要知道它们是不是匹配，只要排序之后匹配即可。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;#define MAX 105string dic[MAX], out[MAX], tmp;int n, i;int flag;int main(int argc, char const *argv[])&#123; while (cin &gt;&gt; dic[i] &amp;&amp; dic[i][0] != &apos;X&apos;) i++; sort(dic, dic + i); n = i; for (i = 0; i &lt; n; i++) &#123; out[i] = dic[i]; sort(dic[i].begin(), dic[i].end()); &#125; while (cin &gt;&gt; tmp) &#123; if (tmp[0] == &apos;X&apos;) break; flag = 0; sort(tmp.begin(), tmp.end()); for (i = 0; i &lt; n; i++) &#123; if (tmp == dic[i]) &#123; flag = 1; cout &lt;&lt; out[i] &lt;&lt; endl; &#125; &#125; if (flag == 0) cout &lt;&lt; &quot;NOT A VALID WORD&quot; &lt;&lt; endl; cout &lt;&lt; &quot;******&quot; &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1316 Self Numbers","slug":"POJ-1316-Self-Numbers","date":"2014-07-23T02:43:24.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1316-Self-Numbers/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1316-Self-Numbers/","excerpt":"题目源地址： http://poj.org/problem?id=1316 理解水题，开一个数组模拟，水过～","text":"题目源地址： http://poj.org/problem?id=1316 理解水题，开一个数组模拟，水过～ 代码#include &lt;stdio.h&gt;int data[10010] = &#123;0&#125;;int sum(int num)&#123; int ans = 0; while (num &gt; 0) &#123; ans += num % 10; num /= 10; &#125; return ans;&#125;int main(int argc, char const *argv[])&#123; int i = 0; for (i = 1; i &lt; 10001; ++i) &#123; data[i + sum(i)] = 1; &#125; for (i = 1; i &lt; 10001; ++i) &#123; if (!data[i]) &#123; printf(&quot;%d\\n&quot;, i); &#125; &#125;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1298 史上最难的问题","slug":"POJ-1298-The-Hardest-Problem-Ever","date":"2014-07-23T02:35:36.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1298-The-Hardest-Problem-Ever/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1298-The-Hardest-Problem-Ever/","excerpt":"题目源地址： http://poj.org/problem?id=1298 理解问题的纠结之处在于编译器根本就不给gets和puts改过自新的机会，调试花了很久= =。恩，我也应该培养避免使用这些函数的习惯。回到题目上来，题意还是比较清楚的，向后移动五位即可。","text":"题目源地址： http://poj.org/problem?id=1298 理解问题的纠结之处在于编译器根本就不给gets和puts改过自新的机会，调试花了很久= =。恩，我也应该培养避免使用这些函数的习惯。回到题目上来，题意还是比较清楚的，向后移动五位即可。 代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; char *p, cipher[128]; gets(cipher); while (strcmp(cipher, &quot;ENDOFINPUT&quot;)) &#123; if (!strcmp(cipher, &quot;START&quot;)) &#123; gets(cipher); while (strcmp(cipher, &quot;END&quot;)) &#123; for (p = cipher; *p; ++p) &#123; if (&apos;A&apos; &lt;= *p &amp;&amp; *p &lt;= &apos;Z&apos;) &#123; *p = *p &lt; &apos;F&apos; ? 21 + *p : *p - 5; &#125; putchar(*p); &#125; gets(cipher); &#125; putchar(&apos;\\n&apos;); &#125; gets(cipher); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1256 Anagram","slug":"POJ-1256-Anagram","date":"2014-07-23T02:07:50.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1256-Anagram/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1256-Anagram/","excerpt":"题目源地址： http://poj.org/problem?id=1256 理解再次遇到一道使用next_permutation的题目，不过这一次需要针对题目的给出的条件重新写一个cmp函数。","text":"题目源地址： http://poj.org/problem?id=1256 理解再次遇到一道使用next_permutation的题目，不过这一次需要针对题目的给出的条件重新写一个cmp函数。 代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;bool cmp(char a, char b)&#123; if (tolower(a) == tolower(b)) return a &lt; b; else return tolower(a) &lt; tolower(b);&#125;int main()&#123; int t; cin &gt;&gt; t; while (t--) &#123; string str; cin &gt;&gt; str; sort(str.begin(), str.end(), cmp); do &#123; cout &lt;&lt; str &lt;&lt; endl; &#125; while (next_permutation(str.begin(), str.end(), cmp)); &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1247 Magnificent Meatballs","slug":"POJ-1247-Magnificent-Meatballs","date":"2014-07-23T02:03:12.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/23/POJ-1247-Magnificent-Meatballs/","link":"","permalink":"https://xuanwo.org/2014/07/23/POJ-1247-Magnificent-Meatballs/","excerpt":"题目源地址： http://poj.org/problem?id=1247 理解让给的肉丸子少的人继续给，直到最后判断是否相等。","text":"题目源地址： http://poj.org/problem?id=1247 理解让给的肉丸子少的人继续给，直到最后判断是否相等。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int table[33];int main(int argc, char const *argv[])&#123; int n; while(cin&gt;&gt;n,n) &#123; memset(table,0,sizeof(table)); int i; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;table[i]; &#125; int sumE=0,sumS=0; int postE=n,postS=1; while(postS&lt;=postE) &#123; if(sumE&gt;=sumS) &#123;sumS+=table[postS];postS++;&#125; else &#123;sumE+=table[postE];postE--;&#125; &#125; if(sumE!=sumS) &#123; cout&lt;&lt;&quot;No equal partitioning.&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;Sam stops at position &quot;&lt;&lt;--postS&lt;&lt;&quot; and Ella stops at position &quot;&lt;&lt;++postE&lt;&lt;&quot;.&quot;&lt;&lt;endl; &#125; return 0;&#125; 更新日志 2014年07月23日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1218 THE DRUNK JAILER","slug":"POJ-1218-THE-DRUNK-JAILER","date":"2014-07-22T21:37:10.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1218-THE-DRUNK-JAILER/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1218-THE-DRUNK-JAILER/","excerpt":"题目源地址： http://poj.org/problem?id=1218 理解汗= =，偷鸡水过了，正好是牢房数的平方根向下取整，不过没有严格的证明","text":"题目源地址： http://poj.org/problem?id=1218 理解汗= =，偷鸡水过了，正好是牢房数的平方根向下取整，不过没有严格的证明 代码#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n, a, k; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; k; a = sqrt(k); cout &lt;&lt; a &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月22日 已AC，有待证明。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1163 The Triangle","slug":"POJ-1163-The-Triangle","date":"2014-07-22T21:12:47.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1163-The-Triangle/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1163-The-Triangle/","excerpt":"题目源地址： http://poj.org/problem?id=1163 理解这是第一道关于DP的题目，据说是用暴力的方法会直接超时，因为有大量的重复计算。使用DP可以避免这一点，最关键的公式是triangle[i][j] += max(triangle[i + 1][j] : triangle[i + 1][j + 1])","text":"题目源地址： http://poj.org/problem?id=1163 理解这是第一道关于DP的题目，据说是用暴力的方法会直接超时，因为有大量的重复计算。使用DP可以避免这一点，最关键的公式是triangle[i][j] += max(triangle[i + 1][j] : triangle[i + 1][j + 1]) 代码#include&lt;stdio.h&gt;#define MAX 100int triangle[MAX][MAX];int main()&#123; int n, i, j; scanf(&quot;%d&quot;, &amp;n); for (i = 0; i &lt; n; i++) for (j = 0; j &lt;= i; j++) scanf(&quot;%d&quot;, triangle[i] + j); for (i = n - 2; i &gt;= 0; i--) for (j = 0; j &lt;= i; j++) triangle[i][j] += triangle[i + 1][j] &gt; triangle[i + 1][j + 1] ? triangle[i + 1][j] : triangle[i + 1][j + 1]; printf(&quot;%d\\n&quot;, triangle[0][0]); return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1083 Moving Tables","slug":"POJ-1083-Moving-Tables","date":"2014-07-22T21:03:10.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1083-Moving-Tables/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1083-Moving-Tables/","excerpt":"题目源地址： http://poj.org/problem?id=1083 理解题目不难，关键在于理解题意。开一个数组，求出每一张桌子移动的时间，遍历找出最大值即可。","text":"题目源地址： http://poj.org/problem?id=1083 理解题目不难，关键在于理解题意。开一个数组，求出每一张桌子移动的时间，遍历找出最大值即可。 代码#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; int n, tables, corridor[200], i, j, start, end, time, x, y; scanf(&quot;%d&quot;, &amp;n); while (n-- &gt; 0) &#123; memset(corridor, 0, sizeof(corridor)); time = 0; scanf(&quot;%d&quot;, &amp;tables); for (i = 0; i &lt; tables; i++) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); start = ((x &lt; y ? x : y) - 1) / 2; end = ((x &gt; y ? x : y) - 1) / 2; for (j = start; j &lt;= end; j++) corridor[j] += 10; &#125; for (i = 0; i &lt; 200; i++) time = corridor[i] &gt; time ? corridor[i] : time; printf(&quot;%d\\n&quot;, time); &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1146 ID Codes","slug":"POJ-1146-ID-Codes","date":"2014-07-22T20:52:19.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1146-ID-Codes/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1146-ID-Codes/","excerpt":"题目源地址： http://poj.org/problem?id=1146 理解使用STL里面的next_permutation轻松水掉。","text":"题目源地址： http://poj.org/problem?id=1146 理解使用STL里面的next_permutation轻松水掉。 新技能getnext_permutation 代码#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; string str; while(cin&gt;&gt;str,str[0]!=&apos;#&apos;) &#123; bool flag=true; if(next_permutation(str.begin(),str.end())) &#123; flag=false; cout&lt;&lt;str&lt;&lt;endl; &#125; if(flag)printf(&quot;No Successor\\n&quot;); &#125;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1068 Parencodings","slug":"POJ-1068-Parencodings","date":"2014-07-22T20:37:35.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1068-Parencodings/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1068-Parencodings/","excerpt":"题目源地址： http://poj.org/problem?id=1068 理解模拟栈操作，主要是对题目意思的理解。","text":"题目源地址： http://poj.org/problem?id=1068 理解模拟栈操作，主要是对题目意思的理解。 代码#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int a[25], b[25], c[100];int main(int argc, char const *argv[])&#123; int i, j, t, n, p, num; stack&lt;int&gt; st; scanf(&quot;%d&quot;, &amp;t); while (t--) &#123; num = 0; cin &gt;&gt; n; a[0] = 0; p = 0; for (i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a[i]; for (j = p; j &lt; p + a[i] - a[i - 1]; j++) c[j] = j + 1; c[p + a[i] - a[i - 1]] = -(p + a[i] - a[i - 1] + 1); p = p + a[i] - a[i - 1] + 1; &#125; j = 0; for (i = 0; i &lt; p; i++) &#123; if (c[i] &gt; 0) st.push(c[i]); else &#123; num = st.top(); st.pop(); num = (-c[i] - num) / 2 + 1; b[j] = num; j++; &#125; &#125; for (i = 0; i &lt; j - 1; i++) printf(&quot;%d &quot;, b[i]); printf(&quot;%d\\n&quot;, b[j - 1]); &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2492 A Bug's Life","slug":"POJ-2492-A-Bug's-Life","date":"2014-07-22T17:12:30.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/22/POJ-2492-A-Bug's-Life/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-2492-A-Bug's-Life/","excerpt":"题目源地址： http://poj.org/problem?id=2492 理解当初学习并查集的时候做得题目，是一个比较经典的关于并查集的题目","text":"题目源地址： http://poj.org/problem?id=2492 理解当初学习并查集的时候做得题目，是一个比较经典的关于并查集的题目 代码#include&lt;cstdio&gt;const int maxn = 2000 + 10;int p[maxn];int r[maxn];int find(int x)&#123; if (x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x] + r[t]) % 2; return p[x];&#125;void Union(int x, int y)&#123; int fx = find(x); int fy = find(y); p[fx] = fy; r[fx] = (r[x] + 1 + r[y]) % 2;&#125;void set(int n)&#123; for (int i = 1; i &lt;= n; i++) &#123; p[i] = i; r[i] = 0; &#125;&#125;int main(int argc, char const *argv[])&#123; int T; scanf(&quot;%d&quot;, &amp;T); for (int i = 1; i &lt;= T; i++) &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); set(n); int x, y; bool flag = true; while (m--) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); if (find(x) == find(y)) &#123; if (r[x] == r[y]) &#123; flag = false; continue; &#125; &#125; else Union(x, y); &#125; printf(&quot;Scenario #%d:\\n&quot;, i); if (flag) printf(&quot;No suspicious bugs found!\\n&quot;); else printf(&quot;Suspicious bugs found!\\n&quot;); printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1988 Cube Stacking","slug":"POJ-1988-Cube-Stacking","date":"2014-07-22T16:36:53.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/22/POJ-1988-Cube-Stacking/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1988-Cube-Stacking/","excerpt":"题目源地址： http://poj.org/problem?id=1988 理解这道题也想了很久。问题主要出在堆叠得过程中，我只考虑了根节点的变化，而没有去更新位于同一个根节点下的方块的高度变化。发现问题之后，试图寻找到一种有效得递归方法，但是失败了。无奈之后，决定再开一个deep数组来保存当前节点到根节点之间的深度差。","text":"题目源地址： http://poj.org/problem?id=1988 理解这道题也想了很久。问题主要出在堆叠得过程中，我只考虑了根节点的变化，而没有去更新位于同一个根节点下的方块的高度变化。发现问题之后，试图寻找到一种有效得递归方法，但是失败了。无奈之后，决定再开一个deep数组来保存当前节点到根节点之间的深度差。 代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define N 30010int pre[N], son[N], deep[N];int find(int x)&#123; int temp; if (x == pre[x]) return x; temp = pre[x]; pre[x] = find(temp); deep[x] += deep[temp]; return pre[x];&#125;int main(int argc, char const *argv[])&#123; int p; char ope; int a, b; int query; int root1, root2; scanf(&quot;%d&quot;, &amp;p); for (int i = 1; i &lt; N; ++i) &#123; pre[i] = i; son[i] = 1; deep[i] = 0; &#125; for (int i = 0; i &lt; p; ++i) &#123; scanf(&quot;%*c%c&quot;, &amp;ope); if (ope == &apos;M&apos;) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); root1 = find(a); root2 = find(b); if (root1 != root2) &#123; pre[root2] = root1; deep[root2] = son[root1]; son[root1] += son[root2]; &#125; &#125; else &#123; scanf(&quot;%d&quot;, &amp;query); printf(&quot;%d\\n&quot;, son[find(query)] - deep[query] - 1); &#125; &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1703 Find them, Catch them","slug":"POJ-1703-Find-them-Catch-them","date":"2014-07-22T13:51:22.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/22/POJ-1703-Find-them-Catch-them/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1703-Find-them-Catch-them/","excerpt":"题目源地址： http://poj.org/problem?id=1703 理解这个并查集有点不一样，之前做过的全都是判断是否连通，这一次确实要判断是否不连通。想了一想，其实还是可以转换过来的。假定r1，r2分别表示ab，bc之间的关系，0表示相同，1表示不同，则有下面的逻辑表。 (a, b) (b, c) (a, c) (r1+r2)%2 0 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0","text":"题目源地址： http://poj.org/problem?id=1703 理解这个并查集有点不一样，之前做过的全都是判断是否连通，这一次确实要判断是否不连通。想了一想，其实还是可以转换过来的。假定r1，r2分别表示ab，bc之间的关系，0表示相同，1表示不同，则有下面的逻辑表。 (a, b) (b, c) (a, c) (r1+r2)%2 0 0 0 0 0 1 1 1 1 0 1 1 1 1 0 0 代码#include&lt;cstdio&gt;const int maxn = 100000 + 10;int p[maxn];int r[maxn];int find(int x)&#123; if (x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x] + r[t]) % 2; return p[x];&#125;void Union(int x, int y)&#123; int fx = find(x); int fy = find(y); p[fx] = fy; r[fx] = (r[x] + 1 + r[y]) % 2;&#125;void set(int n)&#123; for (int x = 1; x &lt;= n; x++) &#123; p[x] = x; r[x] = 0; &#125;&#125;int main(int argc, char const *argv[])&#123; int T; int n, m; scanf(&quot;%d&quot;, &amp;T); while (T--) &#123; scanf(&quot;%d%d%*c&quot;, &amp;n, &amp;m); set(n); char c; int x, y; while (m--) &#123; scanf(&quot;%c%d%d%*c&quot;, &amp;c, &amp;x, &amp;y); if (c == &apos;A&apos;) &#123; if (find(x) == find(y)) &#123; if (r[x] != r[y]) printf(&quot;In different gangs.\\n&quot;); else printf(&quot;In the same gang.\\n&quot;); &#125; else printf(&quot;Not sure yet.\\n&quot;); &#125; else if (c == &apos;D&apos;) &#123; Union(x, y); &#125; &#125; &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1308 Is It A Tree?","slug":"POJ-1308-Is-It-A-Tree","date":"2014-07-22T04:16:00.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1308-Is-It-A-Tree/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1308-Is-It-A-Tree/","excerpt":"题目源地址： http://poj.org/problem?id=1308 理解同样是并查集的应用，难点在于如何判断给定的点之间是否形成了森林。事实上，只要判断树与树之间有没有成环即可。","text":"题目源地址： http://poj.org/problem?id=1308 理解同样是并查集的应用，难点在于如何判断给定的点之间是否形成了森林。事实上，只要判断树与树之间有没有成环即可。 代码#include &lt;stdio.h&gt;#define N 1000int father[N], rank[N];void makeset(int x)&#123; father[x] = x; rank[x] = 0;&#125;int find(int x)&#123; if (x != father[x]) father[x] = find(father[x]); return father[x];&#125;int Union(int x, int y)&#123; x = find(x); y = find(y); if (x == y) return 0; if (rank[x] &gt; rank[y]) father[y] = x; else &#123; if (rank[x] == rank[y]) rank[y]++; father[x] = y; &#125; return 1;&#125;int main(int argc, char const *argv[])&#123; int k = 1; int a, b; int flag = 0; register int i; for (i = 0; i &lt; N; i++) makeset(i); while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF &amp;&amp; a &gt;= 0 &amp;&amp; b &gt;= 0) &#123; if (!a &amp;&amp; !b) &#123; int cnt = 0; for (i = 0; i &lt; N; i++) if (father[i] == i &amp;&amp; rank[i]) cnt++; if (cnt &gt; 1) flag = 1; if (!flag) printf(&quot;Case %d is a tree.\\n&quot;, k++); else printf(&quot;Case %d is not a tree.\\n&quot;, k++); for (i = 0; i &lt; N; i++) makeset(i); flag = 0; continue; &#125; if (!flag &amp;&amp; !Union(a, b)) flag = 1; &#125; return 0; &#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2524 Ubiquitous Religions","slug":"POJ-2524-Ubiquitous-Religions","date":"2014-07-22T03:45:40.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/22/POJ-2524-Ubiquitous-Religions/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-2524-Ubiquitous-Religions/","excerpt":"题目源地址： http://poj.org/problem?id=2524 理解POJ上最简单的一道关于并查集的题目，没有使用路径压缩，没有进行优化，直接水过。","text":"题目源地址： http://poj.org/problem?id=2524 理解POJ上最简单的一道关于并查集的题目，没有使用路径压缩，没有进行优化，直接水过。 代码#include &lt;cstdio&gt;int f[50005], sum;int find(int x)&#123; if (f[x] != x) f[x] = find(f[x]); return f[x];&#125;void make(int a, int b)&#123; int f1 = find(a); int f2 = find(b); if (f1 != f2) &#123; f[f2] = f1; sum--; &#125;&#125;int main(int argc, char const *argv[])&#123; int n, m, p = 1, i; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) &#123; if (n == 0 &amp;&amp; m == 0) break; for (i = 1; i &lt;= n; i++) f[i] = i; sum = n; for (i = 1; i &lt;= m; i++) &#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); make(a, b); &#125; printf(&quot;Case %d: %d\\n&quot;, p++, sum ); &#125; return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1082 食物链","slug":"POJ-1082-Food-Links","date":"2014-07-22T02:43:08.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/22/POJ-1082-Food-Links/","link":"","permalink":"https://xuanwo.org/2014/07/22/POJ-1082-Food-Links/","excerpt":"题目源地址： http://poj.org/problem?id=1082 理解理解时候的困难在于如何把题目中吃与被吃的关系用一个计算机能理解的方式表达出来。后来使用了0表示他们是同类，用1表示a吃b，用2表示b吃a。再使用并查集的相关知识得到最后得结果。","text":"题目源地址： http://poj.org/problem?id=1082 理解理解时候的困难在于如何把题目中吃与被吃的关系用一个计算机能理解的方式表达出来。后来使用了0表示他们是同类，用1表示a吃b，用2表示b吃a。再使用并查集的相关知识得到最后得结果。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int Max = 50005;int n, pa[Max], rank[Max];void make_set()&#123; for (int x = 1; x &lt;= n; x ++) &#123; pa[x] = x; rank[x] = 0; &#125;&#125;int find_set(int x)&#123; int tmp = pa[x]; if (x != pa[x]) &#123; pa[x] = find_set(pa[x]); rank[x] = (rank[x] + rank[tmp]) % 3; &#125; return pa[x];&#125;void union_set(int x, int y, int w)&#123; int a = find_set(x); int b = find_set(y); pa[b] = a; rank[b] = (rank[x] - rank[y] + w + 3) % 3;&#125;int main()&#123; int t, ans = 0; scanf(&quot;%d %d&quot;, &amp;n, &amp;t); make_set(); while (t --) &#123; int d, x, y; scanf(&quot;%d %d %d&quot;, &amp;d, &amp;x, &amp;y); if (x &gt; n || y &gt; n) ans ++; else &#123; if (d == 1) &#123; if (find_set(x) == find_set(y) &amp;&amp; rank[x] != rank[y]) ans ++; else union_set(x, y, 0); &#125; if (d == 2) &#123; if (find_set(x) == find_set(y) &amp;&amp; (rank[x] + 1) % 3 != rank[y]) ans ++; else union_set(x, y, 1); &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 更新日志 2014年07月22日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1046 Color Me Less","slug":"POJ-1046-Color-Me-Less","date":"2014-07-21T15:55:53.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/21/POJ-1046-Color-Me-Less/","link":"","permalink":"https://xuanwo.org/2014/07/21/POJ-1046-Color-Me-Less/","excerpt":"题目源地址： http://poj.org/problem?id=1046 理解题目并不难，暴力水过即可。用到了结构体的知识，可惜我对结构体的理解还是太过于表层。其实我可以把结构体作为函数的参数输入，这样可以减少很大的代码量。","text":"题目源地址： http://poj.org/problem?id=1046 理解题目并不难，暴力水过即可。用到了结构体的知识，可惜我对结构体的理解还是太过于表层。其实我可以把结构体作为函数的参数输入，这样可以减少很大的代码量。 代码#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;struct list&#123; int r, g, b;&#125; standard[16];double dis, tmp;int ansr, ansg, ansb;int r, g, b;double cal(int r1, int r2, int g1, int g2, int b1, int b2)&#123; return sqrt((double)((r1 - r2) * (r1 - r2) + (g1 - g2) * (g1 - g2) + (b1 - b2) * (b1 - b2)));&#125;int main(int argc, char const *argv[])&#123; for (int i = 0; i &lt; 16; i++) scanf(&quot;%d%d%d&quot;, &amp;standard[i].r, &amp;standard[i].g, &amp;standard[i].b); while (scanf(&quot;%d%d%d&quot;, &amp;r, &amp;g, &amp;b) &amp;&amp; r != -1) &#123; dis = 450.0; ansr=ansg=ansb=0; for (int i = 0; i &lt; 16; i++) &#123; tmp = cal(r, standard[i].r, g, standard[i].g, b, standard[i].b); if (tmp&lt;dis) &#123; dis = tmp; ansr = standard[i].r; ansg = standard[i].g; ansb = standard[i].b; &#125; else continue; &#125; printf(&quot;(%d,%d,%d) maps to (%d,%d,%d)\\n&quot;, r, g, b, ansr, ansg, ansb); &#125; return 0;&#125; 更新日志 2014年07月日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1028 Web Navigation","slug":"POJ-1028-Web-Navigation","date":"2014-07-20T15:40:31.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/20/POJ-1028-Web-Navigation/","link":"","permalink":"https://xuanwo.org/2014/07/20/POJ-1028-Web-Navigation/","excerpt":"题目源地址： http://poj.org/problem?id=1028 理解这是一道STL里面的栈的运用的一个模板题。构建两个栈，一个存放forward，一个存放backward，然后后再建立一个string类用于存放浏览器当前的页面。题目不难，但是要理解你现在的操作对栈影响是什么，先后顺序一点都不能错。","text":"题目源地址： http://poj.org/problem?id=1028 理解这是一道STL里面的栈的运用的一个模板题。构建两个栈，一个存放forward，一个存放backward，然后后再建立一个string类用于存放浏览器当前的页面。题目不难，但是要理解你现在的操作对栈影响是什么，先后顺序一点都不能错。 新技能getstd::stack中几个常用的操作|stack example; |建立一个int型的栈 ||example.push(a); |将a的值放在example栈的最顶端 ||example.top(); |获取example栈当前最顶端的值，此处它的返回值为a的值||example.pop(); |将example栈最顶端的值丢弃 ||example.empty(); |判断example栈是否为空，是的话返回1，不是的话返回0 | 代码#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;stack&lt;string&gt; forward;stack&lt;string&gt; backward;string order, tmp, now;int main(int argc, char const *argv[])&#123; now = &quot;http://www.acm.org/&quot;; while (cin &gt;&gt; order &amp;&amp; order.compare(&quot;QUIT&quot;)) &#123; if (!order.compare(&quot;VISIT&quot;)) &#123; backward.push(now); cin &gt;&gt; now; cout &lt;&lt; now &lt;&lt; endl; while (!forward.empty()) forward.pop(); &#125; else if (!order.compare(&quot;BACK&quot;)) &#123; if (!backward.empty()) &#123; forward.push(now); now = backward.top(); backward.pop(); cout &lt;&lt; now &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Ignored\\n&quot;; continue; &#125; &#125; else if (!order.compare(&quot;FORWARD&quot;)) &#123; if (!forward.empty()) &#123; backward.push(now); now = forward.top(); forward.pop(); cout &lt;&lt; now &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Ignored\\n&quot;; continue; &#125; &#125; &#125; return 0;&#125; 更新日志 2014年07月20日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1045 Bode Plot","slug":"POJ-1045-Bode-Plot","date":"2014-07-20T14:39:05.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/20/POJ-1045-Bode-Plot/","link":"","permalink":"https://xuanwo.org/2014/07/20/POJ-1045-Bode-Plot/","excerpt":"题目源地址： http://poj.org/problem?id=1045 理解额- -，居然考到了物理公式。推倒的过程中，卡在了题目中的相位不是已知量。知道看了discuss才明白，可以通过令t=0特殊值带入的方法求解。果真是物理题做得少了- -，不机智了。类似于这样的精度问题，G++都是WA，只有C++才能A。至今不知原因。","text":"题目源地址： http://poj.org/problem?id=1045 理解额- -，居然考到了物理公式。推倒的过程中，卡在了题目中的相位不是已知量。知道看了discuss才明白，可以通过令t=0特殊值带入的方法求解。果真是物理题做得少了- -，不机智了。类似于这样的精度问题，G++都是WA，只有C++才能A。至今不知原因。 新技能get特殊值带入求未知量 代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int n;double vs,r,c,w;int main(int argc, char const *argv[])&#123; cin&gt;&gt;vs&gt;&gt;r&gt;&gt;c&gt;&gt;n; while(n--) &#123; cin&gt;&gt;w; printf(&quot;%.3lf\\n&quot;,(c*r*w*vs)/sqrt(1+(c*r*w)*(c*r*w))); &#125; return 0;&#125; 更新日志 2014年07月日 已AC，C++。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2199 Rate of Return","slug":"POJ-2199-Rate-of-Return","date":"2014-07-20T14:25:25.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/20/POJ-2199-Rate-of-Return/","link":"","permalink":"https://xuanwo.org/2014/07/20/POJ-2199-Rate-of-Return/","excerpt":"题目源地址： http://poj.org/problem?id=2199 理解感觉题目并不是很难。给出n个月，每个月都存进去一定的钱，然后第n+1个月给出到这个月为止的本息和。运用二分法，逐步逼近，直到达到了精度要求。","text":"题目源地址： http://poj.org/problem?id=2199 理解感觉题目并不是很难。给出n个月，每个月都存进去一定的钱，然后第n+1个月给出到这个月为止的本息和。运用二分法，逐步逼近，直到达到了精度要求。 新技能get二分法循环形式 up = 2;down = 1;mid = (up + down) / 2;while ((mid - down) &gt; eps)&#123; temp = 0; for (i = 0; i &lt; count; i++) &#123; temp += cof[i] * pow(mid, month[i]);//迭代条件，自行修改 &#125; if (temp &lt; total) down = mid; else up = mid; mid = (up + down) / 2;&#125; 代码#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;double up, mid, down, rate;double cof[12];int month[12];int lastMon;double total, temp;int count;int Case = 0;int main()&#123; int i; scanf(&quot;%d&quot;, &amp;count); while (count != -1) &#123; Case++; for (i = 0; i &lt; count; i++) &#123; scanf(&quot;%d%lf&quot;, &amp;month[i], &amp;cof[i]); &#125; scanf(&quot;%d%lf&quot;, &amp;lastMon, &amp;total); for (i = 0; i &lt; count; i++) &#123; month[i] = lastMon - month[i] + 1; &#125; up = 2; down = 1; mid = (up + down) / 2; while ((mid - down) &gt; 0.000001) &#123; temp = 0; for (i = 0; i &lt; count; i++) &#123; temp += cof[i] * pow(mid, month[i]); &#125; if (temp &lt; total) down = mid; else up = mid; mid = (up + down) / 2; &#125; printf(&quot;Case %d: %.5lf\\n&quot;, Case, mid - 1); if (scanf(&quot;%d&quot;, &amp;count) &amp;&amp; count != -1) &#123; printf(&quot;\\n&quot;); &#125; &#125; return 0;&#125; 更新日志 2014年07月19日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1047 Round and Round We Go","slug":"POJ-1047-Round-and-Round-We-Go","date":"2014-07-18T17:38:41.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/18/POJ-1047-Round-and-Round-We-Go/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-1047-Round-and-Round-We-Go/","excerpt":"题目源地址： http://poj.org/problem?id=1047 理解一开始觉得很麻烦，打算用字符串+排序来处理是否符合题意。但是无意中发现，事实上当一个数是循环数的时候，这个数本身乘以它的长度+1恰好使得每一位上的数都是9，比如142857*(6+1)=999999。发现了这一点，题目就变成一道水题了。用java的高精度类水掉即可～","text":"题目源地址： http://poj.org/problem?id=1047 理解一开始觉得很麻烦，打算用字符串+排序来处理是否符合题意。但是无意中发现，事实上当一个数是循环数的时候，这个数本身乘以它的长度+1恰好使得每一位上的数都是9，比如142857*(6+1)=999999。发现了这一点，题目就变成一道水题了。用java的高精度类水掉即可～ 新技能get循环数的性质&gt; 乘以产生一个循环数的质数时，结果会是一系列的9.如 142857 × 7 = 999999。 如果将其按位划分成若干等长份并加在一起，结果会是一系列的9.这是Midy定理的特殊情况。如14 + 28 + 57 = 99 142 + 857 = 999 1428 + 5714+ 2857 = 9999 所有的循环数都是9的倍数。 代码import java.util.*;import java.math.*;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); BigInteger b, c, d; String str, str1, str2, str3; int i, len; while (cin.hasNext()) &#123; str = cin.next(); b = new BigInteger(str); len = str.length() + 1; char []kids = new char[len - 1]; for (i = 0; i &lt; len - 1; i++) kids[i] = &apos;9&apos;; str3 = new String(kids); str1 = String.valueOf(len); c = new BigInteger(str1); d = b.multiply(c); str2 = d.toString(); if (str2.compareTo(str3) == 0) System.out.println(str + &quot; &quot; + &quot;is cyclic&quot;); else System.out.println(str + &quot; &quot; + &quot;is not cyclic&quot;); &#125; &#125;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1306 Combinations","slug":"POJ-1306-Combinations","date":"2014-07-18T15:43:53.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/18/POJ-1306-Combinations/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-1306-Combinations/","excerpt":"题目源地址： http://poj.org/problem?id=1306 理解高精度阶乘的题目，再次用java水掉= =。","text":"题目源地址： http://poj.org/problem?id=1306 理解高精度阶乘的题目，再次用java水掉= =。 代码import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin=new Scanner(System.in); while(true)&#123; int a=cin.nextInt(); int b=cin.nextInt(); if(a==0 &amp;&amp; b==0) return; BigInteger fir=factor(a); BigInteger sec=factor(a-b); BigInteger third=factor(b); BigInteger result=fir.divide(sec).divide(third); System.out.println(a+&quot; things taken &quot;+b+&quot; at a time is &quot;+result.toString()+&quot; exactly.&quot;); &#125; &#125; public static BigInteger factor(int n)&#123; BigInteger goal=BigInteger.ONE; for(int i=n;i&gt;=2;i--)&#123; goal=goal.multiply(new BigInteger(String.valueOf(i)) ); &#125; return goal; &#125;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1131 Octal Fractions","slug":"POJ-1131-Octal-Fractions","date":"2014-07-18T15:29:12.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/18/POJ-1131-Octal-Fractions/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-1131-Octal-Fractions/","excerpt":"题目源地址： http://poj.org/problem?id=1131 理解题意挺简单，就是把八进制浮点数转化为十进制，同样是用高精度类，叠乘即可～","text":"题目源地址： http://poj.org/problem?id=1131 理解题意挺简单，就是把八进制浮点数转化为十进制，同样是用高精度类，叠乘即可～ 代码import java.math.BigDecimal;import java.math.RoundingMode;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(System.in); String str, ors; BigDecimal x, y, z; while (cin.hasNext()) &#123; ors = cin.next(); str = ors.substring(ors.indexOf(&quot;.&quot;) + 1, ors.length()); z = new BigDecimal(0); y = new BigDecimal(1); for (int i = 0; i &lt; str.length(); i++) &#123; x = new BigDecimal(str.charAt(i) - &apos;0&apos;); y = y.multiply(new BigDecimal(8)); x = x.divide(y, str.length() * 3, RoundingMode.HALF_UP); z = z.add(x); &#125; System.out.println(ors + &quot; [8] = &quot; + z + &quot; [10]&quot;); &#125; cin.close(); &#125;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1503 Integer Inquiry","slug":"POJ-1503-Integer-Inquiry","date":"2014-07-18T15:04:04.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/18/POJ-1503-Integer-Inquiry/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-1503-Integer-Inquiry/","excerpt":"题目源地址： http://poj.org/problem?id=1503 理解还是高精度计算，大数相加～","text":"题目源地址： http://poj.org/problem?id=1503 理解还是高精度计算，大数相加～ 代码import java.util.Scanner;import java.io.*;import java.math.*;public class Main &#123; public static void main(String args[]) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); BigInteger a; BigInteger b = new BigInteger(&quot;0&quot;); BigInteger c = new BigInteger(&quot;0&quot;); while(cin.hasNextBigInteger()) &#123; a = cin.nextBigInteger(); if(a.compareTo(c) == 0) break; b = b.add(a); &#125; System.out.println(b); &#125;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2305 Basic remains","slug":"POJ-2305-Basic-remains","date":"2014-07-18T14:46:10.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/18/POJ-2305-Basic-remains/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-2305-Basic-remains/","excerpt":"题目源地址： http://poj.org/problem?id=2305 理解高精度计算题啊，用Java的高精度类水过。","text":"题目源地址： http://poj.org/problem?id=2305 理解高精度计算题啊，用Java的高精度类水过。 代码import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; int n = scanner.nextInt(); if (n == 0) break; BigInteger aBigInteger = scanner.nextBigInteger(); BigInteger bBigInteger = scanner.nextBigInteger(); BigInteger a = new BigInteger(aBigInteger.toString(), n); BigInteger b = new BigInteger(bBigInteger.toString(), n); BigInteger cBigInteger = a.divide(b); BigInteger mBigInteger = a.subtract(cBigInteger.multiply(b)); System.out.println(mBigInteger.toString(n)); &#125; &#125;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3048 Max Factor","slug":"POJ-3307-Smart-Sister","date":"2014-07-18T00:23:10.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/18/POJ-3307-Smart-Sister/","link":"","permalink":"https://xuanwo.org/2014/07/18/POJ-3307-Smart-Sister/","excerpt":"题目源地址： http://poj.org/problem?id=3307 理解如果一个数可以通过其他数的各数字位相乘得到，则说这个数具有productivity property。要求求出第i个具有这种性质的数。我们考虑1～9这些数字，显然，我们只要考虑1，2，3，5，7这四个质因数，因为别的数都能通过他们来得到，于是可以得到代码。","text":"题目源地址： http://poj.org/problem?id=3307 理解如果一个数可以通过其他数的各数字位相乘得到，则说这个数具有productivity property。要求求出第i个具有这种性质的数。我们考虑1～9这些数字，显然，我们只要考虑1，2，3，5，7这四个质因数，因为别的数都能通过他们来得到，于是可以得到代码。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX 80000using namespace std;__int64 s[MAX];__int64 d2[MAX];__int64 d3[MAX];__int64 d5[MAX];__int64 d7[MAX];void init()&#123; int i; int pos2, pos3, pos5, pos7; __int64 a, b; s[1] = 1; pos2 = pos3 = pos5 = pos7 = 1; for (i = 1; i &lt; MAX - 1; i++) &#123; d2[i] = s[i] * 2; d3[i] = s[i] * 3; d5[i] = s[i] * 5; d7[i] = s[i] * 7; while (d2[pos2] &lt;= s[i])pos2++; while (d3[pos3] &lt;= s[i])pos3++; while (d5[pos5] &lt;= s[i])pos5++; while (d7[pos7] &lt;= s[i])pos7++; a = d2[pos2] &lt; d3[pos3] ? d2[pos2] : d3[pos3]; b = d5[pos5] &lt; d7[pos7] ? d5[pos5] : d7[pos7]; s[i + 1] = a &lt; b ? a : b; &#125;&#125;int main(int argc, char const *argv[])&#123; int k, n; scanf(&quot;%d&quot;, &amp;k); init(); while (k--) &#123; scanf(&quot;%d&quot;, &amp;n); printf(&quot;%I64d\\n&quot;, s[n]); &#125; return 0;&#125; 更新日志 2014年07月18日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2081 Recaman's Sequence","slug":"POJ-2081-Recaman's-Sequence","date":"2014-07-17T23:53:55.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/17/POJ-2081-Recaman's-Sequence/","link":"","permalink":"https://xuanwo.org/2014/07/17/POJ-2081-Recaman's-Sequence/","excerpt":"题目源地址： http://poj.org/problem?id=2081 理解简单的计算题。利用打表的方法，空间换时间。","text":"题目源地址： http://poj.org/problem?id=2081 理解简单的计算题。利用打表的方法，空间换时间。 代码#include &lt;iostream&gt;using namespace std;char ext[2600000] = &#123;0&#125;;int a[500001];void reset()&#123; int i; a[0] = 0; ext[0] = 1; for (i = 1; i &lt;= 500000; i++) &#123; a[i] = a[i - 1] - i; if (a[i] &lt; 0 || ext[a[i]]) &#123; a[i] = a[i - 1] + i; &#125; ext[a[i]] = 1; &#125;&#125;int main(int argc, char const *argv[])&#123; int k; reset(); while (cin &gt;&gt; k &amp;&amp; k != -1) &#123; cout &lt;&lt; a[k] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月17日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2153 Rank List","slug":"POJ-2153-Rank-List","date":"2014-07-16T22:55:02.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/16/POJ-2153-Rank-List/","link":"","permalink":"https://xuanwo.org/2014/07/16/POJ-2153-Rank-List/","excerpt":"题目源地址： http://poj.org/problem?id=2153 理解感觉不是很难，因为数据量不是很大，将人和成绩一一映射，然后遍历即可。","text":"题目源地址： http://poj.org/problem?id=2153 理解感觉不是很难，因为数据量不是很大，将人和成绩一一映射，然后遍历即可。 新技能getSTL库中Map 代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstdio&gt;using namespace std;int main(int argc, char *argv[])&#123; int n, m; int i, j; char str[200]; string str1; map&lt;string , int&gt;score; scanf(&quot;%d&quot;, &amp;n); getchar(); for (i = 0; i &lt; n; i++ ) &#123; gets(str); str1 = str; score[str1] = 0; &#125; int cnt[5005] = &#123;0&#125;; scanf(&quot;%d&quot;, &amp;m); string li = &quot;Li Ming&quot;; int rank = 0; int s = 0; int temp = 0; int temp2 = 0; int num; for (int k = 0; k &lt; m; k++) &#123; for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;num); getchar(); gets(str); str1 = str; temp2 = score[str1]; score[str1] = num + temp2; cnt[num + temp2]++; &#125; s = score[li]; rank = 1; temp += 100; for (i = temp; i &gt; s; i--) &#123; rank += cnt[i]; cnt[i] = 0; &#125; for (i = s; i &gt;= 0; i--) cnt[i] = 0; printf(&quot;%d\\n&quot;, rank); &#125; return 0;&#125; 更新日志 2014年07月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1014 Dividing","slug":"POJ-1014-Dividing","date":"2014-07-16T15:25:02.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/16/POJ-1014-Dividing/","link":"","permalink":"https://xuanwo.org/2014/07/16/POJ-1014-Dividing/","excerpt":"题目源地址： http://poj.org/problem?id=1014 理解我的思路非常直接，直接当成一道数学题来解。于是把所有的数都mod2，得到了一个二进制串，然后以这个为基础，开始寻找特例，结果挂的很惨。比如0 3 2 0 0 0，这种情况是在mod2的时候直接就舍去的。说明我这种方法本质上有着缺陷。网上的大牛们大多采用了多重背包的方法，但是有一个人在discuss中提出了mod60的方法。实际上，这个是mod2思路的进一步延伸，也就是解决了0 3 2 0 0 0这种类型的特例。然后再不断的用sum去减，判断最后能都减至0，实质上是用了DFS。","text":"题目源地址： http://poj.org/problem?id=1014 理解我的思路非常直接，直接当成一道数学题来解。于是把所有的数都mod2，得到了一个二进制串，然后以这个为基础，开始寻找特例，结果挂的很惨。比如0 3 2 0 0 0，这种情况是在mod2的时候直接就舍去的。说明我这种方法本质上有着缺陷。网上的大牛们大多采用了多重背包的方法，但是有一个人在discuss中提出了mod60的方法。实际上，这个是mod2思路的进一步延伸，也就是解决了0 3 2 0 0 0这种类型的特例。然后再不断的用sum去减，判断最后能都减至0，实质上是用了DFS。 代码#include &lt;cstdio&gt;using namespace std;int num[6] = &#123;0&#125;;int value[6] = &#123;1, 2, 3, 4, 5, 6&#125;;int mod[6] = &#123;60, 30, 20, 15, 12, 10&#125;;int t = 0;int cp[6] = &#123;0&#125;;int divide(int a)&#123; if (a == 0) return 1; for (int i = 5; i &gt;= 0; --i) &#123; if (cp[i] &amp;&amp; a &gt;= value[i]) &#123; cp[i]--; if (divide(a - value[i]) == 1) return 1; cp[i]++; &#125; &#125; return 0;&#125;int main(int argc, char const *argv[])&#123; while (true) &#123; int sum = 0; for (int i = 0; i &lt; 6; ++i) &#123; scanf(&quot;%d&quot;, &amp;num[i]); num[i] = num[i] % mod[i]; sum += value[i] * num[i]; cp[i] = num[i]; &#125; if (!sum) break; printf(&quot;Collection #%d:\\n&quot;, ++t); if (sum % 2 != 0) printf(&quot;Can&apos;t be divided.\\n&quot;); else &#123; sum = sum / 2; if (divide(sum)) printf(&quot;Can be divided.\\n&quot;); else printf(&quot;Can&apos;t be divided.\\n&quot;); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 更新日志 2014年07月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1012 Joseph","slug":"POJ-1012-Joseph","date":"2014-07-16T14:22:30.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/16/POJ-1012-Joseph/","link":"","permalink":"https://xuanwo.org/2014/07/16/POJ-1012-Joseph/","excerpt":"题目源地址： http://poj.org/problem?id=1012 理解用模拟的方法貌似会超时。直接打了一个表，求出0到14之间每一种k的值对应的m值，再根据输入输出就OK。","text":"题目源地址： http://poj.org/problem?id=1012 理解用模拟的方法貌似会超时。直接打了一个表，求出0到14之间每一种k的值对应的m值，再根据输入输出就OK。 代码#include &lt;iostream&gt;using namespace std;int r[14];int i, j, k;bool solve(int k, int i)&#123; int n = k * 2, m = i, x = 0; while (n &gt; k) &#123; x = (x + m - 1) % n; if (x &lt; k) return false; n--; &#125; return true;&#125;int main()&#123; for (k = 1; k &lt; 14; k++) &#123; for (i = k + 1;; i += k + 1) &#123; if (solve(k, i)) &#123; r[k] = i; break; &#125; else if (solve(k, i + 1)) &#123; r[k] = i + 1; break; &#125; &#125; &#125; while (cin &gt;&gt; k, k) &#123; cout &lt;&lt; r[k] &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1011 木棒","slug":"POJ-1011-Sticks","date":"2014-07-16T12:20:44.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/16/POJ-1011-Sticks/","link":"","permalink":"https://xuanwo.org/2014/07/16/POJ-1011-Sticks/","excerpt":"题目源地址： http://poj.org/problem?id=1011 理解一开始的想法比较简单，单纯的求和然后找出最短的那根。但是这样的做法有下面的一些问题：第一，最后的棒子的和不能比最短的棒子还短；第二，最后的棒子必须是由给定的棒子合成的。因此只能使用搜索的方法，但是常规的搜索会超时，必须辅以有效的剪枝，以下是参考之后的代码。","text":"题目源地址： http://poj.org/problem?id=1011 理解一开始的想法比较简单，单纯的求和然后找出最短的那根。但是这样的做法有下面的一些问题：第一，最后的棒子的和不能比最短的棒子还短；第二，最后的棒子必须是由给定的棒子合成的。因此只能使用搜索的方法，但是常规的搜索会超时，必须辅以有效的剪枝，以下是参考之后的代码。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int sticks[64], n, len, num, sum;bool used[64];bool end;bool compare(int a, int b)&#123; return a &gt; b;&#125;bool dfs(int cur, int left, int level)&#123; if (left == 0) &#123; if (level == num - 2) return true; for (cur = 0; used[cur]; cur++); used[cur] = true; if (dfs(cur + 1, len - sticks[cur], level + 1)) return true; used[cur] = false; return false; &#125; else &#123; if (cur &gt;= n - 1) return false; for (int i = cur; i &lt; n; i++) &#123; if (used[i]) continue; if ((sticks[i] == sticks[i - 1]) &amp;&amp; !used[i - 1]) continue; if (sticks[i] &gt; left) continue; used[i] = true; if (dfs(i, left - sticks[i], level)) return true; used[i] = false; &#125; return false; &#125;&#125;int main(int argc, char const *argv[])&#123; while (cin &gt;&gt; n) &#123; if (n == 0) break; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;sticks[i]); sum += sticks[i]; &#125; sort(sticks, sticks + n, compare); end = false; for (len = sticks[0]; len &lt;= sum / 2; len++) &#123; if (sum % len == 0) &#123; used[0] = true; num = sum / len; if (dfs(0, len - sticks[0], 0)) &#123; end = true; printf(&quot;%d\\n&quot;, len); break; &#125; used[0] = false; &#125; &#125; if (!end) printf(&quot;%d\\n&quot;, sum); memset(used, 0, sizeof(used)); &#125; return 0;&#125; 更新日志 2014年07月16日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1001 求高精度幂","slug":"POJ-1001-Big-Decimal","date":"2014-07-15T23:09:03.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/15/POJ-1001-Big-Decimal/","link":"","permalink":"https://xuanwo.org/2014/07/15/POJ-1001-Big-Decimal/","excerpt":"题目源地址： http://poj.org/problem?id=1001 理解搜索高精度计算的时候发现java自带了关于高精度处理的类，毫不客气的拿来用了～","text":"题目源地址： http://poj.org/problem?id=1001 理解搜索高精度计算的时候发现java自带了关于高精度处理的类，毫不客气的拿来用了～ 新技能getJava高精度计算BigDecimal r = cin.nextBigDecimal()定义一个高精度类stripTrailingZeros()除去尾部多余的0toPlainString()转化为string类 代码import java.io.*;import java.util.*;import java.math.BigDecimal;public class Main &#123; public static void main(String args[])throws Exception &#123; Scanner cin = new Scanner(System.in); while (cin.hasNext()) &#123; BigDecimal r = cin.nextBigDecimal(); int n = cin.nextInt(); r = r.pow(n).stripTrailingZeros(); String m_string = r.toPlainString(); if (m_string.charAt(0) == &apos;0&apos;) m_string = m_string.substring(1); System.out.println(m_string); &#125; &#125;&#125; 更新日志 2014年07月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2800 Joseph's Problem","slug":"POJ-2800-Joseph's-Problem","date":"2014-07-15T20:41:42.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/15/POJ-2800-Joseph's-Problem/","link":"","permalink":"https://xuanwo.org/2014/07/15/POJ-2800-Joseph's-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=2800 理解抱着侥幸心理使用了一般的方法来求，果然TLE了。然后开始计算∑1&lt;=i&lt;=n(k mod i)。由分析之，总共有三种情况，kn。分别寻找规律并转化为等差数列简化运算。","text":"题目源地址： http://poj.org/problem?id=2800 理解抱着侥幸心理使用了一般的方法来求，果然TLE了。然后开始计算∑1&lt;=i&lt;=n(k mod i)。由分析之，总共有三种情况，kn。分别寻找规律并转化为等差数列简化运算。 代码#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;long long jos( long long n , long long k )&#123; long long sum = 0 , a = ( long long ) sqrt ( k ), b = k / a , i ; if ( n &gt; k ) sum += ( n - k ) * k ; for ( i = a ; i &gt; 1 ; i -- ) &#123; long long s = k / i , e = k / ( i - 1 ) ; if ( s &gt; n ) break ; if ( e &gt; n ) e = n ; sum += ( k % e + k % ( s + 1 ) ) * ( e - s ) / 2 ; &#125; for ( i = 1 ; i &lt;= n &amp;&amp; i &lt;= b ; i ++ ) sum += k % i ; return sum ;&#125;int main(int argc, char const *argv[])&#123; long long n , k ; while ( scanf ( &quot;%I64d%I64d&quot;, &amp;n, &amp;k ) != EOF ) printf ( &quot;%I64d\\n&quot; , jos(n, k) ) ; return 0 ;&#125; 更新日志 2014年07月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2680 Computer Transformation","slug":"POJ-2680-Computer-Transformation","date":"2014-07-15T19:28:08.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/15/POJ-2680-Computer-Transformation/","link":"","permalink":"https://xuanwo.org/2014/07/15/POJ-2680-Computer-Transformation/","excerpt":"题目源地址： http://poj.org/problem?id=3048 理解数学规律并不难，很容易推出f[n]=f[n-1]+f[n-2]*2。但是2^1000次方，必须使用一定的手段来处理这个超大的数据。这里使用了一种比较简单的技巧，数组模拟。","text":"题目源地址： http://poj.org/problem?id=3048 理解数学规律并不难，很容易推出f[n]=f[n-1]+f[n-2]*2。但是2^1000次方，必须使用一定的手段来处理这个超大的数据。这里使用了一种比较简单的技巧，数组模拟。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int dig[1010][1010];int main(int argc, char const *argv[])&#123; dig[1][0] = 0; dig[2][0] = 1; for (int i = 3; i &lt;= 1000; i++) &#123; for (int j = 0; j &lt; 1000; j++) &#123; dig[i][j] += dig[i - 2][j] * 2 + dig[i - 1][j]; if (dig[i][j] &gt; 9) &#123; dig[i][j + 1] = dig[i][j] / 10; dig[i][j] %= 10; &#125; &#125; &#125; int n; while ( cin &gt;&gt; n) &#123; if ( n == 1) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl; else &#123; bool flag = true; for (int i = 999; i &gt;= 0; i--) &#123; if ( dig[n][i] &amp;&amp; flag) &#123; flag = false; &#125; if (!flag) cout &lt;&lt; dig[n][i] ; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 更新日志 2014年07月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2818 Making Change","slug":"POJ-2818-Making-Change","date":"2014-07-15T16:50:50.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/15/POJ-2818-Making-Change/","link":"","permalink":"https://xuanwo.org/2014/07/15/POJ-2818-Making-Change/","excerpt":"题目源地址： http://poj.org/problem?id=2818 理解感觉很水的一道题，不知道为什么交题的人很少（吐槽一下坑爹的美元换算）。用DFS水掉了，分别从dispenser到pennies来算一遍就OK。我本以为用四个for也能过，但是discuss上面有人说过不了，TLE。有时间我试试看。","text":"题目源地址： http://poj.org/problem?id=2818 理解感觉很水的一道题，不知道为什么交题的人很少（吐槽一下坑爹的美元换算）。用DFS水掉了，分别从dispenser到pennies来算一遍就OK。我本以为用四个for也能过，但是discuss上面有人说过不了，TLE。有时间我试试看。 代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;const int INF = 10000;int num[4], tmp[4], result[4];int total, money;bool success;void DFS(int dep, int remained)&#123; if (dep == 4) &#123; if (remained == 0) &#123; int sum = tmp[0] + tmp[1] + tmp[2] + tmp[3]; if (sum &lt; total) &#123; for (int i = 0; i &lt; 4; i++) result[i] = tmp[i]; total = sum; &#125; success = true; &#125; return; &#125; for (int j = 0; j &lt;= num[dep]; j++) &#123; tmp[dep] = j; if (dep == 0) DFS(dep + 1, remained - 25 * j); else if (dep == 1) DFS(dep + 1, remained - 10 * j); else if (dep == 2) DFS(dep + 1, remained - 5 * j); else if (dep == 3) DFS(dep + 1, remained - j); &#125;&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d%d%d%d&quot;, &amp;num[0], &amp;num[1], &amp;num[2], &amp;num[3], &amp;money) &amp;&amp; (num[0] || num[1] || num[2] || num[3] || money)) &#123; total = INF; success = false; DFS(0, money); if (success) printf(&quot;Dispense %d quarters, %d dimes, %d nickels, and %d pennies.\\n&quot;, result[0], result[1], result[2], result[3]); else printf(&quot;Cannot dispense the desired amount.\\n&quot;); &#125; return 0;&#125; 更新日志 2014年07月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2714 Random Walk","slug":"POJ-2714-Random-Walk","date":"2014-07-15T15:55:21.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/15/POJ-2714-Random-Walk/","link":"","permalink":"https://xuanwo.org/2014/07/15/POJ-2714-Random-Walk/","excerpt":"题目源地址： http://poj.org/problem?id=2714 理解一开始以为只是一道简单的求解最远距离的题目，但是敲完代码之后发现前两个样例过了，最后一个样例数据差距很大。然后仔细读题才发现，题目中给定的正负是不定的= =。一时间没有思路，以为需要使用DP的思想，然后去看了discuss，才明白用枚举的方法列出每一个向量，减少了很大的复杂度，使得问题能在1s之内解决。","text":"题目源地址： http://poj.org/problem?id=2714 理解一开始以为只是一道简单的求解最远距离的题目，但是敲完代码之后发现前两个样例过了，最后一个样例数据差距很大。然后仔细读题才发现，题目中给定的正负是不定的= =。一时间没有思路，以为需要使用DP的思想，然后去看了discuss，才明白用枚举的方法列出每一个向量，减少了很大的复杂度，使得问题能在1s之内解决。 新技能get位运算下面列出一张简表注意区分位运算~与逻辑运算!的区别。 代码#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;const int N = 105;double mx, my, cx, cy;struct V&#123; double x, y; bool operator &lt; (const V &amp;a) const &#123; double t = atan2(y, x); double at = atan2(a.y, a.x); return t &lt; at; &#125;&#125; v[N &lt;&lt; 1];int main(int argc, char const *argv[])&#123; int n, i, ci, end; double x, y; while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123; for (i = 0; i &lt; n; i++) &#123; scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y); v[i &lt;&lt; 1].x = x; v[i &lt;&lt; 1].y = y; v[i &lt;&lt; 1 | 1].x = -x; v[i &lt;&lt; 1 | 1].y = -y; &#125; sort(v, v + (n &lt;&lt; 1)); cx = cy = 0; for (i = 0; i &lt; n; i++) &#123; cx += v[i].x; cy += v[i].y; &#125; mx = cx; my = cy; for (i = 0, end = n &lt;&lt; 1; i &lt; end; i++) &#123; ci = (i + n) % end; cx += v[ci].x - v[i].x; cy += v[ci].y - v[i].y; if (cx * cx + cy * cy &gt; mx * mx + my * my) mx = cx, my = cy; &#125; printf(&quot;Maximum distance = %.3f meters.\\n&quot;, sqrt((double)mx * mx + my * my)); &#125; return 0;&#125; 更新日志 2014年07月15日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3048 Max Factor","slug":"POJ-3048-Max-Factor","date":"2014-07-14T17:21:24.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/14/POJ-3048-Max-Factor/","link":"","permalink":"https://xuanwo.org/2014/07/14/POJ-3048-Max-Factor/","excerpt":"题目源地址： http://poj.org/problem?id=3048 理解这不是我做过的最简单的题目，但一定是我做起来最逗比的题目。题意很明白，就是输出给定的数里面有最大值质因数的那个。题意中明确说明给定的数的范围是1到20000，然后我就开始机智了，20000的开方约为141，我只要打一个1到150以内所有素数的表，就OK啦～空间换时间，复杂度低得很。开开心心的敲完代码，结果WA了。看了一下discuss，针对一些特例微调了一下代码，结果还是WA。然后就进入坑爹模式，一坑就是一个下午。直到终于忍不住了，去问学长，学长看了一眼，说150到20000之间的质数呢？恍然大悟= =，没有考虑本身也是质数的情况，坑。","text":"题目源地址： http://poj.org/problem?id=3048 理解这不是我做过的最简单的题目，但一定是我做起来最逗比的题目。题意很明白，就是输出给定的数里面有最大值质因数的那个。题意中明确说明给定的数的范围是1到20000，然后我就开始机智了，20000的开方约为141，我只要打一个1到150以内所有素数的表，就OK啦～空间换时间，复杂度低得很。开开心心的敲完代码，结果WA了。看了一下discuss，针对一些特例微调了一下代码，结果还是WA。然后就进入坑爹模式，一坑就是一个下午。直到终于忍不住了，去问学长，学长看了一眼，说150到20000之间的质数呢？恍然大悟= =，没有考虑本身也是质数的情况，坑。 新技能get 卡题过久时，应当毫不犹豫地放弃或者寻求帮助。 不要执着于小数据特例而忘记大数据的测试， 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;int p[4000], pNum = 0;bool f[20001];void Prime()&#123; int i, j; for (i = 2; i &lt; 20001; i++) &#123; if (!f[i]) &#123; p[pNum++] = i; &#125; for (j = 0; j &lt; pNum &amp;&amp; i * p[j] &lt; 20001; j++) &#123; f[i * p[j]] = 1; if (!(i % p[j])) break; &#125; &#125;&#125;int main()&#123; int i, n, t, mmax = -1, pos; scanf(&quot;%d&quot;, &amp;n); Prime(); while (n--) &#123; scanf(&quot;%d&quot;, &amp;t); if (t == 1) &#123; if (mmax &lt; 1) &#123; mmax = 1; pos = 1; &#125; &#125; else &#123; for (i = pNum - 1; i &gt;= 0; i--) &#123; if (t &gt;= p[i] &amp;&amp; t % p[i] == 0) &#123; if (mmax &lt; p[i]) &#123; mmax = p[i]; pos = t; break; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, pos);&#125; 更新日志 2014年07月14日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1657 Distance on Chessboard","slug":"POJ-1657-Distance-on-Chessboard","date":"2014-07-13T16:42:02.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/13/POJ-1657-Distance-on-Chessboard/","link":"","permalink":"https://xuanwo.org/2014/07/13/POJ-1657-Distance-on-Chessboard/","excerpt":"题目源地址： http://poj.org/problem?id=1657 理解再一次脑洞大开了= =，居然还写了一个normalize函数用来区分是不是可行的走法，其实只要通过abs(x-y)%2!=0即可实现判断斜的方向上是否可以行走了。恩，这是程序设计实践导引上的例题，加上中文，没有什么好讲的。不过需要注意位置没有发生改变时的特殊情况。","text":"题目源地址： http://poj.org/problem?id=1657 理解再一次脑洞大开了= =，居然还写了一个normalize函数用来区分是不是可行的走法，其实只要通过abs(x-y)%2!=0即可实现判断斜的方向上是否可以行走了。恩，这是程序设计实践导引上的例题，加上中文，没有什么好讲的。不过需要注意位置没有发生改变时的特殊情况。 代码#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int t;char x1, x2;int y1, y2;int x, y;int main(int argc, char const *argv[])&#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; x1 &gt;&gt; y1; getchar(); cin &gt;&gt; x2 &gt;&gt; y2; x = abs(x1 - x2); y = abs(y1 - y2); if (x == 0 &amp;&amp; y == 0) cout &lt;&lt; &quot;0 0 0 0&quot; &lt;&lt; endl; else &#123; if (x &lt; y) cout &lt;&lt; y; else cout &lt;&lt; x; if (x == y || x == 0 || y == 0) cout &lt;&lt; &quot; 1&quot;; else cout &lt;&lt; &quot; 2&quot;; if (x == 0 || y == 0) cout &lt;&lt; &quot; 1&quot;; else cout &lt;&lt; &quot; 2&quot;; if (abs(x - y) % 2 != 0) cout &lt;&lt; &quot; Inf&quot; &lt;&lt; endl; else if (x == y) cout &lt;&lt; &quot; 1&quot; &lt;&lt; endl; else cout &lt;&lt; &quot; 2&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; 更新日志 2014年07月13日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1017 Packets","slug":"POJ-1017-Packets","date":"2014-07-13T16:42:02.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/13/POJ-1017-Packets/","link":"","permalink":"https://xuanwo.org/2014/07/13/POJ-1017-Packets/","excerpt":"题目源地址： http://poj.org/problem?id=1017 理解在COJ上有一道一模一样的题目，当时做的时候没有做出来，因为没有考虑好剩余空间的利用。66和11的情况最为简单，但是其余的情况就分情况考虑了，特别是对于33这种情况而言，因为一个箱子正好可以装4个33的产品。","text":"题目源地址： http://poj.org/problem?id=1017 理解在COJ上有一道一模一样的题目，当时做的时候没有做出来，因为没有考虑好剩余空间的利用。66和11的情况最为简单，但是其余的情况就分情况考虑了，特别是对于33这种情况而言，因为一个箱子正好可以装4个33的产品。 代码#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[])&#123; int n, a, b, c, d, e, f, x, y; int u[4] = &#123;0, 5, 3, 1&#125;; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &amp;&amp; (a != 0 || b != 0 || c != 0 || d != 0 || e != 0 || f != 0)) &#123; n = f + e + d + (c + 3) / 4; y = 5 * d + u[c % 4]; if (b &gt; y) n += (b - y + 8) / 9; x = 36 * n - 36 * f - 25 * e - 16 * d - 9 * c - 4 * b; if (a &gt; x) n += (a - x + 35) / 36; cout &lt;&lt; n &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月14日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3194 Equidivisions","slug":"POJ-3194-Equidivisions","date":"2014-07-12T23:12:37.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/12/POJ-3194-Equidivisions/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-3194-Equidivisions/","excerpt":"题目源地址： http://poj.org/problem?id=3194 理解本以为只要逐个判断每一个数是否有相邻即可，事实上，少考虑了一种情况。比如下面给出的这种： 2211111111111122 根据我原来的思路这种也是good，但其实并不是如此。当然，这个例子并不完备，但用于指出原来思路的漏洞已经够了。正确的思路应当是使用DFS来寻找是否存在独立的区块。","text":"题目源地址： http://poj.org/problem?id=3194 理解本以为只要逐个判断每一个数是否有相邻即可，事实上，少考虑了一种情况。比如下面给出的这种： 2211111111111122 根据我原来的思路这种也是good，但其实并不是如此。当然，这个例子并不完备，但用于指出原来思路的漏洞已经够了。正确的思路应当是使用DFS来寻找是否存在独立的区块。 代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int N, ans;int map[101][101];int visit[101][101];int step[4][2] = &#123; &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125; &#125;;int color[101];bool Check(int x, int y)&#123; if (x &gt;= N || x &lt; 0 || y &gt;= N || y &lt; 0) return false; return true;&#125;void DFS(int CurX, int CurY)&#123; ans++; visit[CurX][CurY] = 1; color[map[CurX][CurY]] = 1; for (int i = 0; i &lt; 4; i++) &#123; int x = CurX+step[i][0]; int y = CurY+step[i][1]; if (Check(x, y) == false || visit[x][y] == 1) continue; if (map[CurX][CurY] == map[x][y] || color[map[x][y]] == 0) &#123; DFS(x, y); &#125; &#125;&#125;int main()&#123; while (cin&gt;&gt;N &amp;&amp; N !=0) &#123; int index = 1; ans = 0; memset(map, 0, sizeof(map)); memset(visit, 0, sizeof(visit)); memset(color, 0, sizeof(color)); for (int i = 0; i &lt; N-1; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; int a, b; cin&gt;&gt;a&gt;&gt;b; map[a-1][b-1] = index; &#125; index++; &#125; DFS(0, 0); if (ans == N*N) cout&lt;&lt;&quot;good&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;wrong&quot;&lt;&lt;endl; &#125; return 0;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2386 Lake Counting","slug":"POJ-2386-Lake-Counting","date":"2014-07-12T21:34:56.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/12/POJ-2386-Lake-Counting/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-2386-Lake-Counting/","excerpt":"题目源地址： http://poj.org/problem?id=2386 理解当年学习DFS的AC掉的一道水题。DFS的经典模板，通过找出全部的相连池塘块来确定有几块池塘。","text":"题目源地址： http://poj.org/problem?id=2386 理解当年学习DFS的AC掉的一道水题。DFS的经典模板，通过找出全部的相连池塘块来确定有几块池塘。 代码原始版本#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int x, y, i, j, ans;char Map[100][100];int visited[100][100];int dfs(int i, int j)&#123; if (!visited[i][j] &amp;&amp; Map[i][j] == &apos;W&apos;) &#123; visited[i][j] = 1; if (j + 1 &lt; y &amp;&amp; Map[i][j + 1] == &apos;W&apos;) dfs(i, j + 1); if (j + 1 &lt; y &amp;&amp; i - 1 &gt;= 0 &amp;&amp; Map[i - 1][j + 1] == &apos;W&apos;) dfs(i - 1, j + 1); if (i - 1 &gt;= 0 &amp;&amp; Map[i - 1][j] == &apos;W&apos;) dfs(i - 1, j); if (i - 1 &gt;= 0 &amp;&amp; j - 1 &gt;= 0 &amp;&amp; Map[i - 1][j - 1] == &apos;W&apos;) dfs(i - 1, j - 1); if (j - 1 &gt;= 0 &amp;&amp; Map[i][j - 1] == &apos;W&apos;) dfs(i, j - 1); if (j - 1 &gt;= 0 &amp;&amp; i + 1 &lt; x &amp;&amp; Map[i + 1][j - 1] == &apos;W&apos;) dfs(i + 1, j - 1); if (i + 1 &lt; x &amp;&amp; Map[i + 1][j] == &apos;W&apos;) dfs(i + 1, j); if (i + 1 &lt; x &amp;&amp; j + 1 &lt; y &amp;&amp; Map[i + 1][j + 1] == &apos;W&apos;) dfs(i + 1, j + 1); &#125; return 0;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); ans = 0; memset(visited, 0, sizeof(visited)); for (i = 0; i &lt; x; i++) scanf(&quot;%s&quot;, Map[i]); for (i = 0; i &lt; x; i++) &#123; for (j = 0; j &lt; y; j++) &#123; if (Map[i][j] == &apos;W&apos; &amp;&amp; !visited[i][j]) &#123; dfs(i, j); ans ++ ; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 优化版本#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)#define MAXN 110using namespace std;int n, m;char field[MAXN][MAXN + 1];void dfs(int x, int y)&#123; field[x][y] = &apos;.&apos;; for (int dx = -1; dx &lt;= 1; dx++) &#123; for (int dy = -1; dy &lt;= 1; dy++) &#123; int nx = x + dx, ny = y + dy; if (0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; field[nx][ny] == &apos;W&apos;) dfs(nx, ny); &#125; &#125; return;&#125;int main(int argc, char const *argv[])&#123; int res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; field[i]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (field[i][j] == &apos;W&apos;) &#123; dfs(i, j); res++; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 更新日志 2014年07月12日 已AC。 2014年08月18日 更新了优化后的代码，提升可读性，并且运用了新的处理方法。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1321 棋盘问题","slug":"POJ-1321-Chess-Problem","date":"2014-07-12T21:30:59.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/12/POJ-1321-Chess-Problem/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-1321-Chess-Problem/","excerpt":"题目源地址： http://poj.org/problem?id=1321 理解感觉还是蛮简单的一道题目，主要是因为数据特别水，最大只有8*8的棋盘，用DFS按照行来搜索。主要的问题在于如何确保同列不存在重复的棋子。","text":"题目源地址： http://poj.org/problem?id=1321 理解感觉还是蛮简单的一道题目，主要是因为数据特别水，最大只有8*8的棋盘，用DFS按照行来搜索。主要的问题在于如何确保同列不存在重复的棋子。 代码#include &lt;iostream&gt;using namespace std;char pic[8][8];int col[8];int c;int n, k;void dfs(int begin, int num)&#123; for (int j = 0; j &lt; n; j++) &#123; if (pic[begin][j] == &apos;#&apos; &amp;&amp; col[j] == 0) &#123; if (num == 1) c++; else &#123; col[j] = 1; for (int h = begin + 1; h &lt; n - num + 2; h++) dfs(h, num - 1); col[j] = 0; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[])&#123; while ((cin &gt;&gt; n &gt;&gt; k) &amp;&amp; !(n == -1 &amp;&amp; k == -1)) &#123; c = 0; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; pic[i][j]; for (int i = 0; i &lt; n; i++) col[i] = 0; for (int i = 0; i &lt;= n - k; i++) &#123; dfs(i, k); &#125; cout &lt;&lt; c &lt;&lt; endl; &#125;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1190 生日蛋糕","slug":"POJ-1190-Birthay-Cake","date":"2014-07-12T20:48:21.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/12/POJ-1190-Birthay-Cake/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-1190-Birthay-Cake/","excerpt":"题目源地址： http://poj.org/problem?id=1190 理解这道题是学长推荐的DFS练习题，一开始没有想明白，为什么这道题是DFS。多次推导之后发现，这道题确实需要用到深度搜索。每次都先确定第一层蛋糕的体积数，然后减去得到剩余的蛋糕体积，如此循坏，最后要保证最后的体积和等于给定的N。因为半径是递增的，所以可以去掉很大一部分无效的搜索。","text":"题目源地址： http://poj.org/problem?id=1190 理解这道题是学长推荐的DFS练习题，一开始没有想明白，为什么这道题是DFS。多次推导之后发现，这道题确实需要用到深度搜索。每次都先确定第一层蛋糕的体积数，然后减去得到剩余的蛋糕体积，如此循坏，最后要保证最后的体积和等于给定的N。因为半径是递增的，所以可以去掉很大一部分无效的搜索。 代码#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int N, S, M;int end, min;int dfs(int v, int m, int lastr, int lasth)&#123; if (m == 0) &#123; if (v &gt; 0 || v &lt; 0) return 0; else &#123; end = 1; if (min &lt; S) S = min; return 0; &#125; &#125; int i, t = 0, j, k, temp; for (i = 1; i &lt;= m; i++) t += i * i * i; if (v &lt; t) return 0; t -= m * m * m; int maxr, maxh; maxr = (int)sqrt((v - t) * 1.0 / m) &lt; lastr ? (int)sqrt((v - t) * 1.0 / m) : lastr; for (i = maxr; i &gt;= m; i--) &#123; maxh = (v - t) / (i * i) &lt; lasth ? (v - t) / (i * i) : lasth; for (j = maxh; j &gt;= m; j--) &#123; temp = 0; for (k = 0; k &lt;= m - 1; k++) temp += (i - k) * (i - k) * (j - k); if (v &gt; temp) break; int tempv = v - i * i * j; if (m == M) &#123; if (i * i &lt; S) min = i * i; else &#123; tempv = v; continue; &#125; &#125; min += 2 * i * j; if (min &gt; S) &#123; tempv = v; min -= 2 * i * j; continue; &#125; dfs(tempv, m - 1, i - 1, j - 1); min -= 2 * i * j; &#125; &#125; return 0;&#125;int main(int argc, char const *argv[])&#123; while (scanf(&quot;%d%d&quot;, &amp;N, &amp;M) == 2) &#123; int t = 0; end = 0; S = 100000; dfs(N, M, 1000, 1000); if (!end) S = 0; printf(&quot;%d\\n&quot;, S); &#125; return 0;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2488 A Knight's Journey","slug":"POJ-2488-A-Knight's-Journey","date":"2014-07-12T19:59:14.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/12/POJ-2488-A-Knight's-Journey/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-2488-A-Knight's-Journey/","excerpt":"题目源地址： http://poj.org/problem?id=2488 理解一开始没看懂，看了几遍之后才明白。是给定一个p*q的棋盘，要求计算出是否存在可能性使得骑士走遍整个棋盘，并要求按照字典序排列。这个字典序真的是要我的命，直接导致挂了很多次，还傻傻地去群里面问这道题是不是Special Judge= =。","text":"题目源地址： http://poj.org/problem?id=2488 理解一开始没看懂，看了几遍之后才明白。是给定一个p*q的棋盘，要求计算出是否存在可能性使得骑士走遍整个棋盘，并要求按照字典序排列。这个字典序真的是要我的命，直接导致挂了很多次，还傻傻地去群里面问这道题是不是Special Judge= =。 新技能get字典序 lexicographically 代码#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef class&#123; public: int row; char col;&#125;location;int p,q;bool chess[&apos;Z&apos;+1][27];int x,y;void path(int i,int j,int num)&#123; switch(num) &#123; case 1: &#123;x=i-1; y=j-2; break;&#125; case 2: &#123;x=i+1; y=j-2; break;&#125; case 3: &#123;x=i-2; y=j-1; break;&#125; case 4: &#123;x=i+2; y=j-1; break;&#125; case 5: &#123;x=i-2; y=j+1; break;&#125; case 6: &#123;x=i+2; y=j+1; break;&#125; case 7: &#123;x=i-1; y=j+2; break;&#125; case 8: &#123;x=i+1; y=j+2; break;&#125; &#125; return;&#125;bool DFS(location* way,int i,int j,int step)&#123; chess[i][j]=true; way[step].row=i; way[step].col=j; if(step==way[0].row) return true; for(int k=1;k&lt;=8;k++) &#123; path(i,j,k); int ii=x,jj=y; if(!chess[ii][jj] &amp;&amp; ii&gt;=1 &amp;&amp; ii&lt;=p &amp;&amp; jj&gt;=&apos;A&apos; &amp;&amp; jj&lt;=&apos;A&apos;+q-1) if(DFS(way,ii,jj,step+1)) return true; &#125; chess[i][j]=false; return false;&#125;int main(int argc, char const *argv[])&#123; int test; cin&gt;&gt;test; int t=1; while(t&lt;=test) &#123; memset(chess,false,sizeof(chess)); cin&gt;&gt;p&gt;&gt;q; if(p==1 &amp;&amp; q==1) &#123; cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;t++&lt;&lt;&apos;:&apos;&lt;&lt;endl; cout&lt;&lt;&quot;A1&quot;&lt;&lt;endl&lt;&lt;endl; continue; &#125; if(p*q&gt;26 || p&gt;=9 || q&gt;=9 || p&lt;=2 || q&lt;=2) &#123; cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;t++&lt;&lt;&apos;:&apos;&lt;&lt;endl; cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl&lt;&lt;endl; continue; &#125; location* way=new location[p*q+1]; way[0].row=p*q; bool flag=false; for(int j=&apos;A&apos;;j&lt;=&apos;A&apos;+q-1;j++) &#123; for(int i=1;i&lt;=p;i++) if(DFS(way,i,j,1)) &#123; cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;t++&lt;&lt;&apos;:&apos;&lt;&lt;endl; for(int k=1;k&lt;=way[0].row;k++) cout&lt;&lt;way[k].col&lt;&lt;way[k].row; cout&lt;&lt;endl&lt;&lt;endl; flag=true; break; &#125; if(flag) break; &#125; if(!flag) &#123; cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;t++&lt;&lt;&apos;:&apos;&lt;&lt;endl; cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl&lt;&lt;endl; &#125; &#125; return 0;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1753 Flip Game","slug":"POJ-1753-Flip-Game","date":"2014-07-12T13:48:16.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/12/POJ-1753-Flip-Game/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-1753-Flip-Game/","excerpt":"题目源地址： http://poj.org/problem?id=1753 理解我一开始的思路是错误的，企图通过正面的方法来找出从当前情况达到全白和全黑的方法，多次尝试之后，发现很难找到一条通用的方法，只能找出几个比较简单的特例。后来才明白过来，应当从全黑或者全白的情况出发，再来判断给定的图是不是其中的一个子集。因为是一个4X4的格子，不难看出，总共的情况只有2^16种。只要一一枚举即可。最后的步数就是这颗树的深度，使用DFS即可实现。","text":"题目源地址： http://poj.org/problem?id=1753 理解我一开始的思路是错误的，企图通过正面的方法来找出从当前情况达到全白和全黑的方法，多次尝试之后，发现很难找到一条通用的方法，只能找出几个比较简单的特例。后来才明白过来，应当从全黑或者全白的情况出发，再来判断给定的图是不是其中的一个子集。因为是一个4X4的格子，不难看出，总共的情况只有2^16种。只要一一枚举即可。最后的步数就是这颗树的深度，使用DFS即可实现。 新技能get深度优先搜索DFS对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 代码#include&lt;iostream&gt;using namespace std;bool chess[6][6]=&#123;false&#125;;bool flag;int step;int r[]=&#123;-1,1,0,0,0&#125;;int c[]=&#123;0,0,-1,1,0&#125;;bool judge_all(void)&#123; int i,j; for(i=1;i&lt;5;i++) for(j=1;j&lt;5;j++) if(chess[i][j]!=chess[1][1]) return false; return true;&#125;void flip(int row,int col)&#123; int i; for(i=0;i&lt;5;i++) chess[row+r[i]][col+c[i]]=!chess[row+r[i]][col+c[i]]; return;&#125;void dfs(int row,int col,int deep)&#123; if(deep==step) &#123; flag=judge_all(); return; &#125; if(flag||row==5)return; flip(row,col); if(col&lt;4) dfs(row,col+1,deep+1); else dfs(row+1,1,deep+1); flip(row,col); if(col&lt;4) dfs(row,col+1,deep); else dfs(row+1,1,deep); return;&#125;int main(void)&#123; char temp; int i,j; for(i=1;i&lt;5;i++) for(j=1;j&lt;5;j++) &#123; cin&gt;&gt;temp; if(temp==&apos;b&apos;) chess[i][j]=true; &#125; for(step=0;step&lt;=16;step++) &#123; dfs(1,1,0); if(flag)break; &#125; if(flag) cout&lt;&lt;step&lt;&lt;endl; else cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; return 0;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1018 Communication System","slug":"POJ-1018-Communication-System","date":"2014-07-12T13:06:29.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/12/POJ-1018-Communication-System/","link":"","permalink":"https://xuanwo.org/2014/07/12/POJ-1018-Communication-System/","excerpt":"题目源地址： http://poj.org/problem?id=1018 理解题意比较清晰，就是找出最大的B/sum(P)，要求网络设备的性价比最高。采用枚举的方法，把所有情况都列出来，然后有些明显不需要考虑的情况，可以直接舍去。","text":"题目源地址： http://poj.org/problem?id=1018 理解题意比较清晰，就是找出最大的B/sum(P)，要求网络设备的性价比最高。采用枚举的方法，把所有情况都列出来，然后有些明显不需要考虑的情况，可以直接舍去。 新技能getSublime-Text在C++模式下输入main+回车可以直接完成符合C++11的代码，点个赞 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;using namespace std;class info&#123;public: int B; double P; int id;&#125;;int cmp(const void* a,const void* b)&#123; info* x=(info*)a; info* y=(info*)b; if((x-&gt;B)==(y-&gt;B)) &#123; if((x-&gt;P)==(y-&gt;P)) return (x-&gt;id)-(y-&gt;id); return (x-&gt;P)-(y-&gt;P); &#125; return (x-&gt;B)-(y-&gt;B);&#125;double max(double a,double b)&#123; return a&gt;b?a:b;&#125;int main(int argc, char const *argv[], int i, int j)&#123; int test; cin&gt;&gt;test; for(int t=1;t&lt;=test;t++) &#123; int n; int m=0; cin&gt;&gt;n; int* MaxB=new int[n+1]; info* dev=new info[100*100+1]; int pd=0; for(i=1;i&lt;=n;i++) &#123; int mi; cin&gt;&gt;mi; m+=mi; MaxB[i]=-1; for(j=1;j&lt;=mi;j++) &#123; pd++; cin&gt;&gt;dev[pd].B&gt;&gt;dev[pd].P; dev[pd].id=i; MaxB[i]=max(MaxB[i],dev[pd].B); &#125; &#125; qsort(dev,m+1,sizeof(info),cmp); bool flag=false; double ans=0; for(i=1;i&lt;=m-(n-1);i++) &#123; bool* vist=new bool[n+1]; memset(vist,false,sizeof(bool)*(n+1)); vist[ dev[i].id ]=true; double price=dev[i].P; int count=1; for(j=i+1;j&lt;=m;j++) &#123; if(vist[ dev[j].id ]) continue; if(dev[i].B &gt; MaxB[ dev[j].id ]) &#123; flag=true; break; &#125; vist[ dev[j].id ]=true; price+=dev[j].P; count++; &#125; if(flag || count&lt;n) break; ans=max(ans,(dev[i].B/price)); &#125; cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;ans&lt;&lt;endl; delete MaxB; delete dev; &#125; return 0;&#125; 更新日志 2014年07月12日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2739 Sum of Consecutive Prime Numbers","slug":"POJ-2739-Sum-of-Consecutive-Prime-Numbers","date":"2014-07-11T19:49:38.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/11/POJ-2739-Sum-of-Consecutive-Prime-Numbers/","link":"","permalink":"https://xuanwo.org/2014/07/11/POJ-2739-Sum-of-Consecutive-Prime-Numbers/","excerpt":"题目源地址： http://poj.org/problem?id=2739 理解跑偏了= =。An output line includes the number of representations for the input integer as the sum of one or more consecutive prime numbers.居然理解成输出用于表示的质数的个数了，卡了很久。","text":"题目源地址： http://poj.org/problem?id=2739 理解跑偏了= =。An output line includes the number of representations for the input integer as the sum of one or more consecutive prime numbers.居然理解成输出用于表示的质数的个数了，卡了很久。 代码#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;bool flag[10002];int prime[10002], sum[1402];int tmp;int main()&#123; int i, j, k ; memset(flag, -1, sizeof(flag)); memset(sum, 0, sizeof(sum)); memset(prime, 0, sizeof(prime)); tmp = 0; for ( i = 2; i &lt;= 10000; i++ ) &#123; if ( flag[i] ) &#123; prime[++tmp] = i; for ( j = 2; i * j &lt;= 10000; j++ ) flag[i * j] = 0; &#125; &#125; for ( i = 1; i &lt;= tmp; i++ ) sum[i] = sum[i - 1] + prime[i]; int n, ans; while ( cin &gt;&gt; n &amp;&amp; n ) &#123; ans = i = 0; while ( prime[i] &lt; n &amp;&amp; i &lt; tmp ) i++; if ( prime[i] == n ) ans++; for ( j = i - 1; j &gt;= 1; j-- ) &#123; for ( k = 0; k &lt; j; k++ ) if ( sum[j] - sum[k] == n ) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 更新日志 2014年07月11日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 2159 Ancient Cipher","slug":"POJ-2159-Ancient-Cipher","date":"2014-07-11T13:30:04.000Z","updated":"2016-08-03T04:19:54.406Z","comments":true,"path":"2014/07/11/POJ-2159-Ancient-Cipher/","link":"","permalink":"https://xuanwo.org/2014/07/11/POJ-2159-Ancient-Cipher/","excerpt":"题目源地址： http://poj.org/problem?id=2159 理解一开始的理解是按照题目的意思，先进行一次置换加密再进行一次排列加密。置换只要按照规律一个一个替换就OK，排列加密则用到了next_permutation函数。两重for循环，模拟出去全部的加密方法。Coding出来之后提交，WA。然后才开始审视另外的可能性：谁说置换就一定要按照规律来？事实上，的确如此，按照题意，只需要明文和密文字符形成唯一映射就OK。如果还是按照原来的思路，这道水题还真的不水。其实，在加密过程中，有一样东西是不变的，就是各个字符（对应）出现的频率。这样想的话，就简单了，只要统计出每个字符出现的概率，sort排序后，判断两个数组是否完全一致就好～","text":"题目源地址： http://poj.org/problem?id=2159 理解一开始的理解是按照题目的意思，先进行一次置换加密再进行一次排列加密。置换只要按照规律一个一个替换就OK，排列加密则用到了next_permutation函数。两重for循环，模拟出去全部的加密方法。Coding出来之后提交，WA。然后才开始审视另外的可能性：谁说置换就一定要按照规律来？事实上，的确如此，按照题意，只需要明文和密文字符形成唯一映射就OK。如果还是按照原来的思路，这道水题还真的不水。其实，在加密过程中，有一样东西是不变的，就是各个字符（对应）出现的频率。这样想的话，就简单了，只要统计出每个字符出现的概率，sort排序后，判断两个数组是否完全一致就好～ 代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int i; int cipher[26], clear[26]; memset(cipher, 0, sizeof(cipher)); memset(clear, 0, sizeof(clear)); string in, out; cin &gt;&gt; in; for (i = 0; i &lt; in.length(); i++) &#123; cipher[in[i] - &apos;A&apos;]++; &#125; cin &gt;&gt; out; for (i = 0; i &lt; out.length(); i++) &#123; clear[out[i] - &apos;A&apos;]++; &#125; sort(cipher, cipher + 26); sort(clear, clear + 26); for (i = 0; i &lt; 26; i++) if (cipher[i] != clear[i]) &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0; &#125; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; return 0;&#125; 更新日志 2014年07月11日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 3299 Humidex","slug":"POJ-3299-Humidex","date":"2014-07-10T23:14:26.000Z","updated":"2016-08-03T04:19:54.410Z","comments":true,"path":"2014/07/10/POJ-3299-Humidex/","link":"","permalink":"https://xuanwo.org/2014/07/10/POJ-3299-Humidex/","excerpt":"题目源地址： http://poj.org/problem?id=3299 理解我的理解有误。主要是看input里面都是给定T，D求H的情况，便以为这道题就是用一下公式。没想到这道题还有其他的两种情况。说明不管在怎样的条件下，看题都是至关重要的一步。还有就是在输入输出上，%s和%c的区别，值得注意。","text":"题目源地址： http://poj.org/problem?id=3299 理解我的理解有误。主要是看input里面都是给定T，D求H的情况，便以为这道题就是用一下公式。没想到这道题还有其他的两种情况。说明不管在怎样的条件下，看题都是至关重要的一步。还有就是在输入输出上，%s和%c的区别，值得注意。 代码#include&lt;stdio.h&gt;#include&lt;math.h&gt;float getHumidex(float temperature, float dewpoint)&#123; float humidex, h, e; e = 6.11 * exp(5417.7530 * ((1 / 273.16) - (1 / (dewpoint + 273.16)))); h = 0.5555 * (e - 10.0); humidex = temperature + h; return humidex;&#125;float getTemperature(float dewpoint, float humidex)&#123; float temperature, h, e; e = 6.11 * exp(5417.7530 * ((1 / 273.16) - (1 / (dewpoint + 273.16)))); h = 0.5555 * (e - 10.0); temperature = humidex - h; return temperature;&#125;float getDewpoint(float temperature, float humidex)&#123; float dewpoint, e, h; h = humidex - temperature; e = h / 0.5555 + 10.0; dewpoint = 1 / ((1 / 273.16) - log(e / 6.11) / 5417.7530) - 273.16; return dewpoint;&#125;void calculate(float *temperature, float *dewpoint, float *humidex, int digit)&#123; switch (digit) &#123; case 3: *temperature = getTemperature(*dewpoint, *humidex); break; case 5: *dewpoint = getDewpoint(*temperature, *humidex); break; case 6: *humidex = getHumidex(*temperature, *dewpoint); break; &#125;&#125;int main()&#123; float temperature, dewpoint, humidex, temp; char ch[2]; int count = 0, digit = 0; scanf(&quot;%s&quot;, ch); while (ch[0] != &apos;E&apos;) &#123; scanf(&quot;%f&quot;, &amp;temp); count = (count + 1) % 2; if (ch[0] == &apos;T&apos;) &#123; temperature = temp; digit += 4; &#125; else if (ch[0] == &apos;D&apos;) &#123; dewpoint = temp; digit += 2; &#125; else if (ch[0] == &apos;H&apos;) &#123; humidex = temp; digit += 1; &#125; if (count == 0) &#123; calculate(&amp;temperature, &amp;dewpoint, &amp;humidex, digit); digit = 0; printf(&quot;T %.1f D %.1f H %.1f\\n&quot;, temperature, dewpoint, humidex); &#125; scanf(&quot;%s&quot;, ch); &#125; return 0;&#125; 更新日志 2014年07月10日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1207 The 3n + 1 problem","slug":"POJ-1207-The-3n+1-problem","date":"2014-07-10T16:55:39.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/10/POJ-1207-The-3n+1-problem/","link":"","permalink":"https://xuanwo.org/2014/07/10/POJ-1207-The-3n+1-problem/","excerpt":"题目源地址： http://poj.org/problem?id=1207 理解额，题意很清楚。就是一道关于3n+1的规律题，要求找出给定的i和j之间最长的循环数列。但是我坑了很久，因为错误的使用了A?B:C这样的三元运算符，被学姐学长痛批一顿之后，果断修改了。AC之余，提醒自己一下，良好的代码规范的重要性。","text":"题目源地址： http://poj.org/problem?id=1207 理解额，题意很清楚。就是一道关于3n+1的规律题，要求找出给定的i和j之间最长的循环数列。但是我坑了很久，因为错误的使用了A?B:C这样的三元运算符，被学姐学长痛批一顿之后，果断修改了。AC之余，提醒自己一下，良好的代码规范的重要性。 新技能getGoogle C++开源项目风格指南 代码#include &lt;stdio.h&gt;int main()&#123; int a, b, n, longest, tmp; while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) != EOF) &#123; printf(&quot;%d %d &quot;, a, b); if (a &gt; b) &#123; tmp = a; a = b; b = tmp; &#125; longest = n = 1; for (int i = a; i &lt;= b; i++) &#123; tmp = 1; n = i; while (n-1) &#123; n % 2 == 0 ? (n = n / 2) : (n = 3 * n + 1); tmp++; &#125; if (tmp &gt; longest) &#123; longest = tmp; &#125; &#125; printf(&quot;%d\\n&quot;, longest); &#125; return 0;&#125; 更新日志2014年07月10日 已AC，添加谷歌代码风格指南。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1013 Counterfeit Dollar","slug":"POJ-1013-Counterfeit-Dollar","date":"2014-07-10T14:22:44.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/10/POJ-1013-Counterfeit-Dollar/","link":"","permalink":"https://xuanwo.org/2014/07/10/POJ-1013-Counterfeit-Dollar/","excerpt":"题目源地址： http://poj.org/problem?id=1013 理解总共有12枚银币，里面有一枚是假货。要求通过三次称量，找出那枚假币，并说出是重了还是轻了。题目中明确指出，三次称量必定能找出那枚假货，使得问题简化了很多。一开始的想法是完全模拟出来，但写到代码的时候感觉过于蛋疼，然后想能不能用一些由计算机来推导的方法。在具体的实现中，发现我很难把问题抽象成计算机可以处理的问题。在一份解题报告的启发下，想到了使用一个数值来度量每个银币可能为假币的可能性的方法。","text":"题目源地址： http://poj.org/problem?id=1013 理解总共有12枚银币，里面有一枚是假货。要求通过三次称量，找出那枚假币，并说出是重了还是轻了。题目中明确指出，三次称量必定能找出那枚假货，使得问题简化了很多。一开始的想法是完全模拟出来，但写到代码的时候感觉过于蛋疼，然后想能不能用一些由计算机来推导的方法。在具体的实现中，发现我很难把问题抽象成计算机可以处理的问题。在一份解题报告的启发下，想到了使用一个数值来度量每个银币可能为假币的可能性的方法。 代码#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; char left[3][6],right[3][6],status[3][6]; int time[&apos;L&apos;+1]=&#123;0&#125;; bool zero[&apos;L&apos;+1]=&#123;false&#125;; for(int k=0;k&lt;3;k++) cin&gt;&gt;left[k]&gt;&gt;right[k]&gt;&gt;status[k]; for(int i=0;i&lt;3;i++) &#123; switch(status[i][0]) &#123; case &apos;u&apos;: &#123; for(int j=0;left[i][j];j++) &#123; time[ left[i][j] ]++; time[ right[i][j] ]--; &#125; break; &#125; case &apos;d&apos;: &#123; for(int j=0;left[i][j];j++) &#123; time[ left[i][j] ]--; time[ right[i][j] ]++; &#125; break; &#125; case &apos;e&apos;: &#123; for(int j=0;left[i][j];j++) &#123; zero[ left[i][j] ]=true; zero[ right[i][j] ]=true; &#125; break; &#125; &#125; &#125; int max=-1; char alpha; for(int j=&apos;A&apos;;j&lt;=&apos;L&apos;;j++) &#123; if(zero[j]) continue; if(max&lt;=abs(time[j])) &#123; max=abs(time[j]); alpha=j; &#125; &#125; cout&lt;&lt;alpha&lt;&lt;&quot; is the counterfeit coin and it is &quot;; if(time[alpha]&gt;0) cout&lt;&lt;&quot;heavy.&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;light.&quot;&lt;&lt;endl; &#125; return 0;&#125; 更新日志2014年07月10日 已AC(C++下通过，G++下WA)，准备择日修复。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1008 Maya Calendar","slug":"POJ-1008-Maya-Calendar","date":"2014-07-07T23:04:08.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/07/POJ-1008-Maya-Calendar/","link":"","permalink":"https://xuanwo.org/2014/07/07/POJ-1008-Maya-Calendar/","excerpt":"题目源地址： http://poj.org/problem?id=1008 理解两种纪年法的转换，另外设一个days的变量保存总天数，然后以它为基准进行变换，没有什么难度。但是在具体的方法上，还是有些优化的余地。比如我不用写那么多长长的if判断语句，使用一个string数组就可以轻松搞定了，这是我不机智的地方。此外，应当注意到，两种纪年法的第一天分别是0和1，要小心。","text":"题目源地址： http://poj.org/problem?id=1008 理解两种纪年法的转换，另外设一个days的变量保存总天数，然后以它为基准进行变换，没有什么难度。但是在具体的方法上，还是有些优化的余地。比如我不用写那么多长长的if判断语句，使用一个string数组就可以轻松搞定了，这是我不机智的地方。此外，应当注意到，两种纪年法的第一天分别是0和1，要小心。 新技能getstring类C++就是比C高大上，再也不需要char数组了～介绍一下string类常用的一些方法和变量： length find copy swap compare 代码#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;using namespace std;int transHabb(string month)&#123; if (!month.compare(&quot;pop&quot;)) return 1; else if (!month.compare(&quot;no&quot;)) return 2; else if (!month.compare(&quot;zip&quot;)) return 3; else if (!month.compare(&quot;zotz&quot;)) return 4; else if (!month.compare(&quot;tzec&quot;)) return 5; else if (!month.compare(&quot;xul&quot;)) return 6; else if (!month.compare(&quot;yoxkin&quot;)) return 7; else if (!month.compare(&quot;mol&quot;)) return 8; else if (!month.compare(&quot;chen&quot;)) return 9; else if (!month.compare(&quot;yax&quot;)) return 10; else if (!month.compare(&quot;zac&quot;)) return 11; else if (!month.compare(&quot;ceh&quot;)) return 12; else if (!month.compare(&quot;mac&quot;)) return 13; else if (!month.compare(&quot;kankin&quot;)) return 14; else if (!month.compare(&quot;muan&quot;)) return 15; else if (!month.compare(&quot;pax&quot;)) return 16; else if (!month.compare(&quot;koyab&quot;)) return 17; else if (!month.compare(&quot;cumhu&quot;)) return 18; else return 19;&#125;string transTzolkin(int day)&#123; if (day == 1) return &quot;imix&quot;; else if (day == 2) return &quot;ik&quot;; else if (day == 3) return &quot;akbal&quot;; else if (day == 4) return &quot;kan&quot;; else if (day == 5) return &quot;chicchan&quot;; else if (day == 6) return &quot;cimi&quot;; else if (day == 7) return &quot;manik&quot;; else if (day == 8) return &quot;lamat&quot;; else if (day == 9) return &quot;muluk&quot;; else if (day == 10) return &quot;ok&quot;; else if (day == 11) return &quot;chuen&quot;; else if (day == 12) return &quot;eb&quot;; else if (day == 13) return &quot;ben&quot;; else if (day == 14) return &quot;ix&quot;; else if (day == 15) return &quot;mem&quot;; else if (day == 16) return &quot;cib&quot;; else if (day == 17) return &quot;caban&quot;; else if (day == 18) return &quot;eznab&quot;; else if (day == 19) return &quot;canac&quot;; else return &quot;ahau&quot;;&#125;int Habb(int day, string month, int year)&#123; return day + (transHabb(month) - 1) * 20 + year * 365;&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; while (n--) &#123; int Tzolkinmonth = 0, Tzolkinyear = 0, Habbday = 0, Habbyear = 0, days = 0; string Tzolkinday = &quot;\\0&quot;, Habbmonth = &quot;\\0&quot;; scanf(&quot;%d. &quot;, &amp;Habbday); cin &gt;&gt; Habbmonth; scanf(&quot; %d&quot;, &amp;Habbyear); days = Habb(Habbday, Habbmonth, Habbyear); Tzolkinyear = days / 260; Tzolkinmonth = days % 260 % 13+1; Tzolkinday = transTzolkin(days % 260 % 20+1); cout &lt;&lt; Tzolkinmonth &lt;&lt; &quot; &quot; &lt;&lt; Tzolkinday &lt;&lt; &quot; &quot; &lt;&lt; Tzolkinyear &lt;&lt; endl; &#125;&#125; 更新日志 2014年07月07日 已AC，文章BUG修正。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1007 DNA Sorting","slug":"POJ-1007-DNA-Sorting","date":"2014-07-07T14:09:22.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/07/POJ-1007-DNA-Sorting/","link":"","permalink":"https://xuanwo.org/2014/07/07/POJ-1007-DNA-Sorting/","excerpt":"题目源地址： http://poj.org/problem?id=1007 理解我再一次把问题想的太复杂了，其实就是一个计算逆序数并且排序的一个过程。","text":"题目源地址： http://poj.org/problem?id=1007 理解我再一次把问题想的太复杂了，其实就是一个计算逆序数并且排序的一个过程。 新技能get快速排序void qsort (void* base, size_t num, size_t size, int (*compar)(const void*,const void*)); 代码#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;using namespace std;class DNA&#123;public: string seqDNA; int num;&#125;;int compare(const void *p1, const void *p2)&#123; return (((DNA *)p1)-&gt;num - ((DNA *)p2)-&gt;num);&#125;int main()&#123; DNA *dna; int n, m, num, count(0); string listDNA; cin &gt;&gt; m &gt;&gt; n; dna = new DNA[n]; while (count &lt; n) &#123; cin &gt;&gt; listDNA; num = 0; for (int i = 0; i &lt; m - 1; ++i) &#123; for (int j = i + 1; j &lt; m; ++j) &#123; if (listDNA.at(i) &gt; listDNA.at(j)) ++num; &#125; &#125; dna[count].num = num; dna[count++].seqDNA = listDNA; &#125; qsort(dna, n, sizeof(DNA), compare); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; dna[i].seqDNA &lt;&lt; endl; return 0;&#125; 更新日志 2014年07月07日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"使用Hexo构建项目Wiki","slug":"use-hexo-to-bulid-project-wiki","date":"2014-07-07T00:38:09.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/07/07/use-hexo-to-bulid-project-wiki/","link":"","permalink":"https://xuanwo.org/2014/07/07/use-hexo-to-bulid-project-wiki/","excerpt":"前言七七事件前一天，我有幸加入了本校OJ2.0项目组。非常高兴能够为我们学校自己的OJ开源项目做出一份贡献，虽然只是一份整理Wiki的小活儿，但是这是我第一次真正的参与一个源项目。经过谨慎考虑之后，我决定项目的Wiki使用Github Pages来构建。","text":"前言七七事件前一天，我有幸加入了本校OJ2.0项目组。非常高兴能够为我们学校自己的OJ开源项目做出一份贡献，虽然只是一份整理Wiki的小活儿，但是这是我第一次真正的参与一个源项目。经过谨慎考虑之后，我决定项目的Wiki使用Github Pages来构建。 为什么是Github Pages？ 免费，无限流量 享受git的版本管理功能，不用担心文章遗失。 你只要用自己喜欢的编辑器写文章就可以了，其他事情一概不用操心，都由github处理。以上引用自阮一峰先生的相关博文 同Github Wiki一样支持多人协作，但是更加便于查阅，特别是在涉及主题繁杂的时候。 比Github Wiki拥有更大的控制权限，避免Wiki被错误操作。 前期准备Hexo的安装与配置Windows环境下32位地址:http://nodejs.org/dist/v0.10.29/node-v0.10.29-x86.msi64位地址:http://nodejs.org/dist/v0.10.29/x64/node-v0.10.29-x64.msi Mac OS环境下安装包地址:http://nodejs.org/dist/v0.10.29/node-v0.10.29.pkg Linux环境下建议使用nvm来管理nodejs环境 打开终端，输入wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 重启终端之后,输入nvm ls，则会列出所有的可用版本 输入nvm install 0.10.29（此处以最新版为例） 下面配置nodejs的环境，分别输入nvm use 0.10.29以及nvm alias default 0.10.29 Git的安装与配置Windows环境下不妨使用Github For Windows， 通过添加命令行参数启动环境，无须配置PATH，完全绿色化。（TODO：有待补充） Mac OS环境下同理，使用Github For Mac即可。 Linux环境下Ubuntu, Debian：sudo apt-get install git-coreFedora, Red Hat, CentOS：sudo yum install git-core 开启SSH，避免重复输入帐号密码可以参考此处。 Wiki配置感谢wzpan开源的主题，其实还是我主动索要的- -，幸好他非常热情地提供了帮助，在此表示衷心的感谢。致谢完毕，下面转入配置的细节。 在github上建立一个新的仓库，名为yourname.github.io 事先建立好准备存放wiki的文件夹，然后在当前目录下打开终端（或者不停地cd进入），然后输入hexo init，初始化。 然后输入npm install，自动下载相关的依赖包，此时一个最基本的框架已经构建完毕了。 然后输入git clone https://github.com/wzpan/hexo-theme-wixo.git themes/wixo，下载wiki用的主题。 然后修改_config.yml中的theme条目为wixo，注意theme后有一个空格。&gt;补充一下关于deploy的设置同样是在_config.yml文件夹中，修改deploy的部分为 deploy: type: github repo: repository url //使用之前创建的那个库，建议使用SSH branch: branch //Hexo会自动识别个人wiki还是项目wiki 6. 进入source文件夹，打开_post文件夹，新建一个md文档，在文档的开头加入 ---title: your title //这将会是wiki文档的标题date: 2014-03-16 10:17:16 //构建时间，wiki中用不到categories: Docs //这将会是本文档所属的类别toc: true //默认开启，生成table of contents--- //不可省略，敲回车后，下面的内容就自由发挥了～ 7. 保存文档后，返回wiki所在文件夹， 输入hexo d -g，此时wiki已经自动生成并上传完毕了。 协作注意事项项目创建者按照上述设置，wiki默认保存在yourname.github.io的master分支下。建议另外开启一个source分支，用来将整个wiki文件夹上传，方便多地编辑以及同步协作。&gt;一开始可能会发现wiki文件夹不能使用git管理，这是因为主题wixo是使用git管理的。所以在上传wiki文件夹之前，要删除位于wixo文件夹下的.git文件夹。 项目参与者让项目创建者在项目的settings中的Collaborators栏目中输入自己的用户名，即可获得对这个项目的控制权。环境配置完毕后，forksource分支，即可开始编辑工作。根据.gitignore文件的不同，可能还需要进行npm install以解决依赖问题。 更新日志 2014年07月07日 完成前言和为什么板块 2014年07月24日 完成前期准备和Wiki配置以及注意事项版块，接下来完成免PATH配置的详细步骤以及SSH的配置。此外发现步骤有些混杂不清，下一个版本中将进行修正。 2015年04月01日 添加了SSH配置。","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"Windows","slug":"Windows","permalink":"https://xuanwo.org/tags/Windows/"},{"name":"Wiki","slug":"Wiki","permalink":"https://xuanwo.org/tags/Wiki/"}]},{"title":"POJ 1006 Biorhythms","slug":"POJ-1006-Biorhythms","date":"2014-07-06T19:30:41.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/06/POJ-1006-Biorhythms/","link":"","permalink":"https://xuanwo.org/2014/07/06/POJ-1006-Biorhythms/","excerpt":"题目源地址： http://poj.org/problem?id=1006 理解基本上就是孙子兵法，求那个最小的公倍数。记得华罗庚先生也写过同余式的相关著作。恩，找出规律之后，轻松水掉。","text":"题目源地址： http://poj.org/problem?id=1006 理解基本上就是孙子兵法，求那个最小的公倍数。记得华罗庚先生也写过同余式的相关著作。恩，找出规律之后，轻松水掉。 新技能get中国剩余定理（离开校网之后再也连不上wiki了，只好引用百度百科的资料） 在中国古代劳动人民中，长期流传着“隔墙算”、“剪管术”、“秦王暗点兵”等数学游戏。有一首“孙子歌”，甚至远渡重洋，输入日本：“三人同行七十稀，五树梅花廿一枝，七子团圆正半月，除百零五便得知。”这些饶有趣味的数学游戏，以各种不同形式，介绍世界闻名的“孙子问题”的解法，通俗地反映了中国古代数学一项卓越的成就。“孙子问题”在现代数论中是一个一次同余问题，它最早出现在中国公元四世纪的数学著作《孙子算经》中。《孙子算经》卷下“物不知数”题说：有物不知其数，三个一数余二，五个一数余三，七个一数又余二，问该物总数几何？显然，这相当于求不定方程组N=3x+2,N=5y+3,N=7z+2的正整数解N，或用现代数论符号表示，等价干解下列的一次同余组。《孙子算经》所给答案是N=23。由于孙子问题数据比较简单，这个答数通过试算也可以得到。但是《孙子算经》并不是这样做的。“物不知数”题的术文指出解题的方法多三三数之，取数七十，与余数二相乘；五五数之，取数二十一，与余数三相乘；七七数之，取数十五，与余数二相乘。将诸乘积相加，然后减去一百零五的倍数。列成算式就是：N=70×2+21×3+15×2－2×105。这里105是模数3、5、7的最小公倍数，容易看出，《孙子算经》给出的是符合条件的最小正整数。对于一般余数的情形，《孙子算经》术文指出，只要把上述算法中的余数2、3、2分别换成新的余数就行了。以R1、R2、R3表示这些余数，那么《孙子算经》相当于给出公式N=70×R1+21×R2+15×R3－P×105（p是整数）。孙子算法的关键，在于70、21和15这三个数的确定。后来流传的《孙子歌》中所说“七十稀”、“廿一枝”和“正半月”，就是暗指这三个关键的数字。《孙子算经》没有说明这三个数的来历。实际上，它们具有如下特性：也就是说，这三个数可以从最小公倍数M=3×5×7=105中各约去模数3、5、7后，再分别乘以整数2、1、1而得到。假令k1=2，K2=1，K3=1，那么整数Ki（i=1，2，3）的选取使所得到的三数70、21、15被相应模数相除的时候余数都是1。由此出发，立即可以推出，在余数是R1、R2、R3的情况下的情况。应用上述推理，可以完全类似地把孙子算法推广到一般情形：设有一数N，分别被两两互素的几个数a1、a2、……an相除得余数R1、R2、……Rn，即N≡Ri（mod ai）（i=1、2、……n），只需求出一组数K，使满足1（mod ai）（i=1、2、……n），那么适合已给一次同余组的最小正数解是（P是整数，M=a1×a2×……×an），这就是现代数论中著名的剩余定理。如上所说，它的基本形式已经包含在《孙子算经》“物不知数”题的解法之中。不过《孙子算经》没有明确地表述这个一般的定理。 代码#include &lt;stdio.h&gt;using namespace std;#define P 23#define E 28#define I 33#define C 21252int main(void)&#123; int p, e, i, d; int x; int flag = 1; while (scanf(&quot;%d %d %d %d&quot;, &amp;p, &amp;e, &amp;i, &amp;d)&amp;&amp;p&gt;=0) &#123; p %= P; e %= E; i %= I; x = i; while (!((x - p) % P == 0 &amp;&amp; (x - e) % E == 0)) &#123; x += I; &#125; x -= d; if (x &lt;= 0) x += C; printf(&quot;Case %d: the next triple peak occurs in %d days.\\n&quot;, flag, x); flag++; &#125; return 0;&#125; 更新日志 2014年07月06日 已AC，完成中国剩余定理资料引用。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1005 I Think I Need a Houseboat","slug":"POJ-1005-I-Think-I-Need-a-Houseboat","date":"2014-07-06T19:04:08.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/06/POJ-1005-I-Think-I-Need-a-Houseboat/","link":"","permalink":"https://xuanwo.org/2014/07/06/POJ-1005-I-Think-I-Need-a-Houseboat/","excerpt":"题目源地址： http://poj.org/problem?id=1005 理解一块地按照50 square miles each year的速度被腐蚀，给定一个坐标要求计算到第几年的时候被腐蚀。自然是一道大水题：计算出给定坐标到原点的距离，取这个距离为半径求出实际的半圆面积，然后跟已经被腐蚀的面积比较一下即可。","text":"题目源地址： http://poj.org/problem?id=1005 理解一块地按照50 square miles each year的速度被腐蚀，给定一个坐标要求计算到第几年的时候被腐蚀。自然是一道大水题：计算出给定坐标到原点的距离，取这个距离为半径求出实际的半圆面积，然后跟已经被腐蚀的面积比较一下即可。 代码#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;#define PI 3.14float dis(float x, float y)&#123; return sqrt(x*x+y*y);&#125;int main()&#123; int n,year,flag; float x,y; flag=1; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;x&gt;&gt;y; year=1; while(100*year&lt;PI*dis(x,y)*dis(x,y)) year++; cout&lt;&lt;&quot;Property &quot;&lt;&lt;flag&lt;&lt;&quot;: This property will begin eroding in year &quot;&lt;&lt;year&lt;&lt;&quot;.&quot;&lt;&lt;endl; flag++; &#125; cout&lt;&lt;&quot;END OF OUTPUT.&quot;; return 0;&#125; 更新日志 2014年07月06日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1004 Financial Management","slug":"POJ-1004-Financial-Management","date":"2014-07-04T18:41:50.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/04/POJ-1004-Financial-Management/","link":"","permalink":"https://xuanwo.org/2014/07/04/POJ-1004-Financial-Management/","excerpt":"题目源地址： http://poj.org/problem?id=1004 理解额，就是求解12个数的平均数。不过据说POJ不能用lf，还要我没有遇到这样的问题，交了一个float水过。","text":"题目源地址： http://poj.org/problem?id=1004 理解额，就是求解12个数的平均数。不过据说POJ不能用lf，还要我没有遇到这样的问题，交了一个float水过。 代码#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int n=12; float money,sum=0; for(int i=0;i&lt;12;i++) &#123; cin&gt;&gt;money; sum+=money; &#125; printf(&quot;$%.2f&quot;, sum/12); return 0;&#125; 更新日志 2014年07月04日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1003 Hangover","slug":"POJ-1003-Hangover","date":"2014-07-04T07:33:55.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/04/POJ-1003-Hangover/","link":"","permalink":"https://xuanwo.org/2014/07/04/POJ-1003-Hangover/","excerpt":"题目源地址： http://poj.org/problem?id=1003 理解嗯哼，一道水题，用模拟水过。唯一自认为值得注意的地方是精度的问题，在比较的时候使用了两者之差小于0.001来判断他们是否相等。","text":"题目源地址： http://poj.org/problem?id=1003 理解嗯哼，一道水题，用模拟水过。唯一自认为值得注意的地方是精度的问题，在比较的时候使用了两者之差小于0.001来判断他们是否相等。 代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; float a, b = 0, i = 2; while (scanf(&quot;%f&quot;, &amp;a)&amp;&amp;a!=0) &#123; while (a-b&gt;0.001) &#123; b += 1 / i; i++; &#125; cout &lt;&lt; i-2 &lt;&lt; &apos; &apos; &lt;&lt; &quot;card(s)&quot; &lt;&lt; endl; b=0; i=2; &#125; return 0;&#125; 更新日志 2014年07月04日 已AC。","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"POJ 1002 487-3279","slug":"POJ-1002-487-3279","date":"2014-07-03T23:21:32.000Z","updated":"2016-08-03T04:19:54.402Z","comments":true,"path":"2014/07/03/POJ-1002-487-3279/","link":"","permalink":"https://xuanwo.org/2014/07/03/POJ-1002-487-3279/","excerpt":"题目源地址： http://poj.org/problem?id=1002 理解简单一看就是一道关于字典的题目，将ABC等字符转化为对应的数字，从而求出这个字符串所对应的电话号码。然后就是我不机智的地方了。我求出的电话号码依然是使用char数组类型保存的，比较的时候使用了strcmp函数，为了降低复杂度，还使用了各种标记，最后就是一团乱麻。在点拨之后才发现，直接转化为int型，然后sort排序，轻松搞定。","text":"题目源地址： http://poj.org/problem?id=1002 理解简单一看就是一道关于字典的题目，将ABC等字符转化为对应的数字，从而求出这个字符串所对应的电话号码。然后就是我不机智的地方了。我求出的电话号码依然是使用char数组类型保存的，比较的时候使用了strcmp函数，为了降低复杂度，还使用了各种标记，最后就是一团乱麻。在点拨之后才发现，直接转化为int型，然后sort排序，轻松搞定。 #新技能get以前就在困惑使用cout的时候如何控制它的输出形式，解题过程中，在cplusplus上面找到了一个库iomanip。通过setfill和setw函数的配合，解决了在数字之间插入一个-的问题。 代码# include &lt;iostream&gt;# include &lt;algorithm&gt;# include &lt;iomanip&gt;using namespace std;int normal(char a)&#123; &#123; if (a == &apos;A&apos; || a == &apos;B&apos; || a == &apos;C&apos;) return 2; if (a == &apos;D&apos; || a == &apos;E&apos; || a == &apos;F&apos;) return 3; if (a == &apos;G&apos; || a == &apos;H&apos; || a == &apos;I&apos;) return 4; if (a == &apos;J&apos; || a == &apos;K&apos; || a == &apos;L&apos;) return 5; if (a == &apos;M&apos; || a == &apos;N&apos; || a == &apos;O&apos;) return 6; if (a == &apos;P&apos; || a == &apos;R&apos; || a == &apos;S&apos;) return 7; if (a == &apos;T&apos; || a == &apos;U&apos; || a == &apos;V&apos;) return 8; if (a == &apos;W&apos; || a == &apos;X&apos; || a == &apos;Y&apos;) return 9; &#125;&#125;int time[10000000];bool vist[10000000];int out[100000];int main()&#123; int n; while (cin &gt;&gt; n) &#123; memset(time, 0, sizeof(time)); memset(vist, 0, sizeof(vist)); int positive = 0; bool flag = false; for (int i = 1; i &lt;= n; i++) &#123; int x = 0; char s[20]; cin &gt;&gt; s; for (int j = 0; s[j] != &apos;\\0&apos;; j++) &#123; if (s[j] == &apos;-&apos; || s[j] == &apos;Q&apos; || s[j] == &apos;Z&apos;) continue; else if (s[j] &lt;= &apos;9&apos;) x = x * 10 + s[j] - &apos;0&apos;; else if (s[j] &lt;= &apos;Z&apos;) x = x * 10 + normal(s[j]); &#125; time[x]++; if (!vist[x] &amp;&amp; time[x] &gt;= 2) &#123; flag = true; vist[x] = true; out[positive++] = x; &#125; &#125; if (!flag) cout &lt;&lt; &quot;No duplicates.&quot; &lt;&lt; endl; else &#123; sort(out, out + positive); for (int i = 0; i &lt; positive; i++) &#123; cout &lt;&lt; setfill(&apos;0&apos;) &lt;&lt; setw(3) &lt;&lt; out[i] / 10000; cout &lt;&lt; &apos;-&apos;; cout &lt;&lt; setfill(&apos;0&apos;) &lt;&lt; setw(4) &lt;&lt; out[i] % 10000; cout &lt;&lt; &apos; &apos; &lt;&lt; time[ out[i] ] &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; 更新日志 2014年07月03日 完成解题报告","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://xuanwo.org/categories/Exercise/"}],"tags":[]},{"title":"暑期刷题计划","slug":"summer-training-plan","date":"2014-07-03T20:04:23.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/07/03/summer-training-plan/","link":"","permalink":"https://xuanwo.org/2014/07/03/summer-training-plan/","excerpt":"前言我很喜欢Coding，也很喜欢AC那一刻的快感。为了追求这样的快感，我参加校赛，并且幸运的拿到了金牌，加入了CUGBACM的团体。但加入之后，我迷茫了。从学长学姐的口中，我知道我们学校的ACM并不是很强，甚至算得上弱校。参加了这么多年的比赛，我们从来没有出线过。每一年，我们都只能围观World Final的赛场，我们不停地刷新着List，不停地点评着清华为什么卡题卡这么久，不停地吐槽着CLJ拿到奖牌时的郁闷表情。心中其实一直有一个问题：为什么WF上，不能出现CUGB的队伍呢？这个问题真的很简单，我们太水。","text":"前言我很喜欢Coding，也很喜欢AC那一刻的快感。为了追求这样的快感，我参加校赛，并且幸运的拿到了金牌，加入了CUGBACM的团体。但加入之后，我迷茫了。从学长学姐的口中，我知道我们学校的ACM并不是很强，甚至算得上弱校。参加了这么多年的比赛，我们从来没有出线过。每一年，我们都只能围观World Final的赛场，我们不停地刷新着List，不停地点评着清华为什么卡题卡这么久，不停地吐槽着CLJ拿到奖牌时的郁闷表情。心中其实一直有一个问题：为什么WF上，不能出现CUGB的队伍呢？这个问题真的很简单，我们太水。 尽管如此，我们依然没有什么改变。我们依旧懒懒散散地刷着水题，我们依旧不能AK每一次讲解之后的习题，甚至在各种学校的校赛被虐场之后，我们依旧没有痛头彻骨的感悟。不知道是哪个学长对我说的，弱校无外交，弱队无人权。今年暑假，我们校队甚至都没有一个自己训练的场地！还要水到什么时候？今天晚上队长问我们计划暑假刷POJ多少题，我半开玩笑地说刷个520道，然后找妹纸表白。他又问了一遍，我想了想，终于下定了决心。一直说自己水，一直羞愧自己配不上金牌选手的称号，为什么不从现在起开始改变呢？我很清楚，我不是那种天赋超人的妖孽，我更清楚，可能努力之后，WF的赛场上，依旧不会出现CUGB的队徽。但是，我想试试看。 规则POJ账号 xuanwo计划9月22号之前完成题目520道，并且完成题解。同时，跟上校队的暑期集训，完成相应的训练。每周一更新已完成题目数。 更新 2014年07月03日 完成本文，目前已完成数6道。 2014年07月07日 Solved: 13 2014年07月14日 Solved: 26 2014年07月23日 Solved: 62 2014年08月06日 Solved: 106 2014年08月12日 Solved: 112 2014年08月20日 Solved: 185 2014年09月02日 Solved: 227","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[]},{"title":"为什么我最后选择了OneDrive","slug":"why-I-choose-onedrive","date":"2014-06-13T16:00:00.000Z","updated":"2016-08-03T04:19:54.422Z","comments":true,"path":"2014/06/13/why-I-choose-onedrive/","link":"","permalink":"https://xuanwo.org/2014/06/13/why-I-choose-onedrive/","excerpt":"前言我从很早开始就接受了网盘这个概念，大概是七年之前，我还在上小学六年级的时候吧= =。好像是2006年的《电脑报》合刊，在上面看到了关于QQ的网络硬盘的介绍，现在还清晰的记得，容量是16M，只有会员才能扩大，囧。然后就一直在寻找适合我用的给力的网盘。","text":"前言我从很早开始就接受了网盘这个概念，大概是七年之前，我还在上小学六年级的时候吧= =。好像是2006年的《电脑报》合刊，在上面看到了关于QQ的网络硬盘的介绍，现在还清晰的记得，容量是16M，只有会员才能扩大，囧。然后就一直在寻找适合我用的给力的网盘。 常见网盘介绍仔细想想，我体验的网盘真心不少了，下面来稍微列举一下，并附上官网链接。 国内：微云，百度云，金山快盘，115网盘，360云盘，DBank，够快，坚果云 国外：Dropbox，GoogleDrive(一般来说，打不开），Box 我的选择不过最后还是选择了微云+OneDrive的组合。原因很简单，整合。QQ与微云的整合，OneDrive的整合，没有烦人的提示，不需要多余的操作，隐藏了繁杂的界面，已经完全符合我的需求了。 下面具体地说一说微云和OneDrive的优势吧。 微云： 10T的大空间，可以用来存放一些视频之类的，比如Coursera上下载的视频啊神马的，存放一些经典的动漫也是极好的（貌似现在不行了） 跟QQ平台整合不错，从QQ群到手机端的QQ浏览器，都可以很轻松的把文件转存到微云，发一些复习资料什么的特别赞。 Tencent是大公司了，数据安全性什么的，还是有保障的。 OneDrive 与Win8.1深度的系统整合，在非Metro界面下没有累赘的窗口，好评。 国内可以正常使用的国外网盘，出于众所周知的原因，不管是GoogleDrive还是DropBox都时不时的会抽筋，着实不爽。 后记其实还是蛮期待真正的云端生活的，要是有朝一日能去美帝，我一定弄个Chrome笔记本= =。 更新日志 2014年06月13日 初稿 2014年06月13日 BUG修正 2014年07月03日 Onedrive已崩溃，频繁出现APPCRASH= =，这是打我脸啊。。。 2014年07月04日 好吧，Onedrive在中国大陆被墙。 2015年05月22日 微云归腾讯QQ空间管了- -，各种黄钻推广，已经放弃微云了。 2016年02月26日 现在以Google Drive为主，本文不再更新","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"}]},{"title":"ACM队友们的博客","slug":"acm-teammates-blog","date":"2014-06-12T15:00:00.000Z","updated":"2016-08-03T04:19:54.414Z","comments":true,"path":"2014/06/12/acm-teammates-blog/","link":"","permalink":"https://xuanwo.org/2014/06/12/acm-teammates-blog/","excerpt":"","text":"2009级 JoinHands http://blog.csdn.net/wsniyufang 2010级 Alan http://blog.csdn.net/cugb1004101218 maddoctor http://blog.csdn.net/sdj222555 walk_upon http://blog.csdn.net/walk_upon 2011级 kdqzzxxcc http://blog.csdn.net/just_water 止于至善 http://blog.csdn.net/qq415200973 2012级 聂小白 http://blog.csdn.net/q295657451 FreeMeepo http://www.freemeepo.com/acm/ 昊天 http://blog.csdn.net/ooooooooe 潇洒走一回 http://blog.csdn.net/u011466175 SIO__Five http://SIOFive.github.io/ 2013级 康逗 http://blog.csdn.net/zxk422/ Isco http://blog.csdn.net/chenyuwen666 浮沉独步 http://blog.csdn.net/u013588639 Peter http://blog.csdn.net/userluoxuan Fly in the s http://blog.csdn.net/mjoinir Every Day http://blog.csdn.net/u013044116","categories":[{"name":"Daily","slug":"Daily","permalink":"https://xuanwo.org/categories/Daily/"}],"tags":[]},{"title":"使用Github Pages做博客的新思路——Spring","slug":"new-way-blog-spring","date":"2014-06-11T14:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/06/11/new-way-blog-spring/","link":"","permalink":"https://xuanwo.org/2014/06/11/new-way-blog-spring/","excerpt":"前言很久之前就有了想要有一个自己的博客的想法，一直没有付诸于实施。整个初中到高中基本上就是在使用一个半死不活的CSDN博客，更新不多，质量不高，还有点嫌弃它丑陋，定制性不佳的界面。前两天队长要求我们每个人都必须开通一个博客，于是，我终于开始腾出精力和时间去寻找一个合适的地方来做我的博客。现有的一些博客提供商都被否决了，网易搜狐腾讯之类的并不是适合一个程序猿，文章写出来也得不到反馈与交流，失去了它的意义。随着搜索的进行，Github Pages开始频繁的出现在页面上。之前一直在用Github，但是对它的Pages业务并不了解。根据一些教程（感谢阮一峰先生的博客），我先后使用了Hexo，Jekyll，Octopress等生成网站。网站的风格我很喜欢，只是不停地纠结于怎样的配置更好的问题，反而加重了我自己的负担。无意之间，我看到了@zhaoda的博客，使用自己开发的Spring项目，通过抓取项目的issues来撰写博客，效果出奇的好。使用Github自带的lables进行标签管理，issues的评论功能直接可以当做文章的评论区，操作简单，无需复杂配置，完全符合我的要求。","text":"前言很久之前就有了想要有一个自己的博客的想法，一直没有付诸于实施。整个初中到高中基本上就是在使用一个半死不活的CSDN博客，更新不多，质量不高，还有点嫌弃它丑陋，定制性不佳的界面。前两天队长要求我们每个人都必须开通一个博客，于是，我终于开始腾出精力和时间去寻找一个合适的地方来做我的博客。现有的一些博客提供商都被否决了，网易搜狐腾讯之类的并不是适合一个程序猿，文章写出来也得不到反馈与交流，失去了它的意义。随着搜索的进行，Github Pages开始频繁的出现在页面上。之前一直在用Github，但是对它的Pages业务并不了解。根据一些教程（感谢阮一峰先生的博客），我先后使用了Hexo，Jekyll，Octopress等生成网站。网站的风格我很喜欢，只是不停地纠结于怎样的配置更好的问题，反而加重了我自己的负担。无意之间，我看到了@zhaoda的博客，使用自己开发的Spring项目，通过抓取项目的issues来撰写博客，效果出奇的好。使用Github自带的lables进行标签管理，issues的评论功能直接可以当做文章的评论区，操作简单，无需复杂配置，完全符合我的要求。 作者本人的介绍Spring是一个通过GitHub Issues撰写内容的博客引擎，或者说是一个简单、静态化的建站系统。不需要服务器和数据库支持，你可以把它作为一个GitHub代码仓库，并托管在免费的GitHub Pages上运行，然后在这个仓库的Issues系统里撰写日志。你可以在这个仓库的Issues系统里添加labels标签，这些标签会成为博客的分类，然后新建Issues，并用Markdown语法写日志。Spring拥有响应式的页面设计，可以在手机、平板和桌面端完美展现；支持IE10+和所有现代浏览器，底端设备做了跳转的降级处理。你可以快速的安装并运行这个系统。 构建步骤接下来，我简单介绍一下如何应用Spring来构建自己的博客。 Fork仓库Spring 修改仓库名称为yourname.github.io 修改index.html文件（可以在Github网页端修改好之后再同步到本地） $.extend(spring.config, &#123;// my blog title---title: &apos;Your Blog title&apos;,// my blog descriptiondesc: &quot;A blog engine written by github issues [Fork me on GitHub](https://github.com/zhaoda/spring)&quot;,// my github usernameowner: &apos;Your Github username&apos;,// creator&apos;s usernamecreator: &apos;Your Github username&apos;,// the repository name on github for writting issuesrepo: &apos;yourname.github.io&apos;,// custom pagepages: []&#125;) 在设置页面中打开Issues功能，开始写你的博客吧～ 添加百度统计代码复制百度提供的代码，粘贴到index.html中&lt;body&gt;与&lt;\\body&gt;之间即可。添加完毕后，可以在百度统计中选择检测代码来测试自己的代码是否安装成功。其他统计代码也是一样。 更新日志 2014年06月11日 完成初稿 2014年06月12日 完成添加百度统计代码教程 2014年07月03日 整体博客迁移至Hexo，此文不再更新","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Github-Pages","slug":"Github-Pages","permalink":"https://xuanwo.org/tags/Github-Pages/"},{"name":"Blog","slug":"Blog","permalink":"https://xuanwo.org/tags/Blog/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://xuanwo.org/tags/JavaScript/"}]},{"title":"Sublime Text 3 化身为高大上的C/C++ IDE","slug":"sublime-text-3-IDE","date":"2014-06-05T23:00:00.000Z","updated":"2016-08-03T04:19:54.418Z","comments":true,"path":"2014/06/05/sublime-text-3-IDE/","link":"","permalink":"https://xuanwo.org/2014/06/05/sublime-text-3-IDE/","excerpt":"前言我是一只有着小小的强迫症的苦逼菜鸟，敲代码追求一个爽快。原来一直在用Code::Blocks，虽然说是用C++开发的，效率很高，但是每次启动的时候总是要盯着它不怎么样的启动页看很久，不开心= =。这两天开始接触Sublime Text，顿时被迷住了，不管不顾的决定把它改造成一个狂霸酷拽屌的IDE，所以，走你～～","text":"前言我是一只有着小小的强迫症的苦逼菜鸟，敲代码追求一个爽快。原来一直在用Code::Blocks，虽然说是用C++开发的，效率很高，但是每次启动的时候总是要盯着它不怎么样的启动页看很久，不开心= =。这两天开始接触Sublime Text，顿时被迷住了，不管不顾的决定把它改造成一个狂霸酷拽屌的IDE，所以，走你～～ 安装以下均为Sublime Text 3 3083版 更新于26 March 2015 OS Xhttp://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203083.dmg Windows 32 bithttp://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203080%20Setup.exe Windows 64 bithttp://c758482.r82.cf2.rackcdn.com/Sublime%20Text%20Build%203080%20x64%20Setup.exe Ubuntu 32 bithttp://c758482.r82.cf2.rackcdn.com/sublime-text_build-3080_i386.deb Ubuntu 64 bithttp://c758482.r82.cf2.rackcdn.com/sublime-text_build-3080_amd64.deb 运行环境Windows下以MinGW为例，其他编译系统类似 下载安装MinGW有被墙的风险，如果不能访问，请在某管，某三的软件管家中搜索MinGWhttp://sourceforge.net/projects/mingw/files/ 添加系统环境变量默认条件下是C:/MinGW/bin，如果不是请自行修改，将其添加到PATH之后，记得不要忘记分号。如果不知道如何修改系统环境变量，请参考http://www.java.com/zh_CN/download/help/path.xml 运行CMD(开始-&gt; 运行-&gt; Cmd)，输入：mingw-get后则会运行MinGW界面，这里说明变量设置成功。然后输入：g++ -v，用于检测安装g++有没有成功。 建立新的编译系统Tools –&gt; Build System –&gt; New Build System在打开的页面中粘贴以下代码 &#123; &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&quot;, &quot;start&quot;, &quot;cmd&quot;, &quot;/c&quot;, &quot;$&#123;file_base_name&#125; &amp; echo. &amp; pause&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;, &quot;shell&quot;: true, &quot;encoding&quot;:&quot;cp936&quot;,&#125; 保存，并且取一个自己喜欢的名字，在Tools-&gt;Build System中选择即可。 如果复制出现问题，请访问 https://gist.github.com/Xuanwo/0cb4bce76929ed764daf Linux下以Ubuntu为例，系统不同请自行修改终端参数。建立新的编译系统Tools –&gt; Build System –&gt; New Build System在打开的页面中粘贴以下代码 &#123; &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&quot;, &quot;gnome-terminal&quot;, &quot;-x&quot;, &quot;bash&quot;, &quot;-c&quot;, &quot;g++ &apos;$&#123;file&#125;&apos; -o &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos; &amp;&amp; &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos; ;read -n1 -p &apos;press any key to continue.&apos;&quot;], &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;, &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;, &quot;selector&quot;: &quot;source.c, source.c++&quot;,&#125; 保存，并且取一个自己喜欢的名字，在Tools-&gt;Build System中选择即可。 如果复制出现问题，请访问 https://gist.github.com/Xuanwo/31ac95e82d446db37c2e 收工一个简单的IDE已经构建完毕了，下面可以进行一些简单的测试。 编译并运行Ctrl+B 配置界面字体、主题风格等设置当需要更改主题时，直接可以通过Preferences —&gt; Color Scheme来设置，主界面上只能改变字体的大小。若需要改变字体和字体大小，可以先Preferences —&gt; Browse Packages，找到Default文件夹，然后找到Preferences.sublime-settings这个文件，用Sublime Text 3打开这个文件，这个文件保存了一些常用的设置，比如字体、主题风格、是否显示行号、智能提示延迟时间等，可以根据自己的需要自行设置。 打开（关闭）侧边栏、右边缩略图等常用面板默认情况下Sublime Text 3是没有打开侧边栏文件浏览器的，可以通过View来打开和关闭侧边栏，默认情况下Sublime Text 3右边是有文件的缩略图的，可以通过View来打开和关闭缩略图。 快捷键寻找文件和已定义的函数在Sublime Text 3中可以非常快速地切换到想找的文件，只需要通过Ctrl+P打开切换面板即可。然后输入想找的文件名称就可以快速找切换到该文件了。如果想要找函数，可以通过输入@+函数名可以快速切换到定义该函数的文件。 插件Package Control必装的插件，有了它可以很方便的安装和管理其他的插件。 使用快捷键ctrl+反斜杠或者 View -&gt; Show Console打开命令行，粘贴以下代码： import urllib.request,os,hashlib; h = &apos;eb2297e1a458f27d836c04bb0cbaf282&apos; + &apos;d0e7a3098092775ccb37ca9d6b2e4b7d&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 如果复制出现问题，请访问https://gist.github.com/Xuanwo/fd4e4388099536bcdd65 ConvertToUTF8此插件可以有效的解决中文乱码问题 Ctrl+P打开切换面板，输入PackageControl回车，打开包管理。输入或者点击install进入安装页面，等待片刻后，在新弹出的窗口中输入ConvertToUTF8，点击它便开始自动下载安装。 如果出现乱码，只要在File里面找到Encoding并选择合适的编码模式即可，快捷键Ctrl+Shift+C。 AStyleFormatterSublime Text 3下的C/C++代码整理工具，好像还支持java Ctrl+P打开切换面板，输入PackageControl回车，打开包管理。输入或者点击install进入安装页面，等待片刻后，在新弹出的窗口中输入AStyleFormatter，点击它便开始自动下载安装。 使用时只要在代码编辑页面右击，选择AStyleFormatter-&gt;Format即可,快捷键为Ctrl+Alt+F。 InsertDate顾名思义，此插件用于在文中快速插入时间Ctrl+P打开切换面板，输入PackageControl回车，打开包管理。输入或者点击install进入安装页面，等待片刻后，在新弹出的窗口中输入InsertDate，点击它便开始自动下载安装。 默认的键位需要用到F5键，但是ThinkPad默认状态下需要同时按Fn才能使用F5，所以修改一下键位吧。 点击Preferences-&gt;Key Bindings - Users，打开自定义键位设置，输入如下代码： [ &#123; &quot;keys&quot;: [&quot;ctrl+m&quot;], //ctrl+m可以换成任意一组没有冲突的组合键 &quot;command&quot;: &quot;insert_date&quot;, &quot;args&quot;: &#123;&quot;format&quot;: &quot;%H:%M:%S&quot;&#125; &#125;,] 这样，不管在什么状态下，我都能用Ctrl+m输入当前时间了～ 代码片段(snippet)功能点击Tools-&gt;New Snippet之后，会新建一个文件，内容如下： &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;. //这里输入你想要键入的代码～]]&gt;&lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt; //这里把hello换成你想要使用的快捷键。 &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt; //这里选择起作用的文件类型&lt;/snippet&gt; 设置完毕之后，Ctrl+S保存，默认会保存在User文件夹下，为了方便管理，不妨新建一个Snippet文件夹，后缀名为.sublime-snippet。保存好之后，就可以使用啦～用我自己的一个Snippet文件举例： &lt;snippet&gt; &lt;content&gt;&lt;![CDATA[#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;list&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;numeric&gt;#include &lt;iomanip&gt;#include &lt;bitset&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;#define debug puts(&quot;-----&quot;)#define pi (acos(-1.0))#define eps (1e-8)#define inf (1&lt;&lt;30)using namespace std;]]&gt; &lt;/content&gt; &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt; &lt;tabTrigger&gt;#init&lt;/tabTrigger&gt; &lt;description&gt;C/C++ header file&lt;/description&gt; //描述信息，可选 &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt; &lt;scope&gt;source.c, source.c++&lt;/scope&gt;&lt;/snippet&gt; 该文件起到的作用就是，当我输入#init并敲击Tab时，会自动将#init转换成我预先设定的代码。 备份配置到现在，Sublime也算用的顺手了，要是换一台电脑都得这么捣鼓一下，肯定得疯。所以下面介绍一下如何同步自己的Sublime配置——只要备份Packages\\User文件夹即可，里面的sublime-settings文件都保存了你的所有设置，更换电脑之后，只要恢复过去，打开Sublime的时候会自动检测，下载并安装你需要的包。 Windows下备份文件夹：C:\\Users\\yourusername\\AppData\\Roaming\\Sublime Text 3\\Packages\\User Linux下备份文件夹：~/Library/Application/Support/Sublime\\ Text\\ 3/Packages/User注意空格的转义= =。rm -rf /usr /balabala之类的梗我才没有听说过呢。 尾言出于个人喜好，没有附带汉化以及破解教程。 毕竟是用来敲代码的，软件本身是英文的还是中文的其实影响不大，所以费尽心思折腾汉化没有什么意思。此外，支持正版从我做起，ST的作者并没有刻意的进行反盗版处理，使用一些简单的汇编工具就可以进行破解，但是出于对作者的尊重，我没有这样做。因为就算是未破解版也不过是跳出一个提示窗口而已，功能完全没有阉割，已经非常厚道了。总之，求汉化，求破解的人可以去Google看看，这里是不会有了。 本文仓促完工，如果有不正确的地方请在下方评论窗口指出，谢谢。 更新日志 2014年06月05日 写完全文，观察效果，并发布 2014年07月03日 博客迁移至Hexo，做细节调整 2014年08月08日 添加了Sublime在Linux下的.buildsystem代码 2014年08月16日 添加了关于Snippet功能和快速插入时间插件的介绍。 2014年08月22日 添加了关于备份Sublime设定的介绍 2014年09月01日 更新Sublime Text 3下载链接至3065版本，增加Changelog，修改下载地址。 2015年01月06日 采纳读者建议，修改了编译系统部分的文字，现在更加容易懂了~ 2015年03月25日 新版本的Build变得有点傻逼- -，重新修改了sublime-build，现在只需要一次按键就能编译并运行了~，Linux下没有进行测试，求反馈。 2015年06月30日 更新Sublime Text 3下载链接至3083版本，更新了Toc上的BUG，修复了Package Control的安装脚本。 2015年07月01日 去除了有些累赘的更新信息 2015年09月02日 修复了一些排版上的BUG 2016年02月26日 博主主力编辑器已切换至Neovim，本文不再维护，敬请谅解","categories":[{"name":"Opinion","slug":"Opinion","permalink":"https://xuanwo.org/categories/Opinion/"}],"tags":[{"name":"Software","slug":"Software","permalink":"https://xuanwo.org/tags/Software/"},{"name":"C","slug":"C","permalink":"https://xuanwo.org/tags/C/"}]}]}